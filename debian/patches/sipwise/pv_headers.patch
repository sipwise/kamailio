--- a/Makefile.groups
+++ b/Makefile.groups
@@ -15,7 +15,7 @@
 				   nat_traversal nathelper path pike pv ratelimit rr rtimer \
 				   rtpproxy sanity sdpops siputils sl statistics textops \
 				   textopsx tm tmx topoh xlog rtpengine stun sipt tcpops \
-				   auth_xkeys smsops tsilo cfgt statsc topos
+				   auth_xkeys smsops tsilo cfgt statsc topos pv_headers
 
 # - extra used modules, with no extra dependency
 mod_list_extra=avp auth_diameter call_control dmq domainpolicy msrp pdb \
--- /dev/null
+++ b/modules/pv_headers/Makefile
@@ -0,0 +1,14 @@
+#
+# pv_headers module makefile
+#
+# 
+# WARNING: do not run this directly, it should be run by the master Makefile
+
+include ../../Makefile.defs
+auto_gen=
+NAME=pv_headers.so
+LIBS=
+
+DEFS+=-DKAMAILIO_MOD_INTERFACE
+
+include ../../Makefile.modules
--- /dev/null
+++ b/modules/pv_headers/README
@@ -0,0 +1,209 @@
+The pv_headers Module
+
+Kirill Solomko
+
+   Sipwise GmbH
+
+   Copyright Â© 2018 Sipwise GmbH
+     __________________________________________________________________
+
+   Table of Contents
+
+    1. Admin Guide
+
+        1. Dependencies
+
+              1.1. Kamailio modules
+
+        2. Parameters
+
+              2.1. xavp_name (string)
+
+        3. Functions
+
+              3.1. pv_collect_headers()
+              3.2. pv_apply_headers()
+              3.3. pv_check_header(hname)
+              3.3. pv_append_header(hname, hvalue)
+              3.3. pv_modify_header(hname, hvalue)
+              3.3. pv_remove_header(hname)
+
+1. Design Goals
+
+    The main goal of the module is to offload the intermediate header processing
+    into the XAVP dynamic container as well as providing with high level methods
+    for collecting the headers, applying the headers and manipulating the XAVP.
+
+2. Overview of Operation
+
+    This module enables storing all headers in XAVP to freely modify
+    them in the kamailio logic and only apply them once when it's time
+    for the packet to be routed outside.
+
+Chapter 1. Admin Guide
+
+    Table of Contents
+
+    1. Dependencies
+
+        1.1. Kamailio modules
+
+    2. Parameters
+
+        2.1. xavp_name (string)
+
+    3. Functions
+
+        3.1. pv_collect_headers()
+        3.2. pv_apply_headers()
+        3.3. pv_check_header(hname)
+        3.3. pv_append_header(hname, hvalue)
+        3.3. pv_modify_header(hname, hvalue)
+        3.3. pv_remove_header(hname)
+
+1. Dependencies
+
+    1.1. Kamailio modules
+
+1.1. Kamailio modules
+
+    The following modules must be loaded before this module:
+        * none
+
+2. Parameters
+
+    2.1. xavp_name (string)
+
+2.1. xavp_name (string)
+
+    Name of the XAVP there the collected headers are stored.
+
+    Default: headers
+
+    Example 1.1. Set xavp_name parameter
+modparam("pv_headers", "xavp_name", "headers")
+
+    Result:
+        $xavp(headers[0]=>From)
+        $xavp(headers[0]=>To)
+        $xavp(headers[0]=>Call-ID)
+        ....
+
+3. Functions
+
+    3.1. pv_collect_headers()
+    3.2. pv_apply_headers()
+    3.3. pv_check_header(hname)
+    3.3. pv_append_header(hname, hvalue)
+    3.3. pv_modify_header(hname, hvalue)
+    3.3. pv_remove_header(hname)
+
+3.1.  pv_collect_headers()
+
+    This function collects all headers from the message into the XAVP,
+    it should be used preferably just when the message is delievered.
+
+    Returns:
+     1 - on success
+    -1 - if there were errors
+
+3.2.  pv_apply_headers()
+
+    This function applies the current XAVP headers state to the real headers.
+    and should be called only once when the message is about to leave kamailio.
+
+    The following rules apply:
+
+    - all headers in the XAVP are recreated in the message.
+    - headers with NULL value are going to be removed if exist in the message.
+    - the initial order of the headers from how they were collected from the message is preserved.
+
+    Usage:
+
+        if (pv_apply_headers())
+        {
+            "success"
+        }
+        else
+        {
+            "errors"
+        }
+
+
+3.3.  pv_check_header(hname)
+
+    This function checks if the header already exists in the XAVP.
+    It can be freely called from anywere, but only after pv_collect_headers.
+
+    Usage:
+
+        if (pv_check_header(hname))
+        {
+            "exists"
+        }
+        else
+        {
+            "does not exist"
+        }
+
+
+3.4.  pv_append_header(hname, hvalue)
+
+    This function appends a new header into the XAVP.
+    It can be freely called from anywere, but only after pv_collect_headers.
+
+    Please note that subsequent "pv_append_header" calls will result in multiple
+    headers with the same.
+
+    If the provided "hvalue" is $null then the header is added into the XAVP
+    but it is not going to be added into the message.
+
+    Usage:
+
+        if (pv_append_header(hname, hvalue))
+        {
+            "appended"
+        }
+        else
+        {
+            "errors"
+        }
+
+3.5.  pv_modify_header(hname, hvalue)
+
+    This function modifies an existing header in the XAVP.
+    It can be freely called from anywere, but only after pv_collect_headers.
+
+    Please note that if a header does not exist it will be implicitly appended.
+
+    If the provided "hvalue" is $null then the header is modified in the XAVP
+    but it is not going to be added into the message.
+
+    Usage:
+
+        if (pv_modify_header(hname, hvalue))
+        {
+            "modified"
+        }
+        else
+        {
+            "errors"
+        }
+
+3.6.  pv_remove_header(hname)
+
+    This function removes an existing header from the XAVP.
+    It can be freely called from anywere, but only after pv_collect_headers.
+
+    It returns "false" if the header does not exist.
+
+    Usage:
+
+        if (pv_modify_header(hname, hvalue))
+        {
+            "removed"
+        }
+        else
+        {
+            "does not exist or errors"
+        }
--- /dev/null
+++ b/modules/pv_headers/pv_headers.c
@@ -0,0 +1,315 @@
+/*
+ * AVP Headers
+ *
+ * Copyright (C) 2018 Kirill Solomko
+ *
+ * This file is part of SIP Router, a free SIP server.
+ *
+ * SIP Router is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * SIP Router is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "../../sr_module.h"
+#include "../../mod_fix.h"
+#include "../../dprint.h"
+#include "../../xavp.h"
+#include "../../pvar.h"
+#include "../../data_lump.h"
+#include "../../parser/msg_parser.h"
+
+MODULE_VERSION
+
+#define MODULE_NAME "pv_headers"
+
+#define XAVP_NAME "headers"
+
+static str xavp_name = str_init(XAVP_NAME);
+
+static void destroy(void);
+static int mod_init(void);
+
+static int pv_collect_headers(struct sip_msg* msg, char* _s1, char* _s2);
+static int pv_apply_headers(struct sip_msg* msg, char* _s1, char* _s2);
+
+static int pv_check_header(struct sip_msg* _m, char* hname, char* _s2);
+static int pv_append_header(struct sip_msg* _m, char* hname, char* value);
+static int pv_modify_header(struct sip_msg* _m, char* hname, char* modify);
+static int pv_remove_header(struct sip_msg* _m, char* hname, char* _s2);
+
+static int pv_set_xavp(str *xname, str *name, str *val);
+static int pv_free_xavp(str *xname);
+
+static int pv_fixup_svalue(struct sip_msg* msg, char* src, str* dst);
+
+/*
+ * Exported functions
+ */
+static cmd_export_t cmds[] = {
+    {"pv_collect_headers", (cmd_function)pv_collect_headers, 0, 0, 0, ANY_ROUTE},
+    {"pv_apply_headers", (cmd_function)pv_apply_headers, 0, 0, 0, ANY_ROUTE},
+    {"pv_check_header", (cmd_function)pv_check_header, 1, fixup_spve_null, fixup_free_spve_null, ANY_ROUTE},
+    {"pv_append_header", (cmd_function)pv_append_header, 2, fixup_spve_spve, fixup_free_spve_spve, ANY_ROUTE},
+    {"pv_modify_header", (cmd_function)pv_modify_header, 2, fixup_spve_spve, fixup_free_spve_spve, ANY_ROUTE},
+    {"pv_remove_header", (cmd_function)pv_remove_header, 1, fixup_spve_null, fixup_free_spve_null, ANY_ROUTE},
+    {0, 0, 0, 0, 0, 0}
+};
+
+
+static param_export_t params[] = {
+    {"xavp_name", PARAM_STR, &xavp_name},
+    {0, 0, 0}
+};
+
+struct module_exports exports = {
+	MODULE_NAME,
+	DEFAULT_DLFLAGS, /* dlopen flags */
+	cmds,      /* Exported functions */
+	params,    /* Exported parameters */
+	0,         /* exported statistics */
+	0,         /* exported MI functions */
+	0,         /* exported pseudo-variables */
+	0,         /* extra processes */
+	mod_init,  /* module initialization function */
+	0,         /* response function */
+	destroy,   /* destroy function */
+	0          /* child initialization function */
+};
+
+static int mod_init(void)
+{
+    LM_INFO("%s module init...\n", MODULE_NAME);
+    return 0;
+}
+
+static void destroy(void)
+{
+    pv_free_xavp(&xavp_name);
+    LM_INFO("%s module unload...\n", MODULE_NAME);
+}
+
+static int pv_collect_headers(struct sip_msg* msg, char* _s1, char* _s2)
+{
+    struct hdr_field *hdr = NULL;
+    str name, val;
+    char hname[255], hval[255];
+
+    if (parse_headers(msg, HDR_EOH_F, 0) < 0)
+    {
+        LM_ERR("error parsing headers\n");
+        return -1;
+    }
+
+    for (hdr=msg->headers; hdr; hdr=hdr->next)
+    {
+        if (hdr->name.len == 12 && strncasecmp(hdr->name.s, "Record-Route", 12)==0)
+            continue;
+        if (hdr->name.len == 3  && strncasecmp(hdr->name.s, "Via", 3)==0)
+            continue;
+        //LM_INFO("header[%.*s]: %.*s\n", hdr->name.len, hdr->name.s, hdr->body.len, hdr->body.s);
+
+        memcpy(&hval, hdr->body.s, hdr->body.len);
+        hval[hdr->body.len] = '\0';
+        val.s = hval;
+        val.len = hdr->body.len;
+
+        memcpy(&hname, hdr->name.s, hdr->name.len);
+        hname[hdr->name.len] = '\0';
+        name.s = hname;
+        name.len = hdr->name.len;
+
+        if (pv_set_xavp(&xavp_name, &name, &val) < 0)
+            break;
+    }
+
+    return 1;
+}
+
+static int pv_apply_headers(struct sip_msg* msg, char* _s1, char* _s2)
+{
+    sr_xavp_t *xavp = NULL;
+    sr_xavp_t *sub = NULL;
+    sr_xavp_t *list[64];
+    int l_idx = 0;
+
+    xavp = xavp_get(&xavp_name, NULL);
+    if (xavp == NULL)
+    {
+        LM_ERR("missing xavp %s, run pv_collect_headers() first\n", xavp_name.s);
+        return -1;
+    }
+
+    if (xavp->val.type != SR_XTYPE_XAVP)
+    {
+        LM_ERR("not xavp child type %s\n" , xavp_name.s);
+        return -1;
+    }
+
+    if (xavp && xavp->val.type == SR_XTYPE_XAVP)
+        sub = xavp->val.v.xavp;
+
+    while (sub)
+    {
+        *(list+l_idx++) = sub;
+        sub = sub->next;
+    }
+
+    while (--l_idx >= 0) {
+        sub = *(list+l_idx);
+        //LM_INFO("A: %s -- %s\n", sub->name.s, sub->val.v.s.s);
+        sr_hdr_del_z(msg, sub->name.s);
+        if (sub->val.type != SR_XTYPE_NULL)
+            sr_hdr_add_zs(msg, sub->name.s, &sub->val.v.s);
+    }
+
+    return 1;
+}
+
+static int pv_check_header(struct sip_msg* msg, char* hname, char* _s2)
+{
+    str hname_s;
+
+    if (hname == NULL || pv_fixup_svalue(msg, hname, &hname_s) < 0)
+        return -1;
+
+    if (xavp_get_child(&xavp_name, &hname_s) == NULL)
+        return -1;
+
+    return 1;
+}
+
+static int pv_append_header(struct sip_msg* msg, char* hname, char* hvalue)
+{
+    str hname_s, hvalue_s;
+
+    if (hname == NULL || pv_fixup_svalue(msg, hname, &hname_s) < 0)
+        return -1;
+
+    if (hvalue != NULL)
+        if (pv_fixup_svalue(msg, hvalue, &hvalue_s) < 0)
+            return -1;
+
+    return pv_set_xavp(&xavp_name, &hname_s, &hvalue_s);
+}
+
+static int pv_modify_header(struct sip_msg* msg, char* hname, char* hvalue)
+{
+    str hname_s, hvalue_s;
+
+    if (hname == NULL || pv_fixup_svalue(msg, hname, &hname_s) < 0)
+        return -1;
+
+    if (hvalue != NULL)
+        if (pv_fixup_svalue(msg, hvalue, &hvalue_s) < 0)
+            return -1;
+
+    LM_INFO("M hname: %s hvalue: %s\n", hname_s.s, hvalue_s.s);
+
+    return pv_set_xavp(&xavp_name, &hname_s, &hvalue_s);
+}
+
+static int pv_remove_header(struct sip_msg* msg, char* hname, char* _s2)
+{
+    str hname_s;
+
+    if (hname == NULL || pv_fixup_svalue(msg, hname, &hname_s) < 0)
+        return -1;
+
+    return pv_set_xavp(&xavp_name, &hname_s, NULL);
+}
+
+static int pv_set_xavp(str *xname, str *name, str *val)
+{
+
+    sr_xavp_t **xavp = NULL;
+    sr_xavp_t *root = NULL;
+    sr_xavp_t *new = NULL;
+    sr_xavp_t *sub = NULL;
+    sr_xval_t xval;
+    int idx_f = 0;
+
+    if (xname == NULL || name == NULL)
+    {
+        LM_ERR("missing xavp/pv name\n");
+        return -1;
+    }
+
+    memset(&xval, 0, sizeof(sr_xval_t));
+    if (val == NULL)
+        xval.type = SR_XTYPE_NULL;
+    else
+        xval.type = SR_XTYPE_STR;
+    if (val != NULL)
+        xval.v.s = *val;
+
+    //LM_INFO("SET: %s=>%s = %s\n", xname->s, name->s, xval.v.s.s);
+
+    root = xavp_get(xname, NULL);
+    xavp = root ? &root->val.v.xavp : &new;
+    if (xavp)
+        sub = xavp_get_child(xname, name);
+    if (sub == NULL)
+    {
+        //LM_INFO("XAVP ADD\n");
+
+        if (xavp_add_value(name, &xval, xavp) == NULL)
+        {
+            LM_ERR("error creating xavp=>name %s=>%s\n", xname->s, name->s);
+            xavp_destroy_list(xavp);
+            return -1;
+        }
+        if (root == NULL)
+        {
+            //LM_INFO("XAVP NEW\n");
+            memset(&xval, 0, sizeof(sr_xval_t));
+            xval.type = SR_XTYPE_XAVP;
+            xval.v.xavp = *xavp;
+            if(xavp_add_value(xname, &xval, NULL)==NULL)
+            {
+                LM_ERR("error creating xavp=>name %s=>%s\n", xname->s, name->s);
+                xavp_destroy_list(xavp);
+                return -1;
+            }
+        }
+    } else {
+        //LM_INFO("XAVP SET: %s -- %s -> %s\n", sub->name.s, sub->val.v.s.s, xval.v.s.s);
+        if (!xavp_set_value(name, idx_f, &xval, xavp)) {
+            LM_ERR("error setting xavp value xavp=>name %s=>%s\n", xname->s, name->s);
+            return -1;
+        }
+    }
+
+    return 1;
+}
+
+static int pv_free_xavp(str* xname)
+{
+    xavp_rm_by_name(&xavp_name, 1, NULL);
+    return 1;
+}
+
+static int pv_fixup_svalue(struct sip_msg* msg, char* src, str* dst)
+{
+    if (fixup_get_svalue(msg, (gparam_p)src, dst) < 0)
+    {
+        LM_ERR("Unable to parse param value\n");
+        return -1;
+    }
+    return 1;
+}
+
--- /dev/null
+++ b/modules/pv_headers/pv_headers.h
@@ -0,0 +1,30 @@
+/*
+ * $Id$
+ *
+ * PV Headers
+ *
+ * Copyright (C) 2018 Kirill Solomko
+ *
+ * This file is part of SIP Router, a free SIP server.
+ *
+ * SIP Router is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * SIP Router is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef PV_HEADERS_H
+#define PV_HEADERS_H
+
+
+#endif /* PV_HEADERS_H */
