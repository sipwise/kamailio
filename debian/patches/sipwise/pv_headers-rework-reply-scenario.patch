From: Victor Seva <vseva@sipwise.com>
Date: Tue, 14 Jan 2020 14:16:42 +0100
Subject: pv_headers: rework reply scenario
---
 src/modules/pv_headers/pv_headers.c | 22 ++++------
 src/modules/pv_headers/pvh_func.c   |  4 ++
 src/modules/pv_headers/pvh_xavp.c   | 87 +++++++++++++++++++++++--------------
 src/modules/pv_headers/pvh_xavp.h   |  2 +-
 4 files changed, 69 insertions(+), 46 deletions(-)

diff --git a/src/modules/pv_headers/pv_headers.c b/src/modules/pv_headers/pv_headers.c
index 9730847..1cf53a7 100644
--- a/src/modules/pv_headers/pv_headers.c
+++ b/src/modules/pv_headers/pv_headers.c
@@ -240,8 +240,8 @@ int mod_init(void)
 		auto_msg_param = 0;
 	} else {
 		if(auto_msg_param
-				&& register_script_cb(
-						   handle_msg_cb, PRE_SCRIPT_CB | REQUEST_CB, 0)
+				&& register_script_cb(handle_msg_cb,
+						   PRE_SCRIPT_CB | REQUEST_CB | ONREPLY_CB, 0)
 						   < 0) {
 			LM_ERR("cannot register PRE_SCRIPT_CB callbacks\n");
 			return -1;
@@ -265,8 +265,7 @@ void mod_destroy(void)
 	pvh_str_hash_free(&skip_headers);
 	pvh_str_hash_free(&split_headers);
 	pvh_str_hash_free(&single_headers);
-	pvh_free_xavp(&xavp_name);
-	pvh_free_xavp(&xavp_parsed_xname);
+
 	LM_INFO("%s module unload...\n", MODULE_NAME);
 }
 
@@ -274,15 +273,12 @@ void handle_tm_t(tm_cell_t *t, int type, struct tmcb_params *params)
 {
 	struct sip_msg *msg = NULL;
 
-	if(type & TMCB_RESPONSE_IN) {
-		msg = params->rpl;
-		if(msg != NULL && msg != FAKED_REPLY) {
-			pvh_reset_headers(msg);
-			pvh_collect_headers(msg, 1);
-		}
-	} else if(type & TMCB_REQUEST_FWDED) {
+	LM_DBG("T:%p params->branch: %d\n", t, params->branch);
+	if(type & TMCB_REQUEST_FWDED) {
 		msg = params->req;
-	} else if(type & (TMCB_ON_BRANCH_FAILURE | TMCB_RESPONSE_FWDED)) {
+	} else if(type
+			  & (TMCB_ON_BRANCH_FAILURE | TMCB_RESPONSE_FWDED
+						| TMCB_RESPONSE_IN)) {
 		msg = params->rpl;
 	} else {
 		LM_ERR("unknown callback: %d\n", type);
@@ -300,7 +296,7 @@ int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb)
 	int cbs = TMCB_REQUEST_FWDED | TMCB_RESPONSE_FWDED | TMCB_RESPONSE_IN
 			  | TMCB_ON_BRANCH_FAILURE;
 
-	if(flags & (PRE_SCRIPT_CB | REQUEST_CB)) {
+	if(flags & (PRE_SCRIPT_CB | REQUEST_CB | ONREPLY_CB)) {
 		if(tmb.register_tmcb(msg, 0, cbs, handle_tm_t, 0, 0) <= 0) {
 			LM_ERR("cannot register TM callbacks\n");
 			return -1;
diff --git a/src/modules/pv_headers/pvh_func.c b/src/modules/pv_headers/pvh_func.c
index 7fafa40..592d381 100644
--- a/src/modules/pv_headers/pvh_func.c
+++ b/src/modules/pv_headers/pvh_func.c
@@ -58,6 +58,10 @@ int pvh_collect_headers(struct sip_msg *msg, int is_auto)
 		}
 	}
 
+	if(msg->first_line.type == SIP_REPLY) {
+		pvh_reply_append();
+	}
+
 	if(parse_headers(msg, HDR_EOH_F, 0) < 0) {
 		LM_ERR("error parsing headers\n");
 		return -1;
diff --git a/src/modules/pv_headers/pvh_xavp.c b/src/modules/pv_headers/pvh_xavp.c
index db2192c..040b29a 100644
--- a/src/modules/pv_headers/pvh_xavp.c
+++ b/src/modules/pv_headers/pvh_xavp.c
@@ -32,39 +32,50 @@
 #include "pvh_str.h"
 #include "pvh_hash.h"
 
-sr_xavp_t *pvh_xavp_new_value(str *name, sr_xval_t *val)
+static str reply_counter = str_init("reply_counter");
+
+/**
+ * We keep a $xavp(xavp_name=>reply_counter) with the number of replies
+ * so we will use $xavp(xavp_name.r.<id>) on reply_route
+ */
+int pvh_reply_append(void)
 {
-	sr_xavp_t *avp = NULL;
-	int size;
-	unsigned int id;
+	sr_xavp_t **xavp = NULL;
+	sr_xavp_t *root = NULL;
+	sr_xval_t root_xval;
+	sr_xval_t xval;
 
-	if(name == NULL || name->s == NULL || val == NULL)
-		return NULL;
-	id = get_hash1_raw(name->s, name->len);
+	root = xavp_get_child_with_ival(&xavp_name, &reply_counter);
+	if(root) {
+		root->val.v.i++;
+		LM_DBG("reply message: %d\n", root->val.v.i);
+		return 1;
+	}
 
-	size = sizeof(sr_xavp_t) + name->len + 1;
-	if(val->type == SR_XTYPE_STR)
-		size += val->v.s.len + 1;
-	avp = (sr_xavp_t *)shm_malloc(size);
-	if(avp == NULL) {
-		SHM_MEM_ERROR;
-		return NULL;
+	memset(&xval, 0, sizeof(sr_xval_t));
+	xval.type = SR_XTYPE_INT;
+	xval.v.i = 0;
+
+	root = xavp_get(&xavp_name, NULL);
+	if(root == NULL) {
+		memset(&root_xval, 0, sizeof(sr_xval_t));
+		root_xval.type = SR_XTYPE_XAVP;
+		root_xval.v.xavp = NULL;
+		if((root = xavp_add_value(&xavp_name, &root_xval, NULL)) == NULL) {
+			LM_ERR("error creating xavp %s\n", xavp_name.s);
+			return -1;
+		}
+		xavp = &root->val.v.xavp;
+	} else {
+		xavp = &root;
 	}
-	memset(avp, 0, size);
-	avp->id = id;
-	avp->name.s = (char *)avp + sizeof(sr_xavp_t);
-	memcpy(avp->name.s, name->s, name->len);
-	avp->name.s[name->len] = '\0';
-	avp->name.len = name->len;
-	memcpy(&avp->val, val, sizeof(sr_xval_t));
-	if(val->type == SR_XTYPE_STR) {
-		avp->val.v.s.s = avp->name.s + avp->name.len + 1;
-		memcpy(avp->val.v.s.s, val->v.s.s, val->v.s.len);
-		avp->val.v.s.s[val->v.s.len] = '\0';
-		avp->val.v.s.len = val->v.s.len;
+	if(pvh_xavp_append_value(&reply_counter, &xval, xavp) < 0) {
+		LM_ERR("error append xavp=>name %s=>%.*s\n", xavp_name.s,
+				reply_counter.len, reply_counter.s);
+		return -1;
 	}
-
-	return avp;
+	LM_DBG("reply message: 0\n");
+	return 1;
 }
 
 int pvh_xavp_append_value(str *name, sr_xval_t *val, sr_xavp_t **start)
@@ -72,7 +83,7 @@ int pvh_xavp_append_value(str *name, sr_xval_t *val, sr_xavp_t **start)
 	sr_xavp_t *last = NULL;
 	sr_xavp_t *xavp = NULL;
 
-	if((xavp = pvh_xavp_new_value(name, val)) == NULL)
+	if((xavp = xavp_new_value(name, val)) == NULL)
 		return -1;
 
 	if(*start == NULL) {
@@ -398,6 +409,8 @@ int pvh_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
 	int os = 0;
 	char br_idx_s[32];
 	char br_idx_len = 0;
+	sr_xavp_t *xavp;
+	int reply = 0;
 
 	if(dst == NULL)
 		return -1;
@@ -408,7 +421,7 @@ int pvh_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
 
 	pvh_get_branch_index(msg, &br_idx);
 	if(br_idx > 0) {
-		sprintf(br_idx_s, "%d", br_idx - 1);
+		snprintf(br_idx_s, 32, "%d", br_idx - 1);
 		br_idx_len = strlen(br_idx_s);
 		memcpy(dst->s + os, ".", 1);
 		os += 1;
@@ -416,8 +429,18 @@ int pvh_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
 		os += br_idx_len;
 	}
 	if(msg->first_line.type == SIP_REPLY) {
-		memcpy(dst->s + os, ".r", 2);
-		os += 2;
+		xavp = xavp_get_child_with_ival(&xavp_name, &reply_counter);
+		if(!xavp) {
+			LM_WARN("no reply_counter found, this should not happend\n");
+			pvh_reply_append();
+			reply = 0;
+		} else {
+			reply = xavp->val.v.i;
+		}
+		snprintf(br_idx_s, 32, ".r.%d", reply);
+		br_idx_len = strlen(br_idx_s);
+		memcpy(dst->s + os, br_idx_s, br_idx_len);
+		os += br_idx_len;
 	}
 	dst->len = os;
 	dst->s[dst->len] = '\0';
diff --git a/src/modules/pv_headers/pvh_xavp.h b/src/modules/pv_headers/pvh_xavp.h
index d9e9299..4172393 100644
--- a/src/modules/pv_headers/pvh_xavp.h
+++ b/src/modules/pv_headers/pvh_xavp.h
@@ -30,7 +30,6 @@
 
 #include "pv_headers.h"
 
-sr_xavp_t *pvh_xavp_new_value(str *name, sr_xval_t *val);
 int pvh_xavp_append_value(str *name, sr_xval_t *val, sr_xavp_t **start);
 int pvh_xavp_set_value(str *name, sr_xval_t *val, int idx, sr_xavp_t **start);
 sr_xavp_t *pvh_xavp_get(struct sip_msg *msg, str *xname);
@@ -45,6 +44,7 @@ int pvh_set_xavp(struct sip_msg *msg, str *xname, str *name, void *data,
 		sr_xtype_t type, int idx, int append);
 int pvh_free_xavp(str *xname);
 int pvh_parse_header_name(pv_spec_p sp, str *hname);
+int pvh_reply_append(void);
 
 int pvh_get_header(struct sip_msg *msg, pv_param_t *param, pv_value_t *res);
 int pvh_set_header(
