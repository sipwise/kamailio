From: Victor Seva <vseva@sipwise.com>
Date: Tue, 21 Jan 2020 10:44:46 +0100
Subject: pv_headers: rework reply scenario
---
 src/modules/pv_headers/pv_headers.c | 180 ++++++++++++++++++++++++++++++++++--
 1 file changed, 174 insertions(+), 6 deletions(-)

diff --git a/src/modules/pv_headers/pv_headers.c b/src/modules/pv_headers/pv_headers.c
index f3c8a83..00432bb 100644
--- a/src/modules/pv_headers/pv_headers.c
+++ b/src/modules/pv_headers/pv_headers.c
@@ -63,6 +63,7 @@ static str xavp_name = str_init(XAVP_NAME);
 static str xavp_helper_xname  = str_init("modparam_pv_headers");
 static str xavp_parsed_xname  = str_init("parsed_pv_headers");
 static str xavp_helper_name   = str_init("xavp_name");
+static str reply_counter = str_init("reply_counter");
 static str skip_headers_param = str_init("Record-Route,Via,Route,Content-Length,Max-Forwards,CSeq");
 static str split_headers_param = STR_NULL;
 static int auto_msg_param     = 1;
@@ -90,6 +91,8 @@ static int mod_init(void);
 
 static void handle_tm_t(tm_cell_t *t, int type, struct tmcb_params* params);
 static int  handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb);
+static int handle_msg_reply_cb(
+        struct sip_msg *msg, unsigned int flags, void *cb);
 
 static int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2);
 static int pv_apply_headers(struct sip_msg *msg, char *is_auto, char *_s2);
@@ -118,6 +121,9 @@ static int pv_str_copy(str *dst, str *src, unsigned int max_size);
 static int pv_extract_display_uri(char *suri, str *display, str *duri);
 static int pv_split_values(str *s, char d[][header_value_size], int *d_size, int keep_spaces);
 
+static int pvh_reply_init(int value);
+static int pvh_reply_append(void);
+
 static sr_xavp_t * pv_xavp_new_value(str *name, sr_xval_t *val);
 static int pv_xavp_append_value(str *name, sr_xval_t *val, sr_xavp_t **start);
 static int pv_xavp_set_value(str *name, sr_xval_t *val, int idx, sr_xavp_t **start);
@@ -220,10 +226,18 @@ int mod_init(void)
         LM_NOTICE("could not bind to the 'tm' module, automatic headers collect/apply is disabled\n");
         auto_msg_param = 0;
     } else {
-        if (auto_msg_param &&
-            register_script_cb(handle_msg_cb, PRE_SCRIPT_CB|REQUEST_CB, 0) < 0) {
-                LM_ERR("cannot register PRE_SCRIPT_CB callbacks\n");
+        if(auto_msg_param) {
+            if(register_script_cb(handle_msg_cb, PRE_SCRIPT_CB | REQUEST_CB, 0)
+                    < 0) {
+                LM_ERR("cannot register PRE_SCRIPT_CB|REQUEST_CB callbacks\n");
+                return -1;
+            }
+            if(register_script_cb(
+                       handle_msg_reply_cb, PRE_SCRIPT_CB | ONREPLY_CB, 0)
+                    < 0) {
+                LM_ERR("cannot register PRE_SCRIPT_CB|ONREPLY_CB callbacks\n");
                 return -1;
+            }
         }
     }
 
@@ -253,6 +267,7 @@ void handle_tm_t(tm_cell_t *t, int type, struct tmcb_params* params)
 {
     struct sip_msg *msg = NULL;
 
+    LM_DBG("T:%p params->branch: %d\n", t, params->branch);
     if (type & TMCB_RESPONSE_IN) {
         msg = params->rpl;
         if (msg != NULL && msg != FAKED_REPLY) {
@@ -283,6 +298,7 @@ int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb)
             LM_ERR("cannot register TM callbacks\n");
             return -1;
         }
+        pvh_reply_init(0);
         pv_collect_headers(msg, "1", NULL);
     } else {
         LM_ERR("unknown callback: %d\n", flags);
@@ -291,6 +307,69 @@ int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb)
     return 1;
 }
 
+int handle_msg_reply_cb(struct sip_msg *msg, unsigned int flags, void *cb)
+{
+    tm_cell_t *t = NULL;
+    int branch;
+    sr_xavp_t **backup_xavps = NULL;
+    int backup_m_flags = msg->msg_flags;
+    int reply_count;
+
+    if(likely(!(msg->msg_flags & FL_TM_RPL_MATCHED))) {
+        msg->msg_flags |= FL_TM_RPL_MATCHED;
+        LM_DBG("fake FL_TM_RPL_MATCHED, to skip tm_cb TMCB_RESPONSE_IN\n");
+    }
+
+    if(tmb.t_check(msg, &branch) == -1) {
+        LM_ERR("failed find UAC branch\n");
+    } else {
+        t = tmb.t_gett();
+        if(t == NULL || t == T_UNDEFINED) {
+            LM_DBG("cannot lookup the transaction\n");
+        } else {
+            LM_DBG("T:%p branch:%d\n", t, branch);
+            backup_xavps = xavp_set_list(&t->xavps_list);
+        }
+    }
+
+    if(msg->msg_flags != backup_m_flags) {
+        msg->msg_flags = backup_m_flags;
+        LM_DBG("restored msg_flags\n");
+    }
+    if((reply_count = pvh_reply_append()) < 0) {
+        goto error;
+    }
+    if(backup_xavps) {
+        xavp_set_list(backup_xavps);
+        LM_DBG("restored backup_xavps\n");
+    }
+    if(t) {
+        tmb.unref_cell(t);
+        LM_DBG("T:%p unref\n", t);
+    }
+    tmb.t_sett(T_UNDEFINED, T_BR_UNDEFINED);
+    LM_DBG("reset tm\n");
+    if(backup_xavps) {
+        if(pvh_reply_init(reply_count) < 0) {
+            return -1;
+        }
+    }
+    return 1;
+
+error:
+    if(backup_xavps) {
+        xavp_set_list(backup_xavps);
+        LM_DBG("restored backup_xavps\n");
+    }
+    if(t) {
+        tmb.unref_cell(t);
+        LM_DBG("T:%p unref\n", t);
+    }
+    tmb.t_sett(T_UNDEFINED, T_BR_UNDEFINED);
+    LM_DBG("reset tm\n");
+    return -1;
+}
+
 int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2)
 {
     struct hdr_field *hf = NULL;
@@ -2052,6 +2131,8 @@ int pv_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
     int os = 0;
     char br_idx_s[32];
     char br_idx_len = 0;
+    sr_xavp_t *xavp;
+    int reply = 0;
 
     if (dst == NULL)
         return -1;
@@ -2061,13 +2142,25 @@ int pv_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
 
     pv_get_branch_index(msg, &br_idx);
     if (br_idx > 0) {
-        sprintf(br_idx_s, "%d", br_idx-1);
+        snprintf(br_idx_s, 32, "%d", br_idx-1);
         br_idx_len = strlen(br_idx_s);
         memcpy(dst->s+os, ".", 1); os+=1;
         memcpy(dst->s+os, br_idx_s, br_idx_len); os+=br_idx_len;
     }
-    if (msg->first_line.type == SIP_REPLY) {
-        memcpy(dst->s+os, ".r", 2); os+=2;
+    if(msg->first_line.type == SIP_REPLY) {
+        xavp = xavp_get_child_with_ival(&xavp_helper_xname, &reply_counter);
+        if(!xavp) {
+            LM_DBG("no %.*s=>%.*s found\n", xavp_helper_xname.len, xavp_helper_xname.s,
+                    reply_counter.len, reply_counter.s);
+            pvh_reply_append();
+            reply = 0;
+        } else {
+            reply = xavp->val.v.i;
+        }
+        snprintf(br_idx_s, 32, ".r.%d", reply);
+        br_idx_len = strlen(br_idx_s);
+        memcpy(dst->s + os, br_idx_s, br_idx_len);
+        os += br_idx_len;
     }
     dst->len = os;
     dst->s[dst->len] = '\0';
@@ -2124,3 +2217,78 @@ static int pv_clone_branch_xavp(struct sip_msg *msg, str *xname, str *br_xname)
 
     return 1;
 }
+
+/**
+ * We keep a $xavp(xavp_helper_xname=>reply_counter) with the number of replies
+ * so we will use $xavp(xavp_name.r.<id>) on reply_route
+ */
+int pvh_reply_init(int value)
+{
+    sr_xavp_t *xavp = NULL;
+    sr_xval_t xval;
+
+    xavp = xavp_get_child_with_ival(&xavp_helper_xname, &reply_counter);
+    if(xavp) {
+        LM_DBG("%.*s=>%.*s found: %d\n", xavp_helper_xname.len, xavp_helper_xname.s,
+                reply_counter.len, reply_counter.s, xavp->val.v.i);
+        return 1;
+    }
+
+    memset(&xval, 0, sizeof(sr_xval_t));
+    xval.type = SR_XTYPE_INT;
+    xval.v.i = value;
+
+    xavp = xavp_get(&xavp_helper_xname, NULL);
+    if(xavp == NULL) {
+        if(xavp_add_xavp_value(&xavp_helper_xname, &reply_counter, &xval, NULL)
+                == NULL) {
+            LM_ERR("can't create xavp:%.*s\n", xavp_helper_xname.len, xavp_helper_xname.s);
+            return -1;
+        }
+        LM_DBG("xavp_name:%.*s created\n", xavp_helper_xname.len, xavp_helper_xname.s);
+    } else {
+        if(xavp_set_value(&reply_counter, 0, &xval, &xavp->val.v.xavp)
+                == NULL) {
+            LM_ERR("can't set reply_counter value\n");
+            return -1;
+        }
+        LM_DBG("added value\n");
+    }
+    LM_DBG("reply message: %d\n", xval.v.i);
+    return xval.v.i;
+}
+
+int pvh_reply_append(void)
+{
+    sr_xavp_t *xavp = NULL;
+    sr_xval_t xval;
+
+    xavp = xavp_get_child_with_ival(&xavp_helper_xname, &reply_counter);
+    if(xavp) {
+        xavp->val.v.i++;
+        LM_DBG("reply message: %d\n", xavp->val.v.i);
+        return xavp->val.v.i;
+    }
+
+    memset(&xval, 0, sizeof(sr_xval_t));
+    xval.type = SR_XTYPE_INT;
+    xval.v.i = 0;
+
+    xavp = xavp_get(&xavp_name, NULL);
+    if(xavp == NULL) {
+        if(xavp_add_xavp_value(&xavp_helper_xname, &reply_counter, &xval, NULL)
+                == NULL) {
+            LM_ERR("can't create xavp:%.*s\n", xavp_helper_xname.len, xavp_helper_xname.s);
+            return -1;
+        }
+        LM_DBG("xavp_name:%.*s created\n", xavp_helper_xname.len, xavp_helper_xname.s);
+    } else {
+        if(xavp_add_value(&reply_counter, &xval, &xavp->val.v.xavp) == NULL) {
+            LM_ERR("can't add reply_counter value\n");
+            return -1;
+        }
+        LM_DBG("added value\n");
+    }
+    LM_DBG("reply message: %d\n", xval.v.i);
+    return xval.v.i;
+}
