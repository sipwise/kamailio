From: Victor Seva <vseva@sipwise.com>
Date: Wed, 15 Jan 2020 15:51:37 +0100
Subject: pv_headers: rework reply scenario
---
 src/modules/pv_headers/pv_headers.c | 77 ++++++++++++++++++++++++++++++-------
 1 file changed, 64 insertions(+), 13 deletions(-)

diff --git a/src/modules/pv_headers/pv_headers.c b/src/modules/pv_headers/pv_headers.c
index f3c8a83..4d41b55 100644
--- a/src/modules/pv_headers/pv_headers.c
+++ b/src/modules/pv_headers/pv_headers.c
@@ -59,7 +59,7 @@ static uac_api_t uac;
 static tm_api_t tmb;
 
 static str xavp_name = str_init(XAVP_NAME);
-
+static str reply_counter = str_init("reply_counter");
 static str xavp_helper_xname  = str_init("modparam_pv_headers");
 static str xavp_parsed_xname  = str_init("parsed_pv_headers");
 static str xavp_helper_name   = str_init("xavp_name");
@@ -221,7 +221,7 @@ int mod_init(void)
         auto_msg_param = 0;
     } else {
         if (auto_msg_param &&
-            register_script_cb(handle_msg_cb, PRE_SCRIPT_CB|REQUEST_CB, 0) < 0) {
+            register_script_cb(handle_msg_cb, PRE_SCRIPT_CB|REQUEST_CB|ONREPLY_CB, 0) < 0) {
                 LM_ERR("cannot register PRE_SCRIPT_CB callbacks\n");
                 return -1;
         }
@@ -253,15 +253,10 @@ void handle_tm_t(tm_cell_t *t, int type, struct tmcb_params* params)
 {
     struct sip_msg *msg = NULL;
 
-    if (type & TMCB_RESPONSE_IN) {
-        msg = params->rpl;
-        if (msg != NULL && msg != FAKED_REPLY) {
-            pv_reset_headers(msg, NULL, NULL);
-            pv_collect_headers(msg, "1", NULL);
-        }
-    } else if (type & TMCB_REQUEST_FWDED) {
+    LM_DBG("T:%p params->branch: %d\n", t, params->branch);
+    if (type & TMCB_REQUEST_FWDED) {
        msg = params->req;
-    } else if (type &(TMCB_ON_BRANCH_FAILURE|TMCB_RESPONSE_FWDED)) {
+    } else if (type &(TMCB_ON_BRANCH_FAILURE|TMCB_RESPONSE_FWDED|TMCB_RESPONSE_IN)) {
         msg = params->rpl;
     } else {
         LM_ERR("unknown callback: %d\n", type);
@@ -278,7 +273,7 @@ int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb)
 {
     int cbs = TMCB_REQUEST_FWDED | TMCB_RESPONSE_FWDED | TMCB_RESPONSE_IN | TMCB_ON_BRANCH_FAILURE;
 
-    if (flags & (PRE_SCRIPT_CB|REQUEST_CB)) {
+    if (flags & (PRE_SCRIPT_CB|REQUEST_CB|ONREPLY_CB)) {
         if (tmb.register_tmcb( msg, 0, cbs, handle_tm_t, 0, 0) <=0) {
             LM_ERR("cannot register TM callbacks\n");
             return -1;
@@ -291,6 +286,44 @@ int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb)
     return 1;
 }
 
+/**
+ * We keep a $xavp(xavp_name=>reply_counter) with the number of replies
+ * so we will use $xavp(xavp_name.r.<id>) on reply_route
+ */
+int pvh_reply_append(void)
+{
+	sr_xavp_t *xavp = NULL;
+	sr_xval_t xval;
+
+	xavp = xavp_get_child_with_ival(&xavp_name, &reply_counter);
+	if(xavp) {
+		xavp->val.v.i++;
+		LM_DBG("reply message: %d\n", xavp->val.v.i);
+		return 1;
+	}
+
+	memset(&xval, 0, sizeof(sr_xval_t));
+	xval.type = SR_XTYPE_INT;
+	xval.v.i = 0;
+
+	xavp = xavp_get(&xavp_name, NULL);
+	if(xavp == NULL) {
+		if(xavp_add_xavp_value(&xavp_name, &reply_counter, &xval, NULL) == NULL) {
+			LM_ERR("can't create xavp:%.*s\n", xavp_name.len, xavp_name.s);
+			return -1;
+		}
+		LM_DBG("xavp_name:%.*s created\n", xavp_name.len, xavp_name.s);
+	} else {
+		if(xavp_add_value(&reply_counter, &xval, &xavp) == NULL) {
+			LM_ERR("can't add reply_counter value\n");
+			return -1;
+		}
+		LM_DBG("added value\n");
+	}
+	LM_DBG("reply message: %d\n", xval.v.i);
+	return 1;
+}
+
 int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2)
 {
     struct hdr_field *hf = NULL;
@@ -310,6 +343,10 @@ int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2)
             return -1;
     }
 
+    if(msg->first_line.type == SIP_REPLY) {
+        pvh_reply_append();
+    }
+
     if (parse_headers(msg, HDR_EOH_F, 0) < 0) {
         LM_ERR("error parsing headers\n");
         return -1;
@@ -2052,6 +2089,8 @@ int pv_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
     int os = 0;
     char br_idx_s[32];
     char br_idx_len = 0;
+    sr_xavp_t *xavp;
+    int reply = 0;
 
     if (dst == NULL)
         return -1;
@@ -2061,13 +2100,25 @@ int pv_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
 
     pv_get_branch_index(msg, &br_idx);
     if (br_idx > 0) {
-        sprintf(br_idx_s, "%d", br_idx-1);
+        snprintf(br_idx_s, 32, "%d", br_idx-1);
         br_idx_len = strlen(br_idx_s);
         memcpy(dst->s+os, ".", 1); os+=1;
         memcpy(dst->s+os, br_idx_s, br_idx_len); os+=br_idx_len;
     }
     if (msg->first_line.type == SIP_REPLY) {
-        memcpy(dst->s+os, ".r", 2); os+=2;
+        xavp = xavp_get_child_with_ival(&xavp_name, &reply_counter);
+		if(!xavp) {
+			LM_DBG("no %.*s=>%.*s found, this should not happend\n",
+				xavp_name.len, xavp_name.s,
+				reply_counter.len, reply_counter.s);
+			reply = 0;
+		} else {
+			reply = xavp->val.v.i;
+		}
+		snprintf(br_idx_s, 32, ".r.%d", reply);
+		br_idx_len = strlen(br_idx_s);
+		memcpy(dst->s + os, br_idx_s, br_idx_len);
+		os += br_idx_len;
     }
     dst->len = os;
     dst->s[dst->len] = '\0';
