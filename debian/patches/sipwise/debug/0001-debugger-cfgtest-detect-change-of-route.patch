From 7f7e7e14f9a535c272aeba165c7ff4a63420e0e1 Mon Sep 17 00:00:00 2001
From: Victor Seva <linuxmaniac@torreviejawireless.org>
Date: Sat, 24 May 2014 23:54:50 +0200
Subject: [PATCH] debugger: cfgtest detect change of route.

---
 modules/debugger/Makefile       |   1 +
 modules/debugger/debugger_api.c | 896 +++++++++++++++++++++++++++++++++++++++-
 modules/debugger/debugger_api.h |   3 +
 modules/debugger/debugger_mod.c |  21 +
 4 files changed, 913 insertions(+), 8 deletions(-)

--- a/modules/debugger/Makefile
+++ b/modules/debugger/Makefile
@@ -11,4 +11,5 @@
 
 SERLIBPATH=../../lib
 SER_LIBS+=$(SERLIBPATH)/srutils/srutils
+SER_LIBS+=$(SERLIBPATH)/kcore/kcore
 include ../../Makefile.modules
--- a/modules/debugger/debugger_api.c
+++ b/modules/debugger/debugger_api.c
@@ -41,6 +41,7 @@
 #include "../../lib/srutils/srjson.h"
 #include "../../xavp.h"
 #include "../pv/pv_xavp.h"
+#include "../../lib/kcore/cmpapi.h"
 
 #include "debugger_act.h"
 #include "debugger_api.h"
@@ -76,6 +77,7 @@
 #define DBG_CFGTRACE_ON	(1<<0)
 #define DBG_ABKPOINT_ON	(1<<1)
 #define DBG_LBKPOINT_ON	(1<<2)
+#define DBG_CFGTEST_ON	(1<<3)
 
 static str _dbg_status_list[] = {
 	str_init("cfgtrace-on"),
@@ -84,6 +86,8 @@
 	str_init("abkpoint-off"),
 	str_init("lbkpoint-on"),
 	str_init("lbkpoint-off"),
+	str_init("cfgtest-on"),
+	str_init("cfgtest-off"),
 	{0, 0}
 };
 
@@ -95,6 +99,8 @@
 		return &_dbg_status_list[2];
 	if(t&DBG_LBKPOINT_ON)
 		return &_dbg_status_list[4];
+	if(t&DBG_CFGTEST_ON)
+		return &_dbg_status_list[6];
 
 	return &_dbg_state_list[0];
 }
@@ -190,6 +196,70 @@
 int _dbg_reset_msgid = 0;
 
 /**
+ * disabled by default
+ */
+int _dbg_cfgtest = 0;
+
+#define DBG_CFGT_HASH_SIZE 32
+
+enum _dbg_cfgt_action_type {
+	DBG_CFGT_ROUTE=1,
+	DBG_CFGT_DROP_E, DBG_CFGT_DROP_D, DBG_CFGT_DROP_R
+};
+
+static str _dbg_cfgt_route_prefix[] = {
+	str_init("start|"),
+	str_init("exit|"),
+	str_init("drop|"),
+	str_init("return|"),
+	{0, 0}
+};
+
+typedef struct _dbg_cfgt_hash
+{
+	gen_lock_t lock;
+	struct str_hash_table hash;
+	str save_uuid; /* uuid to be save */
+} dbg_cfgt_hash_t, *dbg_cfgt_hash_p;
+
+typedef struct _dbg_cfgt_str_list
+{
+	str s;
+	enum _dbg_cfgt_action_type type;
+	struct _dbg_cfgt_str_list *next, *prev;
+} dbg_cfgt_str_list_t, *dbg_cfgt_str_list_p;
+
+typedef struct _dbg_cfgt_node
+{
+	srjson_doc_t jdoc;
+	str uuid;
+	int msgid;
+	dbg_cfgt_str_list_p flow_head;
+	dbg_cfgt_str_list_p route;
+	srjson_t *in, *out, *flow;
+	struct _dbg_cfgt_node *next, *prev;
+} dbg_cfgt_node_t, *dbg_cfgt_node_p;
+
+dbg_cfgt_node_p _dbg_cfgt_head = NULL;
+dbg_cfgt_hash_p _dbg_cfgt_uuid = NULL;
+str _dbg_cfgt_basedir = {"/tmp/", 5};
+str _dbg_cfgt_hdr_name = {"P-NGCP-CFGTEST", 14};
+
+/** defined later */
+void _dbg_cfgt_print_node(dbg_cfgt_node_p node);
+int dbg_cfgt_filter(struct sip_msg *msg, unsigned int flags, void *bar);
+int dbg_cfgt_msgin(void *data);
+int dbg_cfgt_msgout(void *data);
+int _dbg_cfgt_get_uuid_id(dbg_cfgt_node_p node);
+int _dbg_cfgt_create_node(struct sip_msg *msg);
+int _dbg_cfgt_get_hdr(struct sip_msg *msg, str *res);
+int _dbg_cfgt_cmp_hdr(struct sip_msg *msg, str *res);
+int _dbg_cfgt_save(str *uuid);
+int _dbg_cfgt_set_dump(struct sip_msg *msg, dbg_cfgt_node_p node, str *flowname);
+int _dbg_cfgt_process_route(struct sip_msg *msg,
+		dbg_cfgt_node_p node, struct action *a);
+
+/**
  *
  */
 typedef struct _dbg_cmd
@@ -212,6 +282,8 @@
 	gen_lock_t *lock;
 	unsigned int reset_msgid; /* flag to reset the id */
 	unsigned int msgid_base; /* real id since the reset */
+	unsigned int cfgt_save; /* flag to reset the id (1 == ALL, 2 == uuid ) */
+	dbg_cfgt_node_p cfgt_node;
 } dbg_pid_t;
 
 /**
@@ -322,6 +394,7 @@
     pv_value_t val;
 	void **srevp;
 	str *an;
+	dbg_cfgt_node_p node;
 
 	srevp = (void**)data;
 
@@ -357,6 +430,16 @@
 				);
 		}
 	}
+	if(_dbg_pid_list[process_no].set&DBG_CFGTEST_ON)
+	{
+		node = _dbg_pid_list[process_no].cfgt_node;
+		if(node)
+		{
+			if(_dbg_cfgt_process_route(msg, node, a)<0)
+				LM_ERR("Error processing route\n");
+		}
+		else LM_ERR("node empty\n");
+	}
 	if(!(_dbg_pid_list[process_no].set&DBG_ABKPOINT_ON))
 	{
 		/* no breakpoints to be considered */
@@ -591,7 +674,10 @@
 		_dbg_pid_list[process_no].set |= DBG_ABKPOINT_ON;
 	if(_dbg_cfgtrace==1)
 		_dbg_pid_list[process_no].set |= DBG_CFGTRACE_ON;
-	if(_dbg_reset_msgid==1)
+	if(_dbg_cfgtest==1){
+		_dbg_pid_list[process_no].set |= DBG_CFGTEST_ON;
+	}
+	if(_dbg_reset_msgid==1||_dbg_cfgtest==1)
 	{
 		LM_DBG("[%d] create locks\n", process_no);
 		_dbg_pid_list[process_no].lock = lock_alloc();
@@ -1022,12 +1108,78 @@
 /**
  *
  */
+static const char* dbg_rpc_cfgt_save_doc[2] = {
+	"Save cfgtest info to disk",
+	0
+};
+
+static void dbg_rpc_cfgt_save(rpc_t* rpc, void* ctx){
+	int i;
+	str uuid = STR_NULL;
+	if (_dbg_cfgtest==0)
+	{
+		rpc->fault(ctx, 500, "cfgtest is 0. Set it to 1 to enable.");
+		return;
+	}
+	if(_dbg_pid_list==NULL)
+	{
+		rpc->fault(ctx, 500, "_dbg_pid_list is NULL");
+		return;
+	}
+	if(rpc->scan(ctx, "*S", &uuid)!=1)
+	{
+		uuid.len = 0;
+	}
+	LM_DBG("set cfgt_save[%.*s]\n", uuid.len, uuid.s);
+	lock_get(&_dbg_cfgt_uuid->lock);
+	if(_dbg_cfgt_uuid->save_uuid.s)
+	{
+		LM_DBG("free previous uuid\n");
+		shm_free(_dbg_cfgt_uuid->save_uuid.s);
+		_dbg_cfgt_uuid->save_uuid.s = NULL;
+		_dbg_cfgt_uuid->save_uuid.len = 0;
+	}
+	if(uuid.len>0)
+	{
+		if(shm_str_dup(&_dbg_cfgt_uuid->save_uuid, &uuid) != 0)
+		{
+			LM_ERR("No shared memory left\n");
+			rpc->fault(ctx, 500, "No more shared memory left");
+			lock_release(&_dbg_cfgt_uuid->lock);
+			return;
+		}
+	}
+	lock_release(&_dbg_cfgt_uuid->lock);
+	for(i=0; i<_dbg_pid_no; i++)
+	{
+		if (_dbg_pid_list[i].lock!=NULL)
+		{
+			lock_get(_dbg_pid_list[i].lock);
+			if(uuid.len>0)
+			{
+				_dbg_pid_list[i].cfgt_save = 2;
+			}
+			else
+			{
+				_dbg_pid_list[i].cfgt_save = 1;
+			}
+			lock_release(_dbg_pid_list[i].lock);
+		}
+	}
+
+	rpc->add(ctx, "s", "200 ok");
+}
+
+/**
+ *
+ */
 rpc_export_t dbg_rpc[] = {
 	{"dbg.bp",        dbg_rpc_bp,        dbg_rpc_bp_doc,        0},
 	{"dbg.ls",        dbg_rpc_list,      dbg_rpc_list_doc,      0},
 	{"dbg.trace",     dbg_rpc_trace,     dbg_rpc_trace_doc,     0},
 	{"dbg.mod_level", dbg_rpc_mod_level, dbg_rpc_mod_level_doc, 0},
 	{"dbg.reset_msgid", dbg_rpc_reset_msgid, dbg_rpc_reset_msgid_doc, 0},
+	{"dbg.cfgt_save", dbg_rpc_cfgt_save, dbg_rpc_cfgt_save_doc, 0},
 	{0, 0, 0, 0}
 };
 
@@ -1645,7 +1797,8 @@
 	return 0;
 }
 
-int _dbg_get_json(struct sip_msg* msg, unsigned int mask, srjson_doc_t *jdoc)
+int _dbg_get_json(struct sip_msg* msg, unsigned int mask,
+	srjson_doc_t *jdoc, srjson_t *head)
 {
 	int i;
 	pv_value_t value;
@@ -1660,8 +1813,8 @@
 		LM_ERR("cannot access pv_cache\n");
 		return -1;
 	}
-	if(jdoc==NULL){
-		LM_ERR("jdoc is null\n");
+	if(jdoc==NULL||head==NULL){
+		LM_ERR("jdoc or head is null\n");
 		return -1;
 	}
 
@@ -1771,7 +1924,7 @@
 			}
 			if(jobj!=NULL)
 			{
-				srjson_AddItemToObject(jdoc, jdoc->root, iname, jobj);
+				srjson_AddItemToObject(jdoc, head, iname, jobj);
 			}
 			el = el->next;
 		}
@@ -1779,7 +1932,7 @@
 	return 0;
 
 error:
-	srjson_DestroyDoc(jdoc);
+	srjson_Delete(jdoc, head);
 	return -1;
 }
 
@@ -1799,7 +1952,7 @@
 		}
 	}
 
-	if(_dbg_get_json(msg, mask, &jdoc)<0) return -1;
+	if(_dbg_get_json(msg, mask, &jdoc, jdoc.root)<0) goto error;
 	output = srjson_PrintUnformatted(&jdoc, jdoc.root);
 	if(output==NULL)
 	{
@@ -1814,4 +1967,731 @@
 error:
 	srjson_DestroyDoc(&jdoc);
 	return -1;
-}
\ No newline at end of file
+}
+
+/*
+TODO:
+- parse first line, check if is SIP
+- parse for header cfgtest
+*/
+int dbg_cfgt_msgin(void *data)
+{
+	dbg_cfgt_node_p node;
+	srjson_t *jobj;
+	str *buf = (str *) data;
+	if(buf==NULL) return 0;
+	LM_DBG("msg in:{%.*s}\n", buf->len, buf->s);
+	_dbg_cfgt_create_node(NULL);
+	node = _dbg_pid_list[process_no].cfgt_node;
+	if(node)
+	{
+		jobj = srjson_CreateStr(&node->jdoc, buf->s, buf->len);
+		if(jobj==NULL)
+		{
+			LM_ERR("cannot create json object\n");
+			return -1;
+		}
+		srjson_AddItemToArray(&node->jdoc, node->in, jobj);
+		return 0;
+	}
+	LM_ERR("node empty\n");
+	return -1;
+}
+
+int dbg_cfgt_filter(struct sip_msg *msg, unsigned int flags, void *bar)
+{
+	unsigned int save = 0;
+	str uuid = STR_NULL;
+	str unknown = {"unknown", 7};
+	dbg_cfgt_node_p node;
+
+	lock_get(_dbg_pid_list[process_no].lock);
+	if(_dbg_pid_list[process_no].cfgt_save!=0)
+	{
+		LM_DBG("cfgt_save!\n");
+		save = _dbg_pid_list[process_no].cfgt_save;
+		_dbg_pid_list[process_no].cfgt_save = 0;
+	}
+	lock_release(_dbg_pid_list[process_no].lock);
+
+	if(save==2)
+	{
+		lock_get(&_dbg_cfgt_uuid->lock);
+		if(_dbg_cfgt_uuid->save_uuid.s)
+		{
+			pkg_str_dup(&uuid, &_dbg_cfgt_uuid->save_uuid);
+		}
+		lock_release(&_dbg_cfgt_uuid->lock);
+	}
+	if(save!=0)
+	{
+		if (uuid.len>0) LM_DBG("saving [%.*s]\n", uuid.len, uuid.s);
+		else LM_DBG("saving ALL\n");
+		_dbg_cfgt_save(&uuid);
+		LM_DBG("saved\n");
+	}
+	node = _dbg_pid_list[process_no].cfgt_node;
+	if(node)
+	{
+		if (node->msgid == 0)
+		{
+			LM_DBG("new node\n");
+			if(_dbg_cfgt_get_hdr(msg, &node->uuid)!=0)
+			{
+				LM_ERR("cannot get value of cfgtest uuid header. Using unknown\n");
+				pkg_str_dup(&node->uuid, &unknown);
+			}
+			return _dbg_cfgt_get_uuid_id(node);
+		}
+		else
+		{
+			LM_DBG("node->uuid:[%.*s]\n", node->uuid.len, node->uuid.s);
+			if(_dbg_cfgt_cmp_hdr(msg, &node->uuid))
+			{
+				LM_DBG("same uuid\n");
+				return 1;
+			}
+			else { LM_DBG("different uuid\n"); }
+		}
+	}
+	else { LM_ERR("node empty\n"); }
+	return _dbg_cfgt_create_node(msg);
+}
+
+int dbg_cfgt_msgout(void *data)
+{
+	dbg_cfgt_node_p node;
+	srjson_t *jobj;
+	str *buf = (str *) data;
+	if(buf==NULL) return 0;
+	LM_DBG("msg out:{%.*s}\n", buf->len, buf->s);
+	node = _dbg_pid_list[process_no].cfgt_node;
+	if(node)
+	{
+		jobj = srjson_CreateStr(&node->jdoc, buf->s, buf->len);
+		if(jobj==NULL)
+		{
+			LM_ERR("cannot create json object\n");
+			return -1;
+		}
+		srjson_AddItemToArray(&node->jdoc, node->out, jobj);
+		return 0;
+	}
+	LM_ERR("msgnode empty\n");
+	return -1;
+}
+
+static int shm_str_hash_alloc(struct str_hash_table *ht, int size)
+{
+	ht->table = shm_malloc(sizeof(struct str_hash_head) * size);
+
+	if (!ht->table)
+		return -1;
+
+	ht->size = size;
+	return 0;
+}
+
+static int _dbg_cfgt_init_hashtable(struct str_hash_table *ht)
+{
+	if (shm_str_hash_alloc(ht, DBG_CFGT_HASH_SIZE) != 0)
+	{
+		LM_ERR("Error allocating shared memory hashtable\n");
+		return -1;
+	}
+
+	str_hash_init(ht);
+
+	return 0;
+}
+
+int _dbg_cfgt_pv_parse(str *param, pv_elem_p *elem)
+{
+	if (param->s && param->len > 0)
+	{
+		if (pv_parse_format(param, elem)<0)
+		{
+			LM_ERR("malformed or non AVP %.*s AVP definition\n",
+					param->len, param->s);
+			return -1;
+		}
+	}
+	return 0;
+}
+
+int dbg_init_cfgtest(void)
+{
+	_dbg_cfgt_uuid = shm_malloc(sizeof(dbg_cfgt_hash_t));
+	if(_dbg_cfgt_uuid==NULL)
+	{
+		LM_ERR("Cannot allocate shared memory\n");
+		return -1;
+	}
+	if(!lock_init(&_dbg_cfgt_uuid->lock))
+	{
+		LM_ERR("cannot init the lock\n");
+		shm_free(_dbg_cfgt_uuid);
+		_dbg_cfgt_uuid = NULL;
+		return -1;
+	}
+	if(_dbg_cfgt_init_hashtable(&_dbg_cfgt_uuid->hash)<0)
+		return -1;
+
+	sr_event_register_cb(SREV_NET_DATA_IN, dbg_cfgt_msgin);
+	sr_event_register_cb(SREV_NET_DATA_OUT, dbg_cfgt_msgout);
+	return 0;
+}
+
+void _dbg_cfgt_remove_uuid(const str *uuid)
+{
+	struct str_hash_head *head;
+	struct str_hash_entry *entry, *back;
+	int i;
+
+	if(_dbg_cfgt_uuid==NULL) return;
+	if(uuid)
+	{
+		lock_get(&_dbg_cfgt_uuid->lock);
+		entry = str_hash_get(&_dbg_cfgt_uuid->hash, uuid->s, uuid->len);
+		if(entry)
+		{
+			str_hash_del(entry);
+			shm_free(entry->key.s);
+			shm_free(entry);
+			LM_DBG("uuid[%.*s] removed from hash\n", uuid->len, uuid->s);
+		}
+		else LM_DBG("uuid[%.*s] not found in hash\n", uuid->len, uuid->s);
+		lock_release(&_dbg_cfgt_uuid->lock);
+	}
+	else
+	{
+		lock_get(&_dbg_cfgt_uuid->lock);
+		for(i=0; i<DBG_CFGT_HASH_SIZE; i++)
+		{
+			head = _dbg_cfgt_uuid->hash.table+i;
+			clist_foreach_safe(head, entry, back, next)
+			{
+				LM_DBG("uuid[%.*s] removed from hash\n",
+					entry->key.len, entry->key.s);
+				str_hash_del(entry);
+				shm_free(entry->key.s);
+				shm_free(entry);
+			}
+			lock_release(&_dbg_cfgt_uuid->lock);
+		}
+		LM_DBG("remove all uuids. done\n");
+	}
+}
+
+int _dbg_cfgt_get_uuid_id(dbg_cfgt_node_p node)
+{
+	struct str_hash_entry *entry;
+
+	if(_dbg_cfgt_uuid==NULL || node==NULL || node->uuid.len == 0) return -1;
+	lock_get(&_dbg_cfgt_uuid->lock);
+	entry = str_hash_get(&_dbg_cfgt_uuid->hash, node->uuid.s, node->uuid.len);
+	if(entry)
+	{
+		entry->u.n = entry->u.n + 1;
+		node->msgid = entry->u.n;
+	}
+	else
+	{
+		entry = shm_malloc(sizeof(struct str_hash_entry));
+		if(entry==NULL)
+		{
+			lock_release(&_dbg_cfgt_uuid->lock);
+			LM_ERR("No shared memory left\n");
+			return -1;
+		}
+		if (shm_str_dup(&entry->key, &node->uuid) != 0)
+		{
+			lock_release(&_dbg_cfgt_uuid->lock);
+			shm_free(entry);
+			LM_ERR("No shared memory left\n");
+			return -1;
+		}
+		entry->u.n = 1;
+		node->msgid = 1;
+		LM_DBG("Add new entry[%.*s]\n", node->uuid.len, node->uuid.s);
+		str_hash_add(&_dbg_cfgt_uuid->hash, entry);
+	}
+	lock_release(&_dbg_cfgt_uuid->lock);
+	LM_DBG("msgid:[%d]\n", node->msgid);
+	return 1;
+}
+
+int _dbg_cfgt_create_node(struct sip_msg *msg)
+{
+	dbg_cfgt_node_p node;
+
+	node = (dbg_cfgt_node_p) pkg_malloc(sizeof(dbg_cfgt_node_t));
+	if(node==NULL)
+	{
+		LM_ERR("cannot allocate cfgtest msgnode\n");
+		return -1;
+	}
+	memset(node, 0, sizeof(dbg_cfgt_node_t));
+	srjson_InitDoc(&node->jdoc, NULL);
+	if (msg)
+	{
+		node->msgid = msg->id;
+		LM_DBG("msgid:%d\n", node->msgid);
+		if(_dbg_cfgt_get_hdr(msg, &node->uuid)!=0)
+		{
+			LM_ERR("cannot get value of cfgtest uuid header!!\n");
+			goto error;
+		}
+	}
+	node->jdoc.root = srjson_CreateObject(&node->jdoc);
+	if(node->jdoc.root==NULL)
+	{
+		LM_ERR("cannot create json root\n");
+		goto error;
+	}
+	node->flow = srjson_CreateArray(&node->jdoc);
+	if(node->flow==NULL)
+	{
+		LM_ERR("cannot create json object\n");
+		goto error;
+	}
+	srjson_AddItemToObject(&node->jdoc, node->jdoc.root, "flow\0", node->flow);
+	node->in = srjson_CreateArray(&node->jdoc);
+	if(node->in==NULL)
+	{
+		LM_ERR("cannot create json object\n");
+		goto error;
+	}
+	srjson_AddItemToObject(&node->jdoc, node->jdoc.root, "sip_in\0", node->in);
+	node->out = srjson_CreateArray(&node->jdoc);
+	if(node->out==NULL)
+	{
+		LM_ERR("cannot create json object\n");
+		goto error;
+	}
+	srjson_AddItemToObject(&node->jdoc, node->jdoc.root, "sip_out\0", node->out);
+	LM_DBG("node created\n");
+	if(_dbg_cfgt_head)
+	{
+		clist_append(_dbg_cfgt_head, node, next, prev);
+	}
+	else
+	{
+		LM_DBG("Initial node\n");
+		_dbg_cfgt_head = node;
+		clist_init(_dbg_cfgt_head, next, prev);
+	}
+	_dbg_pid_list[process_no].cfgt_node = node;
+	return 1;
+
+error:
+	srjson_DestroyDoc(&node->jdoc);
+	pkg_free(node);
+	_dbg_pid_list[process_no].cfgt_node = NULL;
+	return -1;
+}
+
+int _dbg_cfgt_get_hdr_helper(struct sip_msg *msg, str *res, int mode)
+{
+	struct hdr_field *hf;
+
+	if(msg==NULL || (mode==0 && res==NULL))
+		return -1;
+
+	/* we need to be sure we have parsed all headers */
+	if(parse_headers(msg, HDR_EOH_F, 0)<0)
+	{
+		LM_ERR("error parsing headers\n");
+		return -1;
+	}
+
+	for (hf=msg->headers; hf; hf=hf->next)
+	{
+		if (cmp_hdrname_str(&hf->name, &_dbg_cfgt_hdr_name)==0)
+		{
+			if(mode==0)
+			{
+				if(pkg_str_dup(&hf->body, res)<0)
+				{
+					LM_ERR("error copying header\n");
+					return -1;
+				}
+				LM_DBG("cfgtest uuid:%.*s\n", res->len, res->s);
+				return 0;
+			}
+			else return STR_EQ(hf->body, *res);
+		}
+	}
+	return 1; /* not found */
+}
+
+int _dbg_cfgt_get_hdr(struct sip_msg *msg, str *res)
+{
+	return _dbg_cfgt_get_hdr_helper(msg, res, 0);
+}
+
+int _dbg_cfgt_cmp_hdr(struct sip_msg *msg, str *res)
+{
+	return _dbg_cfgt_get_hdr_helper(msg, res, 1);
+}
+
+int _dbg_cfgt_get_filename(int msgid, str uuid, str *dest)
+{
+	int i, lid, lpid;
+	char buff_id[INT2STR_MAX_LEN], buff_pid[INT2STR_MAX_LEN];
+	char *sid, *spid;
+	if(dest==NULL || uuid.len == 0) return -1;
+	sid = sint2strbuf(msgid, buff_id, INT2STR_MAX_LEN, &lid);
+	spid = sint2strbuf(_dbg_pid_list[process_no].pid,
+		buff_pid, INT2STR_MAX_LEN, &lpid);
+	dest->len = _dbg_cfgt_basedir.len + uuid.len + lid + lpid + 8;
+	if(_dbg_cfgt_basedir.s[_dbg_cfgt_basedir.len-1]!='/')
+		dest->len = dest->len + 1;
+	dest->s = (char *) pkg_malloc(dest->len*sizeof(char));
+	if(dest->s==NULL)
+	{
+		LM_ERR("no more memory.\n");
+		return -1;
+	}
+
+	LM_DBG("id:[%.*s] pid:[%.*s] dest.len:[%d]\n", lid, sid,
+		lpid, spid, dest->len);
+	strncpy(dest->s, _dbg_cfgt_basedir.s, _dbg_cfgt_basedir.len);
+	i = _dbg_cfgt_basedir.len;
+	if(_dbg_cfgt_basedir.s[_dbg_cfgt_basedir.len-1]!='/')
+	{
+		strncpy(dest->s+i, "/", 1);
+		i = i + 1;
+	}
+	strncpy(dest->s+i, uuid.s, uuid.len);
+	i = i + uuid.len;
+	strncpy(dest->s+i, "/", 1);
+	i = i + 1;
+	strncpy(dest->s+i, spid, lpid);
+	i = i + lpid;
+	strncpy(dest->s+i, "_", 1);
+	i = i + 1;
+	strncpy(dest->s+i, sid, lid);
+	i = i + lid;
+	strncpy(dest->s+i, ".json\0", 6);
+	return 0;
+}
+
+void _dbg_cfgt_remove_node(dbg_cfgt_node_p node)
+{
+	if(!node) return;
+	srjson_DestroyDoc(&node->jdoc);
+	if(node->uuid.s) pkg_free(node->uuid.s);
+	clist_rm(node, next, prev);
+	while(node->route)
+	{
+		if(node->route->prev)
+		{
+			pkg_free(node->route->prev);
+			node->route->prev = NULL;
+		}
+		if(node->route->next) node->route = node->route->next;
+		else { pkg_free(node->route); node->route = NULL; }
+	}
+	if(_dbg_pid_list[process_no].cfgt_node == node)
+	{
+		LM_DBG("cfgt_node deleted\n");
+		_dbg_pid_list[process_no].cfgt_node = NULL;
+	}
+	pkg_free(node);
+}
+
+int _dbg_cfgt_save_node(dbg_cfgt_node_p node)
+{
+	FILE *f = NULL;
+	str filename = STR_NULL;
+	char *buf = NULL;
+	int res = -1;
+
+	if(!node) return -1;
+	LM_DBG("msgid:%d uuid:%.*s\n", node->msgid, node->uuid.len, node->uuid.s);
+	if(_dbg_cfgt_get_filename(node->msgid, node->uuid, &filename)<0)
+	{
+		LM_ERR("Cannot get filename\n");
+		res = -1;
+		goto clean;
+	}
+	f = fopen ( filename.s, "w");
+	if(f==NULL)
+	{
+		LM_ERR("Cannot open[%.*s] for write\n", filename.len, filename.s);
+		res = -1;
+		goto clean;
+	}
+	buf = srjson_PrintUnformatted(&node->jdoc, node->jdoc.root);
+	if(buf==NULL)
+	{
+		LM_ERR("Cannot get the json string\n");
+		fclose(f);
+		res = -1;
+		goto clean;
+	}
+	fwrite(buf, strlen(buf), 1, f);
+	fclose(f);
+	res = 0;
+
+clean:
+	if(filename.s) pkg_free(filename.s);
+	if(buf) node->jdoc.free_fn(buf);
+	return res;
+}
+
+int _dbg_cfgt_save(str *uuid)
+{
+	int res = 0;
+	dbg_cfgt_node_p node, back;
+
+	if(_dbg_cfgt_head==NULL || uuid == NULL) return -1;
+	if(uuid->len>0)
+	{
+		clist_foreach_safe(_dbg_cfgt_head, node, back, next)
+		{
+			if(STR_EQ(node->uuid, *uuid))
+			{
+				if(_dbg_cfgt_save_node(node)<0)
+				{
+					LM_ERR("Cannot save node:%p\n", node);
+					_dbg_cfgt_print_node(node);
+					res = res - 1;
+				}
+				_dbg_cfgt_remove_node(node);
+			}
+		}
+		_dbg_cfgt_remove_uuid(uuid);
+	}
+	else
+	{
+		clist_foreach_safe(_dbg_cfgt_head, node, back, next)
+		{
+			if(_dbg_cfgt_save_node(node)<0)
+			{
+				LM_ERR("Cannot save node:%p\n", node);
+				_dbg_cfgt_print_node(node);
+				res = res - 1;
+			}
+			_dbg_cfgt_remove_node(node);
+		}
+		_dbg_cfgt_remove_uuid(NULL);
+	}
+	return res;
+}
+
+int _dbg_cfgt_set_dump(struct sip_msg *msg, dbg_cfgt_node_p node, str *flow)
+{
+	srjson_t *f, *vars;
+
+	if(node==NULL || flow == NULL) return -1;
+	vars = srjson_CreateObject(&node->jdoc);
+	if(vars==NULL)
+	{
+		LM_ERR("cannot create json object\n");
+		return -1;
+	}
+	if(_dbg_get_json(msg, 30, &node->jdoc, vars)<0)
+	{
+		LM_ERR("cannot get var info\n");
+		return -1;
+	}
+	f = srjson_CreateObject(&node->jdoc);
+	if(f==NULL)
+	{
+		LM_ERR("cannot create json object\n");
+		srjson_Delete(&node->jdoc, vars);
+		return -1;
+	}
+	srjson_AddStrItemToObject(&node->jdoc, f,
+		flow->s, flow->len, vars);
+	srjson_AddItemToArray(&node->jdoc, node->flow, f);
+	LM_DBG("node[%.*s] flow created\n", flow->len, flow->s);
+	return 0;
+}
+
+void _dbg_cfgt_set_type(dbg_cfgt_str_list_p route, struct action *a)
+{
+	switch(a->type)
+	{
+		case DROP_T:
+			if(a->val[1].u.number&DROP_R_F)
+				route->type = DBG_CFGT_DROP_D;
+			if(a->val[1].u.number&RETURN_R_F)
+				route->type = DBG_CFGT_DROP_R;
+			else route->type = DBG_CFGT_DROP_E;
+			LM_DBG("set[%.*s][%d]\n", route->s.len, route->s.s, route->type);
+			break;
+		case ROUTE_T:
+			route->type = DBG_CFGT_ROUTE;
+			LM_DBG("set[%.*s][%d]\n", route->s.len, route->s.s, route->type);
+			break;
+		default:
+			LM_DBG("no relevant action\n");
+			route->type = DBG_CFGT_DROP_R;
+			break;
+	}
+}
+
+int _dbg_cfgt_add_routename(dbg_cfgt_node_p node, struct action *a,
+		str *routename)
+{
+	dbg_cfgt_str_list_p route;
+	int ret = 0;
+
+	if(!node->route) /* initial */
+	{
+		node->route = pkg_malloc(sizeof(dbg_cfgt_str_list_t));
+		if(!node->route)
+		{
+			LM_ERR("No more pkg mem\n");
+			return -1;
+		}
+		memset(node->route, 0, sizeof(dbg_cfgt_str_list_t));
+		node->flow_head = node->route;
+		node->route->type = DBG_CFGT_ROUTE;
+		ret = 1;
+	}
+	else
+	{
+		LM_DBG("actual routename:[%.*s][%d]\n", node->route->s.len,
+			node->route->s.s, node->route->type);
+		if(node->route->prev)
+			LM_DBG("prev routename:[%.*s][%d]\n", node->route->prev->s.len,
+				node->route->prev->s.s,	node->route->prev->type);
+		if(STR_EQ(*routename, node->route->s))
+		{
+			LM_DBG("same route\n");
+			_dbg_cfgt_set_type(node->route, a);
+			return 2;
+		}
+		else if(node->route->prev &&
+				STR_EQ(*routename, node->route->prev->s))
+		{
+			LM_DBG("back to route[%.*s]\n", node->route->prev->s.len,
+				node->route->prev->s.s);
+			_dbg_cfgt_set_type(node->route->prev, a);
+			return 3;
+		}
+		route = pkg_malloc(sizeof(dbg_cfgt_str_list_t));
+		if(!route)
+		{
+			LM_ERR("No more pkg mem\n");
+			return -1;
+		}
+		memset(route, 0, sizeof(dbg_cfgt_str_list_t));
+		route->prev = node->route;
+		node->route->next = route;
+		node->route = route;
+		_dbg_cfgt_set_type(node->route, a);
+	}
+	node->route->s.s = routename->s;
+	node->route->s.len = routename->len;
+	LM_DBG("add[%d] route:[%.*s]\n", ret, node->route->s.len, node->route->s.s);
+	_dbg_cfgt_print_node(node);
+	return ret;
+}
+
+void _dbg_cfgt_del_routename(dbg_cfgt_node_p node)
+{
+	LM_DBG("del route[%.*s]\n", node->route->s.len, node->route->s.s);
+	node->route = node->route->prev;
+	pkg_free(node->route->prev);
+	node->route->next = NULL;
+}
+/* dest has to be free */
+int _dbg_cfgt_node_get_flowname(dbg_cfgt_str_list_p route, int *indx, str *dest)
+{
+	int i;
+	if(route==NULL) return -1;
+	LM_DBG("routename:[%.*s][%d]\n", route->s.len, route->s.s,
+		route->type);
+	if(indx) i = *indx;
+	else i = route->type-1;
+	if(str_append(&_dbg_cfgt_route_prefix[i],
+		&route->s, dest)<0)
+	{
+		LM_ERR("Cannot create route name\n");
+		return -1;
+	}
+	return 0;
+}
+int _dbg_cfgt_process_route(struct sip_msg *msg,
+		dbg_cfgt_node_p node, struct action *a)
+{
+	str routename = {a->rname, strlen(a->rname)};
+	int ret = -1;
+	int indx = 0;
+	str flowname = STR_NULL;
+	LM_DBG("route from action:[%s]\n", a->rname);
+	switch(_dbg_cfgt_add_routename(node, a, &routename))
+	{
+		case 2: /* same name */
+			return 0;
+		case 1: /* initial */
+			LM_DBG("Initial route[%.*s]. dump vars\n",
+				node->route->s.len, node->route->s.s);
+			if(_dbg_cfgt_node_get_flowname(node->route, &indx, &flowname)<0)
+			{
+				LM_ERR("cannot create flowname\n");
+				return -1;
+			}
+			ret = _dbg_cfgt_set_dump(msg, node, &flowname);
+			break;
+		case 0: /* new */
+			LM_DBG("Change from[%.*s] route to route[%.*s]. dump vars\n",
+				node->route->prev->s.len, node->route->prev->s.s,
+				node->route->s.len, node->route->s.s);
+			if(_dbg_cfgt_node_get_flowname(node->route, &indx, &flowname)<0)
+			{
+				LM_ERR("cannot create flowname\n");
+				return -1;
+			}
+			ret = _dbg_cfgt_set_dump(msg, node, &flowname);
+			break;
+		case 3: /* back to previous */
+			if(_dbg_cfgt_node_get_flowname(node->route, 0, &flowname)<0)
+			{
+				LM_ERR("cannot create flowname\n");
+				return -1;
+			}
+			ret = _dbg_cfgt_set_dump(msg, node, &flowname);
+			_dbg_cfgt_del_routename(node);
+			break;
+		default:
+			return -1;
+	}
+	if(flowname.s) pkg_free(flowname.s);
+	return ret;
+}
+
+void _dbg_cfgt_print_node(dbg_cfgt_node_p node)
+{
+	char *buf = NULL;
+	dbg_cfgt_str_list_p route;
+
+	if(!node) return;
+	if(node->flow_head)
+	{
+		route = node->flow_head;
+		while(route)
+		{
+			if(route == node->route)
+				LM_DBG("[--[%.*s][%d]--]\n", route->s.len, route->s.s, route->type);
+			else LM_DBG("[%.*s][%d]\n", route->s.len, route->s.s, route->type);
+			route = route->next;
+		}
+	}
+	else LM_DBG("flow:empty\n");
+	return;
+	buf = srjson_PrintUnformatted(&node->jdoc, node->jdoc.root);
+	if(buf==NULL)
+	{
+		LM_ERR("Cannot get the json string\n");
+		return;
+	}
+	LM_DBG("node[%p]: id:[%d] uuid:[%.*s] info:[%s]\n",
+		node, node->msgid, node->uuid.len, node->uuid.s, buf);
+	node->jdoc.free_fn(buf);
+}
--- a/modules/debugger/debugger_api.h
+++ b/modules/debugger/debugger_api.h
@@ -57,5 +57,8 @@
 #define DBG_DP_OTHER		16
 #define DBG_DP_ALL			31
 int dbg_dump_json(struct sip_msg* msg, unsigned int mask, int level);
+
+int dbg_init_cfgtest(void);
+int dbg_cfgt_filter(struct sip_msg *msg, unsigned int flags, void *bar);
 #endif
 
--- a/modules/debugger/debugger_mod.c
+++ b/modules/debugger/debugger_mod.c
@@ -61,6 +61,9 @@
 extern int _dbg_step_usleep;
 extern int _dbg_step_loops;
 extern int _dbg_reset_msgid;
+extern int _dbg_cfgtest;
+extern str _dbg_cfgt_hdr_name;
+extern str _dbg_cfgt_basedir;
 
 static char * _dbg_cfgtrace_facility_str = 0;
 static int _dbg_log_assign = 0;
@@ -91,6 +94,9 @@
 	{"mod_level",         STR_PARAM|USE_FUNC_PARAM, (void*)dbg_mod_level_param},
 	{"reset_msgid",       INT_PARAM, &_dbg_reset_msgid},
 	{"cfgpkgcheck",       INT_PARAM, &_dbg_cfgpkgcheck},
+	{"cfgtest",           INT_PARAM, &_dbg_cfgtest},
+	{"cfgt_hdr_name",     STR_PARAM, &_dbg_cfgt_hdr_name.s},
+	{"cfgt_basedir",      STR_PARAM, &_dbg_cfgt_basedir.s},
 	{0, 0, 0}
 };
 
@@ -166,6 +172,21 @@
 			return -1;
 		}
 	}
+	if(_dbg_cfgtest==1)
+	{
+		unsigned int ALL = REQUEST_CB+FAILURE_CB+ONREPLY_CB
+		  +BRANCH_CB+ONSEND_CB+ERROR_CB+LOCAL_CB+EVENT_CB+BRANCH_FAILURE_CB;
+		if (register_script_cb(dbg_cfgt_filter, PRE_SCRIPT_CB|ALL, 0) != 0)
+		{
+			LM_ERR("could not insert callback");
+			return -1;
+		}
+		if (_dbg_cfgt_hdr_name.s)
+			_dbg_cfgt_hdr_name.len = strlen(_dbg_cfgt_hdr_name.s);
+		if (_dbg_cfgt_basedir.s)
+			_dbg_cfgt_basedir.len = strlen(_dbg_cfgt_basedir.s);
+		dbg_init_cfgtest();
+	}
 	return dbg_init_bp_list();
 }
 
