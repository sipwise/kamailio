From: Victor Seva <vseva@sipwise.com>
Date: Tue, 19 Apr 2022 12:57:33 +0200
Subject: cfgt: fix memory leaks

- free parsed message
- free srjson object left behind

+ remove unused headers
+ remove unused function
+ parse only HDR_CALLID_F
---
 src/modules/cfgt/cfgt_int.c  | 33 +++++++++--------------------
 src/modules/cfgt/cfgt_json.c | 49 +++++++++++++++++++++++++++++++++++++++++---
 2 files changed, 56 insertions(+), 26 deletions(-)

diff --git a/src/modules/cfgt/cfgt_int.c b/src/modules/cfgt/cfgt_int.c
index 7b0c991..b8345b4 100644
--- a/src/modules/cfgt/cfgt_int.c
+++ b/src/modules/cfgt/cfgt_int.c
@@ -32,10 +32,6 @@
 #include "../../core/rpc.h"
 #include "../../core/rpc_lookup.h"
 #include "../../core/parser/msg_parser.h"
-#include "../../core/parser/parse_uri.h"
-#include "../../core/parser/parse_to.h"
-#include "../../core/parser/parse_from.h"
-#include "../../core/parser/parse_cseq.h"
 
 #include "cfgt_int.h"
 #include "cfgt_json.h"
@@ -73,18 +69,6 @@ static int _cfgt_init_hashtable(struct str_hash_table *ht)
 	return 0;
 }
 
-int _cfgt_pv_parse(str *param, pv_elem_p *elem)
-{
-	if(param->s && param->len > 0) {
-		if(pv_parse_format(param, elem) < 0) {
-			LM_ERR("malformed or non AVP %.*s AVP definition\n", param->len,
-					param->s);
-			return -1;
-		}
-	}
-	return 0;
-}
-
 void _cfgt_remove_report(const str *scen)
 {
 	str dest = STR_NULL;
@@ -234,8 +218,7 @@ int _cfgt_get_hdr_helper(struct sip_msg *msg, str *res, int mode)
 	if(msg == NULL || (mode == 0 && res == NULL))
 		return -1;
 
-	/* we need to be sure we have parsed all headers */
-	if(parse_headers(msg, HDR_EOH_F, 0) < 0) {
+	if(parse_headers(msg, HDR_CALLID_F, 0) < 0) {
 		LM_ERR("error parsing headers\n");
 		return -1;
 	}
@@ -636,27 +619,31 @@ int _cfgt_node_get_flowname(cfgt_str_list_p route, int *indx, str *dest)
 
 int _cfgt_parse_msg(sip_msg_t *msg)
 {
+	int res = 1;
 	if(parse_msg(msg->buf, msg->len, msg) != 0) {
 		LM_ERR("outbuf buffer parsing failed!");
-		return 1;
+		return res;
 	}
 
 	if(msg->first_line.type == SIP_REQUEST) {
 		if(!IS_SIP(msg)) {
 			LM_DBG("non sip request message\n");
-			return 1;
+			goto done;
 		}
 	} else if(msg->first_line.type == SIP_REPLY) {
 		if(!IS_SIP_REPLY(msg)) {
 			LM_DBG("non sip reply message\n");
-			return 1;
+			goto done;
 		}
 	} else {
 		LM_DBG("non sip message\n");
-		return 1;
+		goto done;
 	}
+	res = 0;
 
-	return 0;
+done:
+	free_sip_msg(msg);
+	return res;
 }
 
 int cfgt_process_route(struct sip_msg *msg, struct action *a)
diff --git a/src/modules/cfgt/cfgt_json.c b/src/modules/cfgt/cfgt_json.c
index d3aca8d..49fe5fc 100644
--- a/src/modules/cfgt/cfgt_json.c
+++ b/src/modules/cfgt/cfgt_json.c
@@ -60,12 +60,16 @@ int _cfgt_get_array_avp_vals(struct sip_msg *msg, pv_param_t *param,
 			jobjt = srjson_CreateStr(jdoc, avp_value.s.s, avp_value.s.len);
 			if(jobjt == NULL) {
 				LM_ERR("cannot create json object\n");
+				srjson_Delete(jdoc, *jobj);
+				*jobj = NULL;
 				return -1;
 			}
 		} else {
 			jobjt = srjson_CreateNumber(jdoc, avp_value.n);
 			if(jobjt == NULL) {
 				LM_ERR("cannot create json object\n");
+				srjson_Delete(jdoc, *jobj);
+				*jobj = NULL;
 				return -1;
 			}
 		}
@@ -112,12 +116,24 @@ void _cfgt_get_obj_xavp_val(sr_xavp_t *avp, srjson_doc_t *jdoc, srjson_t **jobj)
 	switch(avp->val.type) {
 		case SR_XTYPE_NULL:
 			*jobj = srjson_CreateNull(jdoc);
+			if(*jobj == NULL) {
+				LM_ERR("cannot create json object\n");
+				return;
+			}
 			break;
 		case SR_XTYPE_INT:
 			*jobj = srjson_CreateNumber(jdoc, avp->val.v.i);
+			if(*jobj == NULL) {
+				LM_ERR("cannot create json object\n");
+				return;
+			}
 			break;
 		case SR_XTYPE_STR:
 			*jobj = srjson_CreateStr(jdoc, avp->val.v.s.s, avp->val.v.s.len);
+			if(*jobj == NULL) {
+				LM_ERR("cannot create json object\n");
+				return;
+			}
 			break;
 		case SR_XTYPE_TIME:
 			result = snprintf(
@@ -141,12 +157,24 @@ void _cfgt_get_obj_xavp_val(sr_xavp_t *avp, srjson_doc_t *jdoc, srjson_t **jobj)
 		default:
 			LM_WARN("unknown data type\n");
 			*jobj = srjson_CreateNull(jdoc);
+			if(*jobj == NULL) {
+				LM_ERR("cannot create json object\n");
+				return;
+			}
 	}
 	if(result < 0) {
 		LM_ERR("cannot convert to str\n");
 		*jobj = srjson_CreateNull(jdoc);
+		if(*jobj == NULL) {
+			LM_ERR("cannot create json object\n");
+			return;
+		}
 	} else if(*jobj == NULL) {
 		*jobj = srjson_CreateStr(jdoc, _pv_xavp_buf, 128);
+		if(*jobj == NULL) {
+			LM_ERR("cannot create json object\n");
+			return;
+		}
 	}
 }
 
@@ -167,6 +195,9 @@ int _cfgt_get_obj_avp_vals(
 	}
 	while(avp != NULL) {
 		_cfgt_get_obj_xavp_val(avp, jdoc, &jobjt);
+		if(jobjt == NULL) {
+			return -1;
+		}
 		srjson_AddItemToArray(jdoc, *jobj, jobjt);
 		jobjt = NULL;
 		avp = xavp_get_next(avp);
@@ -205,14 +236,18 @@ int _cfgt_get_obj_xavp_vals(struct sip_msg *msg, pv_param_t *param,
 			jobj = srjson_CreateObject(jdoc);
 			if(jobj == NULL) {
 				LM_ERR("cannot create json object\n");
+				srjson_Delete(jdoc, *jobjr);
+				jobjr = NULL;
 				return -1;
 			}
 			keys = xavp_get_list_key_names(xavp);
 			if(keys != NULL) {
 				do {
 					_cfgt_get_obj_avp_vals(keys->s, avp, jdoc, &jobjt);
-					srjson_AddStrItemToObject(
-							jdoc, jobj, keys->s.s, keys->s.len, jobjt);
+					if(jobjt) {
+						srjson_AddStrItemToObject(
+								jdoc, jobj, keys->s.s, keys->s.len, jobjt);
+					}
 					k = keys;
 					keys = keys->next;
 					pkg_free(k);
@@ -257,6 +292,10 @@ int cfgt_get_json(struct sip_msg *msg, unsigned int mask, srjson_doc_t *jdoc,
 	for(i = 0; i < PV_CACHE_SIZE; i++) {
 		el = _pv_cache[i];
 		while(el) {
+			if(jobj) {
+				srjson_Delete(jdoc, jobj);
+				jobj = NULL;
+			}
 			if(!(el->spec.type == PVT_AVP || el->spec.type == PVT_SCRIPTVAR
 					   || el->spec.type == PVT_XAVP
 					   || el->spec.type == PVT_OTHER)
@@ -271,7 +310,6 @@ int cfgt_get_json(struct sip_msg *msg, unsigned int mask, srjson_doc_t *jdoc,
 				el = el->next;
 				continue;
 			}
-			jobj = NULL;
 			item_name.len = 0;
 			item_name.s = 0;
 			iname[0] = '\0';
@@ -343,8 +381,12 @@ int cfgt_get_json(struct sip_msg *msg, unsigned int mask, srjson_doc_t *jdoc,
 					}
 				} else if(value.flags & (PV_VAL_INT)) {
 					jobj = srjson_CreateNumber(jdoc, value.ri);
+					if(jobj == NULL)
+						LM_ERR("cannot create json object\n");
 				} else if(value.flags & (PV_VAL_STR)) {
 					jobj = srjson_CreateStr(jdoc, value.rs.s, value.rs.len);
+					if(jobj == NULL)
+						LM_ERR("cannot create json object\n");
 				} else {
 					LM_WARN("el->pvname[%.*s] value[%d] unhandled\n",
 							el->pvname.len, el->pvname.s, value.flags);
@@ -360,6 +402,7 @@ int cfgt_get_json(struct sip_msg *msg, unsigned int mask, srjson_doc_t *jdoc,
 			}
 			if(jobj != NULL) {
 				srjson_AddItemToObject(jdoc, head, iname, jobj);
+				jobj = NULL;
 			}
 			el = el->next;
 		}
