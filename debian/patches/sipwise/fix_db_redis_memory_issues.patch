--- a/src/modules/db_redis/redis_connection.c
+++ b/src/modules/db_redis/redis_connection.c
@@ -339,6 +339,11 @@
     int ret;
     redis_key_t *query;
 
+    if (!con || !con->con) {
+        LM_ERR("Internal error passing null connection\n");
+        return -1;
+    }
+
     *reply = NULL;
     ret = redisGetReply(con->con, reply);
     if (con->con->err == REDIS_ERR_EOF) {
@@ -350,6 +355,7 @@
                 redisFree(con->con);
                 con->con = NULL;
             }
+            return -1;
         }
         // take commands from oldest to newest and re-do again,
         // but don't queue them once again in retry-mode
@@ -396,4 +402,4 @@
         LM_DBG("consuming queued command\n");
         db_redis_key_free(&query);
     }
-}
\ No newline at end of file
+}
--- a/src/modules/db_redis/redis_dbase.c
+++ b/src/modules/db_redis/redis_dbase.c
@@ -378,8 +378,6 @@
         goto err;
     }
     if (key_found) {
-        db_redis_key_add_str(keys, &keyname);
-
         if (db_redis_key_add_str(keys, &keyname) != 0) {
             LM_ERR("Failed to add key string\n");
             goto err;
@@ -470,7 +468,10 @@
             goto err;
         }
         if (key_found) {
-            db_redis_key_add_str(keys, &keyname);
+            if (db_redis_key_add_str(keys, &keyname) != 0) {
+                LM_ERR("Failed to add query key to key list\n");
+                goto err;
+            }
             (*keys_count)++;
             LM_DBG("found key '%.*s' for type '%.*s'\n",
                     keyname.len, keyname.s,
@@ -526,7 +527,10 @@
     if (key_found) {
         LM_DBG("found suitable entry key '%.*s' for query\n",
                 keyname.len, keyname.s);
-        db_redis_key_add_str(query_keys, &keyname);
+        if (db_redis_key_add_str(query_keys, &keyname) != 0) {
+            LM_ERR("Failed to add key name to query keys\n");
+            goto err;
+        }
         *query_keys_count = 1;
         pkg_free(keyname.s);
         keyname.s = NULL;
@@ -544,10 +548,12 @@
 
                 if (db_redis_key_add_string(&query_v, prefix, strlen(prefix)) != 0) {
                     LM_ERR("Failed to add smembers command to query\n");
+                    db_redis_key_free(&query_v);
                     goto err;
                 }
                 if (db_redis_key_add_str(&query_v, &keyname) != 0) {
                     LM_ERR("Failed to add key name to smembers query\n");
+                    db_redis_key_free(&query_v);
                     goto err;
                 }
 
@@ -665,6 +671,14 @@
             LM_ERR("Failed to add match pattern to scan query\n");
             goto err;
         }
+        if (db_redis_key_add_string(&query_v, "COUNT", 5) != 0) {
+            LM_ERR("Failed to add count command to scan query\n");
+            goto err;
+        }
+        if (db_redis_key_add_string(&query_v, "1000", 5) != 0) {
+            LM_ERR("Failed to add count value to scan query\n");
+            goto err;
+        }
         pkg_free(match); match = NULL;
 
         reply = db_redis_command_argv(con, query_v);
@@ -691,6 +705,7 @@
                     table_name->len, table_name->s);
             goto err;
         }
+        LM_ERR("cursor is %lu\n", cursor);
 
         if (reply->element[1]->type != REDIS_REPLY_ARRAY) {
             LM_ERR("Invalid content type for scan on table '%.*s', expected array\n",
@@ -717,8 +732,9 @@
                         j, table_name->len, table_name->s);
                 goto err;
             }
-            if (db_redis_key_add_string(query_keys, key->str, strlen(key->str)) != 0) {
-                LM_ERR("Failed to add redis key\n");
+            LM_ERR("+++ adding key '%s'\n", key->str);
+            if (db_redis_key_prepend_string(query_keys, key->str, strlen(key->str)) != 0) {
+                LM_ERR("Failed to prepend redis key\n");
                 goto err;
             }
         }
@@ -740,6 +756,8 @@
     if (reply) {
         db_redis_free_reply(&reply);
     }
+
+    LM_ERR("got %lu entries by scan\n", i);
     return 0;
 
 err:
@@ -1047,7 +1065,7 @@
     redis_key_t *query_v = NULL;
     int num_rows = 0;
     redis_key_t *key;
-    int j;
+    int i, j, max;
 
     *_r = db_redis_new_result();
     if (!*_r) {
@@ -1062,7 +1080,7 @@
     RES_NUM_ROWS(*_r) = RES_ROW_N(*_r) = 0;
     RES_COL_N(*_r) = _nc;
 
-    if (!keys_count && do_table_scan) {
+    if (!(*keys_count) && do_table_scan) {
         LM_DBG("performing full table scan\n");
         if (db_redis_scan_query_keys(con, CON_TABLE(_h), _k, _n,
                     keys, keys_count,
@@ -1072,12 +1090,26 @@
         }
     }
 
+    // we allocate best case scenario (all rows match)
+    RES_NUM_ROWS(*_r) = RES_ROW_N(*_r) = *keys_count;
+    if (db_allocate_rows(*_r) != 0) {
+        LM_ERR("Failed to allocate memory for rows\n");
+        return -1;
+    }
+    RES_COL_N(*_r) = _nc;
+    // reset and increment in convert_row
+    RES_NUM_ROWS(*_r) = RES_ROW_N(*_r) = 0;
+
     for (key = *keys; key; key = key->next) {
         redis_key_t *tmp = NULL;
         str *keyname = &(key->key);
 
         num_rows++;
 
+        if (do_table_scan) {
+            LM_ERR("+++ checking row %d of %d\n", num_rows, *keys_count);
+        }
+
         LM_DBG("checking key '%s' in redis\n", keyname->s);
 
         if (db_redis_key_add_string(&query_v, "EXISTS", 6) != 0) {
@@ -1134,56 +1166,57 @@
 
         db_redis_key_free(&query_v);
         query_v = NULL;
-    }
-
-    // we allocate best case scenario (all rows match)
-    RES_NUM_ROWS(*_r) = RES_ROW_N(*_r) = num_rows;
-    if (db_allocate_rows(*_r) != 0) {
-        LM_ERR("Failed to allocate memory for rows\n");
-        return -1;
-    }
-    RES_COL_N(*_r) = _nc;
-    // reset and increment in convert_row
-    RES_NUM_ROWS(*_r) = RES_ROW_N(*_r) = 0;
 
-    for (key = *keys; key; key = key->next) {
-        // get reply for EXISTS query
-        if (db_redis_get_reply(con, (void**)&reply) != REDIS_OK) {
-            LM_ERR("Failed to get reply for query: %s\n",
-                    con->con->errstr);
-            goto error;
-        }
-        db_redis_check_reply(con, reply, error);
-        if (reply->integer == 0) {
-            LM_DBG("key does not exist, returning no row for query\n");
-            db_redis_free_reply(&reply);
-            // also free next reply, as this is a null row for the HMGET
-            db_redis_get_reply(con, (void**)&reply);
-            db_redis_check_reply(con, reply, error);
-            db_redis_free_reply(&reply);
-            continue;
-        }
-        db_redis_free_reply(&reply);
+        max = 0;
+        if (*keys_count == num_rows)
+            max = (*keys_count) % 1000;
+        else if (num_rows % 1000 == 0)
+            max = 1000;
+
+        if (max) {
+            LM_ERR("+++ fetching next %d results\n", max);
+            for (i = 0; i < max; ++i) {
+                // get reply for EXISTS query
+                LM_ERR("+++ get exists-reply for subrow %d\n", i);
+                if (db_redis_get_reply(con, (void**)&reply) != REDIS_OK) {
+                    LM_ERR("Failed to get reply for query: %s\n",
+                            con->con->errstr);
+                    goto error;
+                }
+                db_redis_check_reply(con, reply, error);
+                if (reply->integer == 0) {
+                    LM_DBG("key does not exist, returning no row for query\n");
+                    db_redis_free_reply(&reply);
+                    // also free next reply, as this is a null row for the HMGET
+                    db_redis_get_reply(con, (void**)&reply);
+                    db_redis_check_reply(con, reply, error);
+                    db_redis_free_reply(&reply);
+                    continue;
+                }
+                db_redis_free_reply(&reply);
 
-        // get reply for actual HMGET query
-        if (db_redis_get_reply(con, (void**)&reply) != REDIS_OK) {
-            LM_ERR("Failed to get reply for query: %s\n",
-                    con->con->errstr);
-            goto error;
-        }
-        db_redis_check_reply(con, reply, error);
-        if (reply->type != REDIS_REPLY_ARRAY) {
-            LM_ERR("Unexpected reply, expected array\n");
-            goto error;
-        }
-        LM_DBG("dumping full query reply for row\n");
-        db_redis_dump_reply(reply);
+                // get reply for actual HMGET query
+                LM_ERR("+++ get hmget-reply for subrow %d\n", i);
+                if (db_redis_get_reply(con, (void**)&reply) != REDIS_OK) {
+                    LM_ERR("Failed to get reply for query: %s\n",
+                            con->con->errstr);
+                    goto error;
+                }
+                db_redis_check_reply(con, reply, error);
+                if (reply->type != REDIS_REPLY_ARRAY) {
+                    LM_ERR("Unexpected reply, expected array\n");
+                    goto error;
+                }
+                LM_DBG("dumping full query reply for row\n");
+                db_redis_dump_reply(reply);
 
-        if (db_redis_convert_row(con, *_r, _k, _v, _op, reply, CON_TABLE(_h), _c, _nc, *manual_keys, *manual_keys_count)) {
-            LM_ERR("Failed to convert redis reply for row\n");
-            goto error;
+                if (db_redis_convert_row(con, *_r, _k, _v, _op, reply, CON_TABLE(_h), _c, _nc, *manual_keys, *manual_keys_count)) {
+                    LM_ERR("Failed to convert redis reply for row\n");
+                    goto error;
+                }
+                db_redis_free_reply(&reply);
+            }
         }
-        db_redis_free_reply(&reply);
     }
 
     return 0;
@@ -1193,7 +1226,7 @@
     db_redis_key_free(&query_v);
     if(reply)
         db_redis_free_reply(&reply);
-    if(_r && *_r) {
+    if(*_r) {
         db_redis_free_result((db1_con_t*)_h, *_r); *_r = NULL;
     }
     return -1;
@@ -1354,7 +1387,9 @@
             goto error;
         }
         pkg_free(db_keys);
+        db_keys = NULL;
         pkg_free(db_vals);
+        db_vals = NULL;
         db_redis_free_reply(&reply);
 
         if (db_redis_key_add_string(&query_v, "DEL", 3) != 0) {
@@ -1395,6 +1430,7 @@
     }
     db_redis_key_free(&type_keys);
     db_redis_key_free(&all_type_keys);
+    db_redis_key_free(&query_v);
 
     return 0;
 
@@ -1426,7 +1462,7 @@
     int j;
     size_t col;
 
-    if (!keys_count && do_table_scan) {
+    if (!(*keys_count) && do_table_scan) {
         LM_DBG("performing full table scan\n");
         if (db_redis_scan_query_keys(con, CON_TABLE(_h), _k, _n,
                     keys, keys_count,
@@ -1664,6 +1700,11 @@
     // TODO: optimize mapping-based manual post-check (remove check for keys already
     // in type query key)
 
+    if (!_r) {
+        LM_ERR("db result is null\n");
+        return -1;
+    }
+
     con = REDIS_CON(_h);
     if (con && con->con == NULL) {
         if (db_redis_connect(con) != 0) {
@@ -1683,7 +1724,7 @@
                 CON_TABLE(_h)->len, CON_TABLE(_h)->s);
     }
 
-    if(_r) *_r = NULL;
+    *_r = NULL;
 
     // check if we have a version query, and return version directly from
     // schema instead of loading it from redis
@@ -1731,6 +1772,7 @@
     } else {
         LM_DBG("no columns given to build query keys, falling back to full table scan\n");
         keys_count = 0;
+        do_table_scan = 1;
     }
 
     if (db_redis_perform_query(_h, con, _k, _v, query_ops, _c, _n, _nc, _r,
--- a/src/modules/db_redis/redis_table.c
+++ b/src/modules/db_redis/redis_table.c
@@ -313,8 +313,12 @@
                 col_last = (&col_ht->table[j])->prev;
                 clist_foreach(&col_ht->table[j], col_he, next) {
                     pkg_free(col_he->key.s);
-                    pkg_free(col_he);
-                    if (col_he == col_last) break;
+                    if (col_he == col_last) {
+                        pkg_free(col_he);
+                        break;
+                    } else {
+                        pkg_free(col_he);
+                    }
                 }
             }
             pkg_free(col_ht->table);
@@ -340,9 +344,13 @@
             }
             pkg_free(table);
             pkg_free(he->key.s);
-            pkg_free(he);
+            if (he == last) {
+                pkg_free(he);
+                break;
+            } else {
+                pkg_free(he);
+            }
 
-            if (he == last) break;
         }
     }
     pkg_free(ht->table);
@@ -409,6 +417,7 @@
         LM_ERR("Failed to allocate memory for table schema hashtable\n");
         pkg_free(e->key.s);
         pkg_free(e);
+        pkg_free(t);
         return NULL;
     }
     str_hash_init(&t->columns);
@@ -426,6 +435,7 @@
     }
     if (pkg_str_dup(&e->key, col) != 0) {
         LM_ERR("Failed to allocate memory for column name\n");
+        pkg_free(e);
         return NULL;
     }
     e->flags = 0;
@@ -453,6 +463,7 @@
         default:
             LM_ERR("Invalid schema column type '%.*s', expecting one of string, int, timestamp, double, blob\n",
                     type->len, type->s);
+            pkg_free(e->key.s);
             pkg_free(e);
             return NULL;
     }
@@ -494,6 +505,8 @@
     p = start = redis_keys.s;
     state = DBREDIS_KEYS_TABLE_ST;
     do {
+        type = NULL;
+        key = NULL;
         switch(state) {
             case DBREDIS_KEYS_TABLE_ST:
                 while(p != end && *p != '=')
@@ -539,6 +552,10 @@
                     if (!table->types) {
                         table->types = type_target = type;
                     } else {
+                        if (!type_target) {
+                            LM_ERR("Internal error accessing null type_target\n");
+                            goto err;
+                        }
                         type_target->next = type;
                         type_target = type_target->next;
                     }
@@ -571,6 +588,10 @@
                 if (*key_target == NULL) {
                     *key_target = key_location = key;
                 } else {
+                    if (!key_location) {
+                        LM_ERR("Internal error, null key_location pointer\n");
+                        goto err;
+                    }
                     key_location->next = key;
                     key_location = key_location->next;
                 }
@@ -586,6 +607,10 @@
     return 0;
 
 err:
+    if (type)
+        pkg_free(type);
+    if (key)
+        pkg_free(key);
     db_redis_free_tables(con);
     return -1;
 }
@@ -608,7 +633,8 @@
     char full_path[_POSIX_PATH_MAX + 1];
     int path_len;
     struct stat fstat;
-    char c;
+    unsigned char c;
+    int cc;
 
     enum {
         DBREDIS_SCHEMA_COLUMN_ST,
@@ -699,14 +725,15 @@
                 goto err;
             }
 
-            c = fgetc(fin);
+            cc = fgetc(fin);
+            c = (unsigned char)cc;
 
             if (c == '\r')
                 continue;
             //LM_DBG("parsing char %c, buf is '%s' at pos %lu\n", c, buf, bufpos);
             switch(state) {
                 case DBREDIS_SCHEMA_COLUMN_ST:
-                    if (c == EOF) {
+                    if (cc == EOF) {
                         LM_ERR("Unexpected end of file in schema column name of file %s\n", full_path);
                         goto err;
                     }
@@ -732,7 +759,7 @@
                     LM_DBG("found column name '%.*s'\n", column_name.len, column_name.s);
                     break;
                 case DBREDIS_SCHEMA_TYPE_ST:
-                    if (c == EOF) {
+                    if (cc == EOF) {
                         LM_ERR("Unexpected end of file in schema column type of file %s\n", full_path);
                         goto err;
                     }
@@ -772,7 +799,7 @@
                     bufptr = buf;
                     break;
                 case DBREDIS_SCHEMA_VERSION_ST:
-                    if (c != '\n' && c != EOF) {
+                    if (c != '\n' && cc != EOF) {
                         *bufptr = c;
                         bufptr++;
                         continue;
@@ -785,7 +812,7 @@
                     goto fileend;
                     break;
             }
-        } while (c != EOF);
+        } while (cc != EOF);
 
 fileend:
         fclose(fin);
@@ -838,4 +865,4 @@
         pkg_free(redis_keys.s);
     }
     return -1;
-}
\ No newline at end of file
+}
