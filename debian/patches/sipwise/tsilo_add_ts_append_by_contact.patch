From: Sipwise Development Team <support@sipwise.com>
Date: Tue, 2 Nov 2021 11:14:23 +0100
Subject: tsilo_add_ts_append_by_contact

---
 src/modules/tsilo/ts_append.c | 116 ++++++++++++++++++
 src/modules/tsilo/ts_append.h |   2 +
 src/modules/tsilo/tsilo.c     | 269 +++++++++++++++++++++++++++++++++++++++++-
 3 files changed, 386 insertions(+), 1 deletion(-)

diff --git a/src/modules/tsilo/ts_append.c b/src/modules/tsilo/ts_append.c
index 7d95186..1847ac1 100644
--- a/src/modules/tsilo/ts_append.c
+++ b/src/modules/tsilo/ts_append.c
@@ -139,3 +139,119 @@ done:
 
 	return ret;
 }
+
+int ts_append_by_contact(struct sip_msg* msg, str *ruri, str *contact, char *table) {
+	ts_urecord_t* _r;
+	ts_transaction_t* ptr;
+
+	struct sip_uri p_uri;
+	struct sip_uri c_uri;
+	str *t_uri;
+
+	int res;
+	int appended;
+
+	/* parse R-URI */
+	if (use_domain) {
+		t_uri = ruri;
+	} else {
+		if (parse_uri(ruri->s, ruri->len, &p_uri) < 0) {
+			LM_ERR("tsilo: failed to parse uri %.*s\n", ruri->len, ruri->s);
+			return -1;
+		}
+		t_uri = &p_uri.user;
+	}
+
+	/* parse contact */
+	if (parse_uri(contact->s, contact->len, &c_uri) < 0) {
+		LM_ERR("tsilo: failed to parse contact %.*s\n", ruri->len, ruri->s);
+		return -1;
+	}
+
+	/* find urecord in TSILO cache */
+	lock_entry_by_ruri(t_uri);
+	res = get_ts_urecord(t_uri, &_r);
+
+	if (res != 0) {
+		LM_ERR("tsilo: failed to retrieve record for %.*s\n", t_uri->len, t_uri->s);
+		unlock_entry_by_ruri(t_uri);
+		return -1;
+	}
+
+	/* cycle through existing transactions */
+	ptr = _r->transactions;
+	while(ptr) {
+		LM_DBG("tsilo: transaction %u:%u found for %.*s, going to append branches\n",
+						ptr->tindex, ptr->tlabel, t_uri->len, t_uri->s);
+		/* append only if the desired contact has been found in locations */
+		appended = ts_append_by_contact_to(msg, ptr->tindex, ptr->tlabel, table, ruri, contact);
+		if (appended > 0)
+			update_stat(added_branches, appended);
+		ptr = ptr->next;
+	}
+
+	unlock_entry_by_ruri(t_uri);
+
+	return 1;
+}
+
+int ts_append_by_contact_to(struct sip_msg* msg, int tindex, int tlabel, char *table, str *uri, str *contact) {
+	struct cell     *t=0;
+	struct cell     *orig_t;	/* a pointer to an existing transaction or 0 if lookup fails*/
+	struct sip_msg *orig_msg;
+	int ret;
+	str stable;
+
+	LM_DBG("tsilo: trying to append based on contact <%.*s>\n", contact->len, contact->s);
+
+	/* lookup a transaction based on its identifier (hash_index:label) */
+	orig_t = _tmb.t_gett();
+	if(_tmb.t_lookup_ident(&t, tindex, tlabel) < 0)
+	{
+		LM_ERR("tsilo: transaction [%u:%u] not found\n", tindex, tlabel);
+		ret = -1;
+		goto done;
+	}
+
+	/* check if the dialog is still in the early stage */
+	if (t->flags & T_CANCELED) {
+		LM_DBG("tsilo: trasaction [%u:%u] was cancelled\n", tindex, tlabel);
+		ret = -2;
+		goto done;
+	}
+	if (t->uas.status >= 200) {
+		LM_DBG("tsilo: trasaction [%u:%u] sent out a final response already - %d\n",
+					tindex, tlabel, t->uas.status);
+		ret = -3;
+		goto done;
+	}
+
+	/* get original (very first) request of the transaction */
+	orig_msg = t->uas.request;
+	stable.s = table;
+	stable.len = strlen(stable.s);
+
+	if(uri==NULL || uri->s==NULL || uri->len<=0) {
+		ret = _regapi.lookup_to_dset(orig_msg, &stable, NULL);
+	} else {
+		ret = _regapi.lookup_to_dset(orig_msg, &stable, uri);
+	}
+
+	if(ret != 1) {
+		LM_ERR("tsilo: transaction %u:%u: error updating dset (%d)\n", tindex, tlabel, ret);
+		ret = -4;
+		goto done;
+	}
+
+	/* start the transaction only for the desired contact
+		contact must be of syntax: sip:<user>@<host>:<port> with no parameters list*/
+	ret = _tmb.t_append_branch_by_contact(contact);
+
+done:
+	/* unref the transaction which had been referred by t_lookup_ident() call.
+	 * Restore the original transaction (if any) */
+	if(t) _tmb.unref_cell(t);
+	_tmb.t_sett(orig_t, T_BR_UNDEFINED);
+
+	return ret;
+}
diff --git a/src/modules/tsilo/ts_append.h b/src/modules/tsilo/ts_append.h
index 56f9120..461f888 100644
--- a/src/modules/tsilo/ts_append.h
+++ b/src/modules/tsilo/ts_append.h
@@ -24,5 +24,7 @@
 
 int ts_append(struct sip_msg* msg, str *ruri, char *table);
 int ts_append_to(struct sip_msg* msg, int tindex, int tlabel, char *table, str *uri);
+int ts_append_by_contact(struct sip_msg* msg, str *ruri, str *contact, char *table);
+int ts_append_by_contact_to(struct sip_msg* msg, int tindex, int tlabel, char *table, str *uri, str *contact);
 
 #endif
diff --git a/src/modules/tsilo/tsilo.c b/src/modules/tsilo/tsilo.c
index 0c531ac..2eefb2f 100644
--- a/src/modules/tsilo/tsilo.c
+++ b/src/modules/tsilo/tsilo.c
@@ -34,6 +34,8 @@
 #include "../../core/rpc_lookup.h"
 #include "../../core/kemi.h"
 
+#include "../../core/parser/contact/parse_contact.h"
+
 #include "ts_hash.h"
 #include "ts_handlers.h"
 #include "ts_append.h"
@@ -61,7 +63,9 @@ static int w_ts_append_to2(struct sip_msg* msg, char *idx, char *lbl, char *d, c
 static int fixup_ts_append_to(void** param, int param_no);
 static int w_ts_append(struct sip_msg* _msg, char *_table, char *_ruri);
 static int fixup_ts_append(void** param, int param_no);
-
+static int w_ts_append_by_contact2(struct sip_msg* _msg, char *_table, char *_ruri);
+static int w_ts_append_by_contact3(struct sip_msg* _msg, char *_table, char *_ruri, char *_contact);
+static int fixup_ts_append_by_contact(void** param, int param_no);
 static int w_ts_store(struct sip_msg* msg, char *p1, char *p2);
 static int w_ts_store1(struct sip_msg* msg, char *_ruri, char *p2);
 
@@ -78,6 +82,10 @@ static cmd_export_t cmds[]={
 		fixup_ts_append_to, 0, REQUEST_ROUTE | FAILURE_ROUTE },
 	{"ts_append", (cmd_function)w_ts_append,  2,
 		fixup_ts_append, 0, REQUEST_ROUTE | FAILURE_ROUTE },
+	{"ts_append_by_contact", (cmd_function)w_ts_append_by_contact2,  2,	/* for two parameters */
+		fixup_ts_append_by_contact, 0, REQUEST_ROUTE | FAILURE_ROUTE },
+	{"ts_append_by_contact", (cmd_function)w_ts_append_by_contact3,  3,	/* for three parameters */
+		fixup_ts_append_by_contact, 0, REQUEST_ROUTE | FAILURE_ROUTE },
 	{"ts_store", (cmd_function)w_ts_store,  0,
 		0 , 0, REQUEST_ROUTE | FAILURE_ROUTE },
 	{"ts_store", (cmd_function)w_ts_store1,  1,
@@ -241,6 +249,23 @@ static int fixup_ts_append(void** param, int param_no)
 	return 0;
 }
 
+static int fixup_ts_append_by_contact(void** param, int param_no)
+{
+	if (param_no==1) {
+		if(strlen((char*)*param)<=1 && (*(char*)(*param)==0 || *(char*)(*param)=='0')) {
+			*param = (void*)0;
+			LM_ERR("empty table name\n");
+			return -1;
+		}
+	}
+
+	if (param_no==2 || param_no==3) {
+		return fixup_spve_null(param, 1);
+	}
+
+	return 0;
+}
+
 /**
  *
  */
@@ -357,6 +382,238 @@ static int ki_ts_append_to_uri(sip_msg_t* _msg, int tindex, int tlabel,
 			_table->s, _uri);
 }
 
+/**
+ *
+ */
+static int w_ts_append_by_contact2(struct sip_msg* _msg, char *_table, char *_ruri) {
+	str ruri = STR_NULL;
+	str ruri_fixed = STR_NULL;
+
+	str contact = STR_NULL;
+	str tmp_contact = STR_NULL;
+	struct sip_uri curi;
+
+	int rc;
+
+	/* parse R-URI */
+	if (fixup_get_svalue(_msg, (gparam_t*)_ruri, &ruri_fixed)!=0) {
+		LM_ERR("failed to convert r-uri parameter\n");
+		return -1;
+	}
+
+	if (_ruri==NULL || strlen(_ruri) <= 0 || ruri_fixed.len <= 0) {
+		LM_ERR("tsilo: invalid ruri parameter (empty or zero length).\n");
+		return -1;
+	}
+
+	if (pkg_str_dup(&ruri, &ruri_fixed) < 0) {
+		LM_ERR("failed to copy r-uri parameter\n");
+		return -1;
+	}
+
+	if (ts_check_uri(&ruri) < 0) {
+		LM_ERR("tsilo: failed to parse R-URI.\n");
+		return -1;
+	}
+
+	/* parse Contact header */
+	if ((!_msg->contact && parse_headers(_msg, HDR_CONTACT_F, 0) != 0)
+			|| !_msg->contact) {
+		LM_WARN("tsilo: missing contact header or the value is empty/malformed.\n");
+		return -1;
+	}
+	if (_msg->contact) {
+		if (parse_contact(_msg->contact) < 0) {
+			LM_WARN("tsilo: failed to parse Contact header.\n");
+			return -1;
+		}
+		if (parse_uri(
+						((struct contact_body*)_msg->contact->parsed)->contacts->uri.s,
+						((struct contact_body*)_msg->contact->parsed)->contacts->uri.len,
+						&curi) != 0 ) {
+			if (ts_check_uri(&_msg->contact->body) < 0) {	/* one more attempt */
+				LM_WARN("tsilo: failed to parse Contact header.\n");
+				return -1;
+			}
+		}
+
+		tmp_contact.len = ((struct contact_body*)_msg->contact->parsed)->contacts->uri.len;
+		tmp_contact.s = (char*)pkg_malloc(tmp_contact.len+1);
+		if (tmp_contact.s == NULL) {
+			PKG_MEM_ERROR;
+			return -1;
+		}
+		memcpy(tmp_contact.s, ((struct contact_body*)_msg->contact->parsed)->contacts->uri.s, tmp_contact.len);
+		tmp_contact.s[tmp_contact.len] = '\0';
+
+		if (pkg_str_dup(&contact, &tmp_contact) < 0) {
+			if (pkg_str_dup(&contact, &_msg->contact->body) < 0) { /* one more attempt */
+				LM_ERR("tsilo: problems when calling ts_append_contact(), cannot copy Contact parameter.\n");
+				return -1;
+			}
+		}
+	}
+
+	/* contact must be of syntax: sip:<user>@<host>:<port> with no parameters list */
+	rc = ts_append_by_contact(_msg, &ruri, &contact, _table);
+
+	/* free previously used memory */
+	pkg_free(ruri.s);
+	pkg_free(contact.s);
+	pkg_free(tmp_contact.s);
+
+	return rc;
+}
+
+/**
+ *
+ */
+static int ki_ts_append_by_contact(sip_msg_t* _msg, str *_table, str *_ruri) {
+	str ruri = STR_NULL;
+	str contact = STR_NULL;
+	str tmp_contact = STR_NULL;
+	struct sip_uri curi;
+	int rc;
+
+	/* parse R-URI */
+	if (ts_check_uri(_ruri) < 0)
+		return -1;
+	if (pkg_str_dup(&ruri, _ruri) < 0)
+		return -1;
+
+	/* parse Contact header */
+	if ((!_msg->contact && parse_headers(_msg, HDR_CONTACT_F, 0) != 0) || !_msg->contact)
+		return -1;
+
+	if (_msg->contact) {
+		if (parse_contact(_msg->contact) < 0)
+			return -1;
+		if (parse_uri(
+						((struct contact_body*)_msg->contact->parsed)->contacts->uri.s,
+						((struct contact_body*)_msg->contact->parsed)->contacts->uri.len,
+						&curi) != 0 ) {
+			if (ts_check_uri(&_msg->contact->body) < 0) /* one more attempt */
+				return -1;
+		}
+
+		tmp_contact.len = ((struct contact_body*)_msg->contact->parsed)->contacts->uri.len;
+		tmp_contact.s = (char*)pkg_malloc(tmp_contact.len+1);
+		if (tmp_contact.s == NULL) {
+			PKG_MEM_ERROR;
+			return -1;
+		}
+		memcpy(tmp_contact.s, ((struct contact_body*)_msg->contact->parsed)->contacts->uri.s, tmp_contact.len);
+		tmp_contact.s[tmp_contact.len] = '\0';
+
+		if (pkg_str_dup(&contact, &tmp_contact) < 0) {
+			if (pkg_str_dup(&contact, &_msg->contact->body) < 0) /* one more attempt */
+				return -1;
+		}
+	}
+
+	/* contact must be of syntax: sip:<user>@<host>:<port> with no parameters list */
+	rc = ts_append_by_contact(_msg, &ruri, &contact, _table->s);
+
+	pkg_free(ruri.s);
+	pkg_free(contact.s);
+	pkg_free(tmp_contact.s);
+
+	return rc;
+}
+
+/**
+ *
+ */
+static int w_ts_append_by_contact3(struct sip_msg* _msg, char *_table, char *_ruri, char *_contact) {
+	str ruri = STR_NULL;
+	str ruri_fixed = STR_NULL;
+
+	str contact = STR_NULL;
+	str contact_fixed = STR_NULL;
+
+	int rc;
+
+	/* parse R-URI */
+	if (fixup_get_svalue(_msg, (gparam_t*)_ruri, &ruri_fixed)!=0) {
+		LM_ERR("failed to convert r-uri parameter\n");
+		return -1;
+	}
+
+	if (_ruri==NULL || strlen(_ruri) <= 0 || ruri_fixed.len <= 0) {
+		LM_ERR("tsilo: invalid ruri parameter.\n");
+		return -1;
+	}
+
+	if (pkg_str_dup(&ruri, &ruri_fixed) < 0) {
+		LM_ERR("failed to copy r-uri parameter\n");
+		return -1;
+	}
+
+	if (ts_check_uri(&ruri) < 0) {
+		LM_ERR("tsilo: failed to parse R-URI.\n");
+		return -1;
+	}
+
+	/* parse Contact header */
+	if (fixup_get_svalue(_msg, (gparam_t*)_contact, &contact_fixed)!=0) {
+		LM_ERR("failed to convert contact parameter\n");
+		return -1;
+	}
+
+	if (_contact==NULL || strlen(_contact) <= 0 || contact_fixed.len <= 0) {
+		LM_ERR("tsilo: invalid contact parameter.\n");
+		return -1;
+	}
+
+	if (pkg_str_dup(&contact, &contact_fixed) < 0) {
+		LM_ERR("failed to copy r-uri parameter\n");
+		return -1;
+	}
+
+	if (ts_check_uri(&contact) < 0) {
+		LM_ERR("tsilo: failed to parse Contact parameter.\n");
+		return -1;
+	}
+
+	/* contact must be of syntax: sip:<user>@<host>:<port> with no parameters list */
+	rc = ts_append_by_contact(_msg, &ruri, &contact, _table);
+
+	pkg_free(ruri.s);
+	pkg_free(contact.s);
+
+	return rc;
+}
+
+/**
+ *
+ */
+static int ki_ts_append_by_contact_uri(sip_msg_t* _msg, str *_table, str *_ruri, str *_contact) {
+	str ruri = STR_NULL;
+	str contact = STR_NULL;
+
+	int rc;
+
+	/* parse R-URI */
+	if(ts_check_uri(_ruri) < 0)
+		return -1;
+	if (pkg_str_dup(&ruri, _ruri) < 0)
+		return -1;
+
+	/* parse Contact header */
+	if (ts_check_uri(_contact) < 0)
+		return -1;
+	if (pkg_str_dup(&contact, _contact) < 0)
+		return -1;
+
+	/* contact must be of syntax: sip:<user>@<host>:<port> with no parameters list */
+	rc = ts_append_by_contact(_msg, &ruri, &contact, _table->s);
+
+	pkg_free(ruri.s);
+	pkg_free(contact.s);
+
+	return rc;
+}
+
 /**
  *
  */
@@ -417,6 +674,16 @@ static sr_kemi_t sr_kemi_tsilo_exports[] = {
 		{ SR_KEMIP_INT, SR_KEMIP_INT, SR_KEMIP_STR,
 			SR_KEMIP_STR, SR_KEMIP_NONE, SR_KEMIP_NONE }
 	},
+	{ str_init("tsilo"), str_init("ts_append_by_contact"),
+		SR_KEMIP_INT, ki_ts_append_by_contact,
+		{ SR_KEMIP_STR, SR_KEMIP_STR, SR_KEMIP_NONE,
+			SR_KEMIP_NONE, SR_KEMIP_NONE, SR_KEMIP_NONE }
+	},
+	{ str_init("tsilo"), str_init("ts_append_by_contact_uri"),
+		SR_KEMIP_INT, ki_ts_append_by_contact_uri,
+		{ SR_KEMIP_STR, SR_KEMIP_STR, SR_KEMIP_STR,
+			SR_KEMIP_NONE, SR_KEMIP_NONE, SR_KEMIP_NONE }
+	},
 
 	{ {0, 0}, {0, 0}, 0, NULL, { 0, 0, 0, 0, 0, 0 } }
 };
