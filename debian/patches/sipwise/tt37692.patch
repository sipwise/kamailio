--- a/src/modules/permissions/trusted.c
+++ b/src/modules/permissions/trusted.c
@@ -354,16 +354,18 @@ static inline int match_proto(const char
 
 	return 0;
 }
-
 /*
  * Matches from uri against patterns returned from database.  Returns number
  * of matches or -1 if none of the patterns match.
  */
-static int match_res(struct sip_msg* msg, int proto, db1_res_t* _r)
+static int match_res(struct sip_msg* msg, int proto, db1_res_t* _r, str uri)
 {
 	int i, tag_avp_type;
-	str uri, ruri;
+	str ruri;
 	char uri_string[MAX_URI_SIZE+1];
+      memcpy(uri_string, uri.s, uri.len);
+	uri_string[uri.len] = (char)0;
+
 	char ruri_string[MAX_URI_SIZE+1];
 	db_row_t* row;
 	db_val_t* val;
@@ -372,14 +374,6 @@ static int match_res(struct sip_msg* msg
 	int count = 0;
 
 	if (IS_SIP(msg)) {
-		if (parse_from_header(msg) < 0) return -1;
-		uri = get_from(msg)->uri;
-		if (uri.len > MAX_URI_SIZE) {
-			LM_ERR("message has From URI too large\n");
-			return -1;
-		}
-		memcpy(uri_string, uri.s, uri.len);
-		uri_string[uri.len] = (char)0;
 		ruri = msg->first_line.u.request.uri;
 		if (ruri.len > MAX_URI_SIZE) {
 			LM_ERR("message has Request URI too large\n");
@@ -450,12 +444,11 @@ static int match_res(struct sip_msg* msg
 		return count;
 }
 
-
 /*
  * Checks based on given source IP address and protocol, and From URI
  * of request if request can be trusted without authentication.
  */
-int allow_trusted(struct sip_msg* msg, char *src_ip, int proto)
+int allow_trusted(struct sip_msg* msg, char *src_ip, int proto, str uri)
 {
 	int result;
 	db1_res_t* res = NULL;
@@ -498,7 +491,7 @@ int allow_trusted(struct sip_msg* msg, c
 			return -1;
 		}
 
-		result = match_res(msg, proto, res);
+		result = match_res(msg, proto, res, uri);
 		perm_dbf.free_result(db_handle, res);
 		return result;
 	} else {
@@ -513,16 +506,26 @@ int allow_trusted(struct sip_msg* msg, c
  */
 int allow_trusted_0(struct sip_msg* _msg, char* str1, char* str2)
 {
+      str uri;
+
+      if (IS_SIP(msg)) {
+            if (parse_from_header(msg) < 0) return -1;
+            uri = get_from(msg)->uri;
+            if (uri.len > MAX_URI_SIZE) {
+                  LM_ERR("message has From URI too large\n");
+                  return -1;
+            }
+      }
+
 	return allow_trusted(_msg, ip_addr2a(&(_msg->rcv.src_ip)),
-			_msg->rcv.proto);
+			_msg->rcv.proto, uri);
 }
 
-
 /*
  * Checks based on source address and protocol given in pvar arguments and
- * and requests's From URI, if request can be trusted without authentication.
+ * provided uri, if request can be trusted without authentication.
  */
-int allow_trusted_2(struct sip_msg* _msg, char* _src_ip_sp, char* _proto_sp)
+int allow_trusted_1(struct sip_msg* _msg, char* _src_ip_sp, char* _proto_sp, str uri)
 {
 	str src_ip, proto;
 	int proto_int;
@@ -582,6 +585,38 @@ error:
 	return -1;
 }
 
+/*
+ * Checks based on source address and protocol given in pvar arguments and
+ * and requests's From URI, if request can be trusted without authentication.
+ */
+int allow_trusted_2(struct sip_msg* _msg, char* _src_ip_sp, char* _proto_sp)
+{
+      str uri;
+
+      if (IS_SIP(msg)) {
+            if (parse_from_header(msg) < 0) return -1;
+            uri = get_from(msg)->uri;
+            if (uri.len > MAX_URI_SIZE) {
+                  LM_ERR("message has From URI too large\n");
+                  return -1;
+            }
+      }
+
+      return allow_trusted_1(msg, _src_ip_sp, _proto_sp, uri);
+}
+
+/*
+ * Checks based on source address and protocol given in pvar arguments and
+ * and requests's From URI, if request can be trusted without authentication.
+ */
+int allow_trusted_3(struct sip_msg* _msg, char* _src_ip_sp, char* _proto_sp, char *value)
+{
+      str uri;
+      memcpy(uri.s, value, strlen(value));
+      uri.len = strlen(uri.s);
+
+      return allow_trusted_1(msg, _src_ip_sp, _proto_sp, uri);
+}
 
 int reload_trusted_table_cmd(void)
 {
