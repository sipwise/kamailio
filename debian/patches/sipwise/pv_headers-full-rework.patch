From: Victor Seva <vseva@sipwise.com>
Date: Wed, 29 Jan 2020 17:05:47 +0100
Subject: pv_headers: full rework
---
 src/Makefile.groups                     |   2 +-
 src/modules/pv_headers_new/Makefile     |  12 +
 src/modules/pv_headers_new/pv_headers.c | 276 ++++++++++++++++++++++
 src/modules/pv_headers_new/pv_headers.h |  55 +++++
 src/modules/pv_headers_new/pvh_func.c   | 140 +++++++++++
 src/modules/pv_headers_new/pvh_func.h   |  34 +++
 src/modules/pv_headers_new/pvh_hash.c   | 134 +++++++++++
 src/modules/pv_headers_new/pvh_hash.h   |  41 ++++
 src/modules/pv_headers_new/pvh_str.c    | 104 +++++++++
 src/modules/pv_headers_new/pvh_str.h    |  39 ++++
 src/modules/pv_headers_new/pvh_xavp.c   | 397 ++++++++++++++++++++++++++++++++
 src/modules/pv_headers_new/pvh_xavp.h   |  41 ++++
 12 files changed, 1274 insertions(+), 1 deletion(-)
 create mode 100644 src/modules/pv_headers_new/Makefile
 create mode 100644 src/modules/pv_headers_new/pv_headers.c
 create mode 100644 src/modules/pv_headers_new/pv_headers.h
 create mode 100644 src/modules/pv_headers_new/pvh_func.c
 create mode 100644 src/modules/pv_headers_new/pvh_func.h
 create mode 100644 src/modules/pv_headers_new/pvh_hash.c
 create mode 100644 src/modules/pv_headers_new/pvh_hash.h
 create mode 100644 src/modules/pv_headers_new/pvh_str.c
 create mode 100644 src/modules/pv_headers_new/pvh_str.h
 create mode 100644 src/modules/pv_headers_new/pvh_xavp.c
 create mode 100644 src/modules/pv_headers_new/pvh_xavp.h

diff --git a/src/Makefile.groups b/src/Makefile.groups
index 53d8cc6..745a127 100644
--- a/src/Makefile.groups
+++ b/src/Makefile.groups
@@ -11,7 +11,7 @@
 # - basic used modules, with no extra dependency (widespread usage)
 mod_list_basic=async auth benchmark blst cfg_rpc cfgutils corex counters \
 				   ctl debugger diversion enum exec ipops kex mangler maxfwd \
-				   mediaproxy mqueue \
+				   mediaproxy mqueue pv_headers_new \
 				   nat_traversal nathelper path pike pv ratelimit rr rtimer \
 				   rtpproxy sanity sdpops siputils sl statistics textops \
 				   textopsx tm tmx topoh xlog rtpengine stun sipt tcpops \
diff --git a/src/modules/pv_headers_new/Makefile b/src/modules/pv_headers_new/Makefile
new file mode 100644
index 0000000..eb00413
--- /dev/null
+++ b/src/modules/pv_headers_new/Makefile
@@ -0,0 +1,12 @@
+#
+# pv_headers module makefile
+#
+#
+# WARNING: do not run this directly, it should be run by the master Makefile
+
+include ../../Makefile.defs
+auto_gen=
+NAME=pv_headers_new.so
+LIBS=
+
+include ../../Makefile.modules
diff --git a/src/modules/pv_headers_new/pv_headers.c b/src/modules/pv_headers_new/pv_headers.c
new file mode 100644
index 0000000..049b8f3
--- /dev/null
+++ b/src/modules/pv_headers_new/pv_headers.c
@@ -0,0 +1,276 @@
+/*
+ * pv_headers
+ *
+ * Copyright (C)
+ * 2020 Victor Seva <vseva@sipwise.com>
+ * 2018 Kirill Solomko <ksolomko@sipwise.com>
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include "../../core/sr_module.h"
+#include "../../core/script_cb.h"
+#include "../../modules/tm/tm_load.h"
+
+#include "pv_headers.h"
+#include "pvh_func.h"
+#include "pvh_hash.h"
+
+MODULE_VERSION
+
+#define MODULE_NAME "pv_headers_new"
+#define XAVP_NAME "headers_new"
+
+uac_api_t uac;
+static tm_api_t tmb;
+
+str xavp_name = str_init(XAVP_NAME);
+str xavp_helper_xname = str_init("modparam_pv_headers");
+str xavp_parsed_xname = str_init("parsed_pv_headers");
+unsigned int header_name_size = 255;
+unsigned int header_value_size = 1024;
+int FL_PV_HDRS_COLLECTED = 27;
+int FL_PV_HDRS_APPLIED = 28;
+static str skip_headers_param =
+		str_init("Record-Route,Via,Route,Content-Length,Max-Forwards,CSeq");
+static str split_headers_param = STR_NULL;
+static str single_headers_param = str_init("");
+static int auto_msg_param = 1;
+
+str _hdr_from = {"From", 4};
+str _hdr_to = {"To", 2};
+int _branch = T_BR_UNDEFINED;
+
+static void mod_destroy(void);
+static int mod_init(void);
+
+static void handle_tm_t(tm_cell_t *t, int type, struct tmcb_params *params);
+static int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb);
+static int handle_msg_reply_cb(
+		struct sip_msg *msg, unsigned int flags, void *cb);
+
+/* clang-format off */
+static cmd_export_t cmds[] = {
+	{0, 0, 0, 0, 0, 0}
+};
+
+static pv_export_t mod_pvs[] = {
+	{{0, 0}, 0, 0, 0, 0, 0, 0, 0}
+};
+
+static param_export_t params[] = {
+	{"xavp_name", PARAM_STR, &xavp_name},
+	{"header_value_size", PARAM_INT, &header_value_size},
+	{"header_collect_flag", PARAM_INT, &FL_PV_HDRS_COLLECTED},
+	{"header_apply_flag", PARAM_INT, &FL_PV_HDRS_APPLIED},
+	{"skip_headers", PARAM_STR, &skip_headers_param},
+	{"split_headers", PARAM_STR, &split_headers_param},
+	{"auto_msg", PARAM_INT, &auto_msg_param},
+	{0, 0, 0}
+};
+
+struct module_exports exports = {
+	MODULE_NAME,	 /* module name */
+	DEFAULT_DLFLAGS, /* dlopen flags */
+	cmds,			 /* exported functions */
+	params,			 /* exported parameters */
+	0,				 /* RPC method exports */
+	mod_pvs,		 /* exported pseudo-variables */
+	0,				 /* response handling function */
+	mod_init,		 /* module initialization function */
+	0,				 /* per-child init function */
+	mod_destroy		 /* module destroy function */
+};
+/* clang-format on */
+
+int mod_init(void)
+{
+	LM_INFO("%s module init...\n", MODULE_NAME);
+
+	if(load_uac_api(&uac) < 0) {
+		LM_NOTICE("could not bind to the 'uac' module, From/To headers will "
+				  "not be modifed\n");
+	}
+
+	if(load_tm_api(&tmb) < 0) {
+		LM_NOTICE("could not bind to the 'tm' module, automatic headers "
+				  "collect/apply is disabled\n");
+		auto_msg_param = 0;
+	}
+	if(auto_msg_param) {
+		if(register_script_cb(handle_msg_cb, PRE_SCRIPT_CB | REQUEST_CB, 0)
+				< 0) {
+			LM_ERR("cannot register PRE_SCRIPT_CB REQUEST_CB callbacks\n");
+			return -1;
+		}
+		if(register_script_cb(
+				   handle_msg_reply_cb, PRE_SCRIPT_CB | ONREPLY_CB, 0)
+				< 0) {
+			LM_ERR("cannot register PRE_SCRIPT_CB ONREPLY_CB callbacks\n");
+			return -1;
+		}
+	}
+
+	pvh_str_hash_init(&skip_headers, &skip_headers_param, "skip_headers");
+	pvh_str_hash_init(&split_headers, &split_headers_param, "split_headers");
+	pvh_str_hash_init(&single_headers, &single_headers_param, "single_headers");
+
+	return 0;
+}
+
+void mod_destroy(void)
+{
+	LM_INFO("%s module unload...\n", MODULE_NAME);
+}
+
+/* just for debug */
+static inline char *tm_type_to_string(int type)
+{
+	switch(type) {
+		case TMCB_REQUEST_IN:
+			return "TMCB_REQUEST_IN";
+		case TMCB_RESPONSE_IN:
+			return "TMCB_RESPONSE_IN";
+		case TMCB_E2EACK_IN:
+			return "TMCB_E2EACK_IN";
+		case TMCB_REQUEST_PENDING:
+			return "TMCB_REQUEST_PENDING";
+		case TMCB_REQUEST_FWDED:
+			return "TMCB_REQUEST_FWDED";
+		case TMCB_RESPONSE_FWDED:
+			return "TMCB_RESPONSE_FWDED";
+		case TMCB_ON_FAILURE_RO:
+			return "TMCB_ON_FAILURE_RO";
+		case TMCB_ON_FAILURE:
+			return "TMCB_ON_FAILURE";
+		case TMCB_REQUEST_OUT:
+			return "TMCB_REQUEST_OUT";
+		case TMCB_RESPONSE_OUT:
+			return "TMCB_RESPONSE_OUT";
+		case TMCB_LOCAL_COMPLETED:
+			return "TMCB_LOCAL_COMPLETED";
+		case TMCB_LOCAL_RESPONSE_OUT:
+			return "TMCB_LOCAL_RESPONSE_OUT";
+		case TMCB_ACK_NEG_IN:
+			return "TMCB_ACK_NEG_IN";
+		case TMCB_REQ_RETR_IN:
+			return "TMCB_REQ_RETR_IN";
+		case TMCB_LOCAL_RESPONSE_IN:
+			return "TMCB_LOCAL_RESPONSE_IN";
+		case TMCB_LOCAL_REQUEST_IN:
+			return "TMCB_LOCAL_REQUEST_IN";
+		case TMCB_DLG:
+			return "TMCB_DLG";
+		case TMCB_DESTROY:
+			return "TMCB_DESTROY";
+		case TMCB_E2ECANCEL_IN:
+			return "TMCB_E2ECANCEL_IN";
+		case TMCB_E2EACK_RETR_IN:
+			return "TMCB_E2EACK_RETR_IN";
+		case TMCB_RESPONSE_READY:
+			return "TMCB_RESPONSE_READY";
+		case TMCB_DONT_ACK:
+			return "TMCB_DONT_ACK";
+		case TMCB_REQUEST_SENT:
+			return "TMCB_REQUEST_SENT";
+		case TMCB_RESPONSE_SENT:
+			return "TMCB_RESPONSE_SENT";
+		case TMCB_ON_BRANCH_FAILURE:
+			return "TMCB_ON_BRANCH_FAILURE";
+		case TMCB_ON_BRANCH_FAILURE_RO:
+			return "TMCB_ON_BRANCH_FAILURE_RO";
+		case TMCB_MAX:
+			return "TMCB_MAX";
+	}
+
+	return "UNKNOWN";
+}
+
+void handle_tm_t(tm_cell_t *t, int type, struct tmcb_params *params)
+{
+	struct sip_msg *msg = NULL;
+
+	LM_DBG("T:%p params->branch: %d type:%s\n", t, params->branch,
+			tm_type_to_string(type));
+
+	_branch = params->branch;
+
+	if(type & TMCB_REQUEST_FWDED) {
+		msg = params->req;
+	} else if(type & (TMCB_ON_BRANCH_FAILURE | TMCB_RESPONSE_FWDED)) {
+		msg = params->rpl;
+	} else {
+		LM_ERR("unknown callback: %d\n", type);
+		return;
+	}
+
+	LM_DBG("msg:%p apply changes??\n", msg);
+	return;
+}
+
+static int msg_cbs =
+		TMCB_REQUEST_FWDED | TMCB_RESPONSE_FWDED | TMCB_ON_BRANCH_FAILURE;
+
+int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb)
+{
+	if(pvh_parse_msg(msg) != 0)
+		return 1;
+	LM_DBG("msg:%p flags:%d\n", msg, flags);
+
+	if(tmb.register_tmcb(msg, 0, msg_cbs, handle_tm_t, 0, 0) <= 0) {
+		LM_ERR("cannot register TM callbacks\n");
+		return -1;
+	}
+
+	_branch = 0;
+	pvh_collect_headers(msg);
+	return 1;
+}
+
+int handle_msg_reply_cb(struct sip_msg *msg, unsigned int flags, void *cb)
+{
+	tm_cell_t *t = NULL;
+	sr_xavp_t **backup_xavps = NULL;
+
+	if(pvh_parse_msg(msg) != 0)
+		return 1;
+	LM_DBG("msg:%p flags:%d\n", msg, flags);
+
+	if(tmb.t_check(msg, &_branch) == -1) {
+		LM_ERR("failed find UAC branch\n");
+	} else {
+		t = tmb.t_gett();
+		if(t == NULL || t == T_UNDEFINED) {
+			LM_DBG("cannot lookup the transaction\n");
+		} else {
+			LM_DBG("T:%p branch:%d\n", t, _branch);
+			backup_xavps = xavp_set_list(&t->xavps_list);
+		}
+	}
+
+	pvh_collect_headers(msg);
+
+	if(t) {
+		tmb.unref_cell(t);
+		LM_DBG("T:%p unref\n", t);
+	}
+	tmb.t_sett(T_UNDEFINED, T_BR_UNDEFINED);
+	LM_DBG("reset tm\n");
+
+	return 1;
+}
diff --git a/src/modules/pv_headers_new/pv_headers.h b/src/modules/pv_headers_new/pv_headers.h
new file mode 100644
index 0000000..1285c54
--- /dev/null
+++ b/src/modules/pv_headers_new/pv_headers.h
@@ -0,0 +1,55 @@
+/*
+ * pv_headers
+ *
+ * Copyright (C)
+ * 2020 Victor Seva <vseva@sipwise.com>
+ * 2018 Kirill Solomko <ksolomko@sipwise.com>
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef PV_HEADERS_H
+#define PV_HEADERS_H
+
+#include "../../core/parser/parse_addr_spec.h"
+#include "../../modules/uac/api.h"
+
+typedef struct _xavp_c_data
+{
+	struct to_body to_b;
+	struct to_param *to_params;
+	str value;
+} xavp_c_data_t;
+
+extern uac_api_t uac;
+
+extern str xavp_name;
+extern str xavp_parsed_xname;
+extern str xavp_helper_xname;
+
+extern unsigned int header_name_size;
+extern unsigned int header_value_size;
+
+extern str _hdr_from;
+extern str _hdr_to;
+extern int _branch;
+
+extern int FL_PV_HDRS_COLLECTED;
+extern int FL_PV_HDRS_APPLIED;
+
+#endif /* PV_HEADERS_H */
diff --git a/src/modules/pv_headers_new/pvh_func.c b/src/modules/pv_headers_new/pvh_func.c
new file mode 100644
index 0000000..7c4b7b0
--- /dev/null
+++ b/src/modules/pv_headers_new/pvh_func.c
@@ -0,0 +1,140 @@
+/*
+ * pv_headers
+ *
+ * Copyright (C)
+ * 2020 Victor Seva <vseva@sipwise.com>
+ * 2018 Kirill Solomko <ksolomko@sipwise.com>
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include "../../core/dset.h"
+
+#include "pv_headers.h"
+#include "pvh_func.h"
+#include "pvh_xavp.h"
+#include "pvh_str.h"
+#include "pvh_hash.h"
+
+static str xavp_helper_name = str_init("xavp_name");
+
+int pvh_parse_msg(sip_msg_t *msg)
+{
+	if(msg->first_line.type == SIP_REQUEST) {
+		if(!IS_SIP(msg)) {
+			LM_DBG("non SIP request message\n");
+			return 1;
+		}
+	} else if(msg->first_line.type == SIP_REPLY) {
+		if(!IS_SIP_REPLY(msg)) {
+			LM_DBG("non SIP reply message\n");
+			return 1;
+		}
+	} else {
+		LM_DBG("non SIP message\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+int pvh_collect_headers(struct sip_msg *msg)
+{
+	struct hdr_field *hf = NULL;
+	str name = STR_NULL;
+	str val = STR_NULL;
+	char hvals[header_name_size][header_value_size];
+	int idx = 0, d_size = 0;
+	str val_part = STR_NULL;
+
+	if(msg->first_line.type == SIP_REPLY) {
+		if(isflagset(msg, FL_PV_HDRS_COLLECTED) == 1) {
+			LM_ERR("headers are already collected\n");
+			return -1;
+		}
+		if(pvh_reply_append() < 0) {
+			return -1;
+		}
+	} else {
+		if(isbflagset(_branch, FL_PV_HDRS_COLLECTED) == 1) {
+			LM_ERR("headers are already collected\n");
+			return -1;
+		}
+	}
+
+	if(parse_headers(msg, HDR_EOH_F, 0) < 0) {
+		LM_ERR("error parsing headers\n");
+		return -1;
+	}
+
+	for(hf = msg->headers; hf; hf = hf->next) {
+		LM_DBG("collect header[%.*s]: %.*s\n", hf->name.len, hf->name.s,
+				hf->body.len, hf->body.s);
+
+		switch(hf->type) {
+			case HDR_FROM_T:
+				name.len = _hdr_from.len;
+				name.s = _hdr_from.s;
+				LM_DBG("force [From] as key\n");
+				break;
+			case HDR_TO_T:
+				name.len = _hdr_to.len;
+				name.s = _hdr_to.s;
+				LM_DBG("force [To] as key\n");
+				break;
+			default:
+				name.len = hf->name.len;
+				name.s = hf->name.s;
+		}
+		val.len = hf->body.len;
+		val.s = hf->body.s;
+
+		if(strchr(val.s, ',') != NULL
+				&& str_hash_get(&split_headers, name.s, name.len)) {
+
+			if(pvh_split_values(&val, hvals, &d_size, 1) < 0) {
+				LM_ERR("could not parse %.*s header comma separated "
+					   "value",
+						name.len, name.s);
+				return -1;
+			}
+
+			for(idx = 0; idx < d_size; idx++) {
+				val_part.s = hvals[idx];
+				val_part.len = strlen(hvals[idx]);
+				if(pvh_set_xavp(msg, &xavp_name, &name, &val_part, SR_XTYPE_STR,
+						   0, 1)
+						< 0)
+					return -1;
+			}
+			continue;
+		}
+		if(pvh_set_xavp(msg, &xavp_name, &name, &val, SR_XTYPE_STR, 0, 1) < 0)
+			return -1;
+	}
+
+	if(pvh_set_xavp(msg, &xavp_helper_xname, &xavp_helper_name, &xavp_name,
+			   SR_XTYPE_STR, 0, 0)
+			< 0)
+		return -1;
+
+	msg->first_line.type == SIP_REPLY ? setflag(msg, FL_PV_HDRS_COLLECTED)
+									  : setbflag(_branch, FL_PV_HDRS_COLLECTED);
+
+	return 1;
+}
diff --git a/src/modules/pv_headers_new/pvh_func.h b/src/modules/pv_headers_new/pvh_func.h
new file mode 100644
index 0000000..ebe1fe6
--- /dev/null
+++ b/src/modules/pv_headers_new/pvh_func.h
@@ -0,0 +1,34 @@
+/*
+ * pv_headers
+ *
+ * Copyright (C)
+ * 2020 Victor Seva <vseva@sipwise.com>
+ * 2018 Kirill Solomko <ksolomko@sipwise.com>
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef PV_FUNC_H
+#define PV_FUNC_H
+
+#include "../../core/parser/msg_parser.h"
+
+int pvh_parse_msg(sip_msg_t *msg);
+int pvh_collect_headers(struct sip_msg *msg);
+
+#endif /* PV_FUNC_H */
diff --git a/src/modules/pv_headers_new/pvh_hash.c b/src/modules/pv_headers_new/pvh_hash.c
new file mode 100644
index 0000000..6c99c43
--- /dev/null
+++ b/src/modules/pv_headers_new/pvh_hash.c
@@ -0,0 +1,134 @@
+/*
+ * pv_headers
+ *
+ * Copyright (C)
+ * 2020 Victor Seva <vseva@sipwise.com>
+ * 2018 Kirill Solomko <ksolomko@sipwise.com>
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include "pv_headers.h"
+#include "pvh_hash.h"
+#include "pvh_str.h"
+
+struct str_hash_table skip_headers;
+struct str_hash_table split_headers;
+struct str_hash_table single_headers;
+
+int pvh_str_hash_init(struct str_hash_table *ht, str *keys, char *desc)
+{
+	char split[header_name_size][header_value_size];
+	int idx = 0, d_size = 0;
+	str val = STR_NULL;
+
+	if(pvh_split_values(keys, split, &d_size, 0) < 0) {
+		LM_ERR("could not parse %s param\n", desc);
+		return -1;
+	}
+
+	if(str_hash_alloc(ht, d_size + 1) < 0) {
+		PKG_MEM_ERROR;
+		return -1;
+	}
+	str_hash_init(ht);
+
+	for(idx = 0; idx < d_size; idx++) {
+		val.s = split[idx];
+		val.len = strlen(split[idx]);
+		if(pvh_str_hash_add_key(ht, &val) < 0) {
+			LM_ERR("cannot add a hash key=>%s", desc);
+			return -1;
+		}
+	}
+
+	return 1;
+}
+
+int pvh_str_hash_add_key(struct str_hash_table *ht, str *key)
+{
+	struct str_hash_entry *e = NULL;
+	int e_size;
+
+	if(ht->table == NULL || key == NULL || key->len == 0)
+		return -1;
+
+	e_size = sizeof(struct str_hash_entry) + sizeof(char) * key->len;
+	e = pkg_malloc(e_size);
+	if(e == NULL) {
+		PKG_MEM_ERROR;
+		return -1;
+	}
+	memset(e, 0, e_size);
+
+	if(pvh_str_new(&e->key, key->len + 1) < 0)
+		goto err;
+	pvh_str_copy(&e->key, key, key->len + 1);
+
+	str_hash_add(ht, e);
+	return 1;
+
+err:
+	pvh_str_free(&e->key);
+	return -1;
+}
+
+int pvh_str_hash_free(struct str_hash_table *ht)
+{
+	struct str_hash_entry *e = NULL;
+	struct str_hash_entry *bak = NULL;
+	int r;
+
+	if(ht == NULL)
+		return -1;
+
+	if(ht->table) {
+		for(r = 0; r < ht->size; r++) {
+			clist_foreach_safe(&ht->table[r], e, bak, next)
+			{
+				pvh_str_free(&e->key);
+				pkg_free(e);
+			}
+		}
+		pkg_free(ht->table);
+	}
+
+	return 1;
+}
+
+int pvh_skip_header(str *hname)
+{
+	if(hname == NULL)
+		return 0;
+
+	if(str_hash_get(&skip_headers, hname->s, hname->len))
+		return 1;
+
+	return 0;
+}
+
+int pvh_single_header(str *hname)
+{
+	if(hname == NULL)
+		return 0;
+
+	if(str_hash_get(&single_headers, hname->s, hname->len))
+		return 1;
+
+	return 0;
+}
diff --git a/src/modules/pv_headers_new/pvh_hash.h b/src/modules/pv_headers_new/pvh_hash.h
new file mode 100644
index 0000000..d7e25f8
--- /dev/null
+++ b/src/modules/pv_headers_new/pvh_hash.h
@@ -0,0 +1,41 @@
+/*
+ * pv_headers
+ *
+ * Copyright (C)
+ * 2020 Victor Seva <vseva@sipwise.com>
+ * 2018 Kirill Solomko <ksolomko@sipwise.com>
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef PVH_HASH_H
+#define PVH_HASH_H
+
+#include "../../core/str_hash.h"
+
+extern struct str_hash_table skip_headers;
+extern struct str_hash_table split_headers;
+extern struct str_hash_table single_headers;
+
+int pvh_str_hash_init(struct str_hash_table *ht, str *keys, char *desc);
+int pvh_str_hash_add_key(struct str_hash_table *ht, str *key);
+int pvh_str_hash_free(struct str_hash_table *ht);
+int pvh_skip_header(str *hname);
+int pvh_single_header(str *hname);
+
+#endif /* PVH_HASH_H */
diff --git a/src/modules/pv_headers_new/pvh_str.c b/src/modules/pv_headers_new/pvh_str.c
new file mode 100644
index 0000000..c429d99
--- /dev/null
+++ b/src/modules/pv_headers_new/pvh_str.c
@@ -0,0 +1,104 @@
+/*
+ * pv_headers
+ *
+ * Copyright (C)
+ * 2020 Victor Seva <vseva@sipwise.com>
+ * 2018 Kirill Solomko <ksolomko@sipwise.com>
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include "pvh_str.h"
+
+int pvh_str_new(str *s, int size)
+{
+	s->s = (char *)pkg_malloc(size);
+	if(s->s == NULL) {
+		PKG_MEM_ERROR;
+		return -1;
+	}
+	memset(s->s, 0, size);
+	s->len = 0;
+
+	return 1;
+}
+
+int pvh_str_free(str *s)
+{
+	if(s->s)
+		pkg_free(s->s);
+	s->s = NULL;
+	return 1;
+}
+
+int pvh_str_copy(str *dst, str *src, unsigned int max_size)
+{
+	unsigned int src_len = src->len + 1 >= max_size ? max_size - 1 : src->len;
+
+	if(src == NULL || dst == NULL || src->len <= 0)
+		return -1;
+
+	memset(dst->s, 0, dst->len);
+	memcpy(dst->s, src->s, src_len);
+	dst->s[src_len] = '\0';
+	dst->len = src_len;
+
+	return 1;
+}
+
+int pvh_split_values(
+		str *s, char d[][header_value_size], int *d_size, int keep_spaces)
+{
+	char p;
+	int idx = 0, c_idx = 0;
+
+	*d_size = -1;
+
+	if(s == NULL || s->len == 0 || d == NULL) {
+		*d_size = 0;
+		return 1;
+	}
+
+	while(idx < s->len) {
+		strncpy(&p, s->s + idx++, 1);
+		if(keep_spaces == 0 && strncmp(&p, " ", 1) == 0)
+			continue;
+		if(strncmp(&p, ",", 1) == 0) {
+			if(c_idx == 0)
+				continue;
+			if(c_idx + 1 < header_value_size)
+				c_idx++;
+			d[*d_size][c_idx] = '\0';
+			c_idx = 0;
+			continue;
+		}
+		if(c_idx == 0)
+			(*d_size)++;
+		strncpy(&d[*d_size][c_idx++], &p, 1);
+	}
+
+	if(c_idx > 0) {
+		if(c_idx >= header_value_size)
+			c_idx--;
+		d[*d_size][c_idx] = '\0';
+	}
+
+	(*d_size)++;
+
+	return 1;
+}
\ No newline at end of file
diff --git a/src/modules/pv_headers_new/pvh_str.h b/src/modules/pv_headers_new/pvh_str.h
new file mode 100644
index 0000000..3620471
--- /dev/null
+++ b/src/modules/pv_headers_new/pvh_str.h
@@ -0,0 +1,39 @@
+/*
+ * pv_headers
+ *
+ * Copyright (C)
+ * 2020 Victor Seva <vseva@sipwise.com>
+ * 2018 Kirill Solomko <ksolomko@sipwise.com>
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#ifndef PV_STR_H
+#define PV_STR_H
+
+#include "../../core/str.h"
+
+#include "pv_headers.h"
+
+int pvh_str_new(str *s, int size);
+int pvh_str_free(str *s);
+int pvh_str_copy(str *dst, str *src, unsigned int max_size);
+int pvh_split_values(
+		str *s, char d[][header_value_size], int *d_size, int keep_spaces);
+
+#endif /* PV_STR_H */
\ No newline at end of file
diff --git a/src/modules/pv_headers_new/pvh_xavp.c b/src/modules/pv_headers_new/pvh_xavp.c
new file mode 100644
index 0000000..64a515d
--- /dev/null
+++ b/src/modules/pv_headers_new/pvh_xavp.c
@@ -0,0 +1,397 @@
+/*
+ * pv_headers
+ *
+ * Copyright (C)
+ * 2020 Victor Seva <vseva@sipwise.com>
+ * 2018 Kirill Solomko <ksolomko@sipwise.com>
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+
+#include "pvh_xavp.h"
+#include "pvh_str.h"
+#include "pvh_hash.h"
+
+static str reply_counter = str_init("reply_counter");
+
+/**
+ * We keep a $xavp(xavp_helper_xname=>reply_counter) with the number of replies
+ * so we will use $xavp(xavp_name.r.<id>) on reply_route
+ */
+int pvh_reply_init(int value)
+{
+	sr_xavp_t *xavp = NULL;
+	sr_xval_t xval;
+
+	xavp = xavp_get_child_with_ival(&xavp_helper_xname, &reply_counter);
+	if(xavp) {
+		LM_DBG("%.*s=>%.*s found: %d\n", xavp_helper_xname.len,
+				xavp_helper_xname.s, reply_counter.len, reply_counter.s,
+				xavp->val.v.i);
+		return 1;
+	}
+
+	memset(&xval, 0, sizeof(sr_xval_t));
+	xval.type = SR_XTYPE_INT;
+	xval.v.i = value;
+
+	xavp = xavp_get(&xavp_helper_xname, NULL);
+	if(xavp == NULL) {
+		if(xavp_add_xavp_value(&xavp_helper_xname, &reply_counter, &xval, NULL)
+				== NULL) {
+			LM_ERR("can't create xavp:%.*s\n", xavp_helper_xname.len,
+					xavp_helper_xname.s);
+			return -1;
+		}
+		LM_DBG("xavp_name:%.*s created\n", xavp_helper_xname.len,
+				xavp_helper_xname.s);
+	} else {
+		if(xavp_set_value(&reply_counter, 0, &xval, &xavp->val.v.xavp)
+				== NULL) {
+			LM_ERR("can't set reply_counter value\n");
+			return -1;
+		}
+		LM_DBG("added value\n");
+	}
+	LM_DBG("reply message: %d\n", xval.v.i);
+	return xval.v.i;
+}
+
+int pvh_reply_append(void)
+{
+	sr_xavp_t *xavp = NULL;
+	sr_xval_t xval;
+
+	xavp = xavp_get_child_with_ival(&xavp_helper_xname, &reply_counter);
+	if(xavp) {
+		xavp->val.v.i++;
+		LM_DBG("reply message: %d\n", xavp->val.v.i);
+		return xavp->val.v.i;
+	}
+
+	memset(&xval, 0, sizeof(sr_xval_t));
+	xval.type = SR_XTYPE_INT;
+	xval.v.i = 0;
+
+	xavp = xavp_get(&xavp_name, NULL);
+	if(xavp == NULL) {
+		if(xavp_add_xavp_value(&xavp_helper_xname, &reply_counter, &xval, NULL)
+				== NULL) {
+			LM_ERR("can't create xavp:%.*s\n", xavp_helper_xname.len,
+					xavp_helper_xname.s);
+			return -1;
+		}
+		LM_DBG("xavp_name:%.*s created\n", xavp_helper_xname.len,
+				xavp_helper_xname.s);
+	} else {
+		if(xavp_add_value(&reply_counter, &xval, &xavp->val.v.xavp) == NULL) {
+			LM_ERR("can't add reply_counter value\n");
+			return -1;
+		}
+		LM_DBG("added value\n");
+	}
+	LM_DBG("reply message: %d\n", xval.v.i);
+	return xval.v.i;
+}
+
+sr_xavp_t *pvh_xavp_new_value(str *name, sr_xval_t *val)
+{
+	sr_xavp_t *avp = NULL;
+	int size;
+	unsigned int id;
+
+	if(name == NULL || name->s == NULL || val == NULL)
+		return NULL;
+	id = get_hash1_raw(name->s, name->len);
+
+	size = sizeof(sr_xavp_t) + name->len + 1;
+	if(val->type == SR_XTYPE_STR)
+		size += val->v.s.len + 1;
+	avp = (sr_xavp_t *)shm_malloc(size);
+	if(avp == NULL) {
+		SHM_MEM_ERROR;
+		return NULL;
+	}
+	memset(avp, 0, size);
+	avp->id = id;
+	avp->name.s = (char *)avp + sizeof(sr_xavp_t);
+	memcpy(avp->name.s, name->s, name->len);
+	avp->name.s[name->len] = '\0';
+	avp->name.len = name->len;
+	memcpy(&avp->val, val, sizeof(sr_xval_t));
+	if(val->type == SR_XTYPE_STR) {
+		avp->val.v.s.s = avp->name.s + avp->name.len + 1;
+		memcpy(avp->val.v.s.s, val->v.s.s, val->v.s.len);
+		avp->val.v.s.s[val->v.s.len] = '\0';
+		avp->val.v.s.len = val->v.s.len;
+	}
+
+	return avp;
+}
+
+int pvh_xavp_append_value(str *name, sr_xval_t *val, sr_xavp_t **start)
+{
+	sr_xavp_t *last = NULL;
+	sr_xavp_t *xavp = NULL;
+
+	if((xavp = pvh_xavp_new_value(name, val)) == NULL)
+		return -1;
+
+	if(*start == NULL) {
+		xavp->next = *start;
+		*start = xavp;
+		return 1;
+	}
+
+	last = *start;
+	while(last->next)
+		last = last->next;
+	last->next = xavp;
+
+	return 1;
+}
+
+int pvh_xavp_set_value(str *name, sr_xval_t *val, int idx, sr_xavp_t **start)
+{
+	int cnt = 0;
+
+	if(idx < 0) {
+		cnt = xavp_count(name, start);
+		idx = idx + cnt;
+		if(idx < 0)
+			return -1;
+	}
+	LM_DBG("xavp name: %.*s\n", name->len, name->s);
+	if(xavp_set_value(name, idx, val, start) == NULL)
+		return -1;
+
+	return 1;
+}
+
+void pvh_free_to_params(struct to_param *param, sr_xavp_sfree_f sfree)
+{
+	struct to_param *n = NULL;
+
+	while(param) {
+		n = param->next;
+		sfree(param);
+		param = n;
+	}
+	param = NULL;
+}
+
+void pvh_xavp_free_data(void *p, sr_xavp_sfree_f sfree)
+{
+	xavp_c_data_t *c_data = NULL;
+
+	if((c_data = (xavp_c_data_t *)p) != NULL) {
+		pvh_free_to_params(c_data->to_params, sfree);
+		sfree(c_data->value.s);
+		c_data->value.s = NULL;
+		sfree(c_data);
+		c_data = NULL;
+	}
+}
+
+int pvh_set_xavp(struct sip_msg *msg, str *xname, str *name, void *data,
+		sr_xtype_t type, int idx, int append)
+{
+	sr_xavp_t **xavp = NULL;
+	sr_xavp_t *root = NULL;
+	sr_xval_t root_xval;
+	sr_xval_t xval;
+	str br_xname = STR_NULL;
+
+	if(xname == NULL || name == NULL) {
+		LM_ERR("missing xavp/pv name\n");
+		return -1;
+	}
+
+	if(pvh_str_new(&br_xname, header_name_size) < 0)
+		return -1;
+	pvh_get_branch_xname(msg, xname, &br_xname);
+	LM_DBG("br_xname: %.*s name: %.*s\n", br_xname.len, br_xname.s, name->len,
+			name->s);
+	memset(&xval, 0, sizeof(sr_xval_t));
+	if(data == NULL || SR_XTYPE_NULL) {
+		xval.type = SR_XTYPE_NULL;
+	} else if(type == SR_XTYPE_STR) {
+		xval.type = SR_XTYPE_STR;
+		xval.v.s = *(str *)data;
+	} else if(type == SR_XTYPE_DATA) {
+		xval.type = SR_XTYPE_DATA;
+		xval.v.data = (sr_data_t *)shm_malloc(sizeof(sr_data_t));
+		if(xval.v.data == NULL) {
+			SHM_MEM_ERROR;
+			goto err;
+		}
+		memset(xval.v.data, 0, sizeof(sr_data_t));
+		xval.v.data->p = data;
+		xval.v.data->pfree = pvh_xavp_free_data;
+	}
+
+	root = xavp_get(&br_xname, NULL);
+
+	if(root == NULL && _branch > 0) {
+		pvh_clone_branch_xavp(msg, xname);
+		root = xavp_get(&br_xname, NULL);
+	}
+
+	xavp = root ? &root->val.v.xavp : &root;
+
+	if(root == NULL) {
+		append = 1;
+		memset(&root_xval, 0, sizeof(sr_xval_t));
+		root_xval.type = SR_XTYPE_XAVP;
+		root_xval.v.xavp = NULL;
+
+		if((root = xavp_add_value(&br_xname, &root_xval, NULL)) == NULL) {
+			LM_ERR("error create xavp %s\n", br_xname.s);
+			goto err;
+		}
+		xavp = &root->val.v.xavp;
+	} else if(xavp_get_child(&br_xname, name) == NULL) {
+		append = 1;
+	}
+
+	if(append) {
+		if(pvh_xavp_append_value(name, &xval, xavp) < 0) {
+			LM_ERR("error append xavp=>name %s=>%.*s\n", br_xname.s, name->len,
+					name->s);
+			goto err;
+		}
+	} else {
+		if(pvh_xavp_set_value(name, &xval, idx, xavp) < 0) {
+			LM_ERR("error modify xavp=>name %s=>%.*s idx=%d\n", br_xname.s,
+					name->len, name->s, idx);
+			goto err;
+		}
+	}
+
+	pvh_str_free(&br_xname);
+	return 1;
+
+err:
+	pvh_str_free(&br_xname);
+	return -1;
+}
+
+int pvh_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
+{
+	int os = 0;
+	char br_idx_s[32];
+	char br_idx_len = 0;
+	sr_xavp_t *xavp;
+	int reply = 0;
+
+	if(dst == NULL)
+		return -1;
+
+	memset(dst->s, 0, dst->len);
+	memcpy(dst->s, xname->s, xname->len);
+	os += xname->len;
+
+	if(_branch > 0) {
+		snprintf(br_idx_s, 32, "%d", _branch - 1);
+		br_idx_len = strlen(br_idx_s);
+		memcpy(dst->s + os, ".", 1);
+		os += 1;
+		memcpy(dst->s + os, br_idx_s, br_idx_len);
+		os += br_idx_len;
+	}
+	if(msg->first_line.type == SIP_REPLY) {
+		xavp = xavp_get_child_with_ival(&xavp_helper_xname, &reply_counter);
+		if(!xavp) {
+			LM_DBG("no %.*s=>%.*s found\n", xavp_helper_xname.len,
+					xavp_helper_xname.s, reply_counter.len, reply_counter.s);
+			pvh_reply_append();
+			reply = 0;
+		} else {
+			reply = xavp->val.v.i;
+		}
+		snprintf(br_idx_s, 32, ".r.%d", reply);
+		br_idx_len = strlen(br_idx_s);
+		memcpy(dst->s + os, br_idx_s, br_idx_len);
+		os += br_idx_len;
+	}
+	dst->len = os;
+	dst->s[dst->len] = '\0';
+
+	return 1;
+}
+
+int pvh_clone_branch_xavp(struct sip_msg *msg, str *xname)
+{
+	sr_xavp_t *xavp = NULL;
+	sr_xavp_t *br_xavp = NULL;
+	sr_xavp_t *sub = NULL;
+	sr_xval_t root_xval;
+	str br_xname = STR_NULL;
+
+	if((xavp = xavp_get(xname, NULL)) == NULL) {
+		LM_ERR("cannot clone xavp from non existing %s\n", xname->s);
+		return -1;
+	}
+
+	if(xavp->val.type != SR_XTYPE_XAVP) {
+		LM_ERR("not xavp child type %s\n", xavp_name.s);
+		return -1;
+	}
+
+	if((sub = xavp->val.v.xavp) == NULL) {
+		LM_ERR("invalid xavp structure: %s\n", xavp_name.s);
+		return -1;
+	}
+
+	if(pvh_str_new(&br_xname, header_name_size) < 0)
+		return -1;
+	pvh_get_branch_xname(msg, xname, &br_xname);
+
+	memset(&root_xval, 0, sizeof(sr_xval_t));
+	root_xval.type = SR_XTYPE_XAVP;
+	root_xval.v.xavp = NULL;
+
+	if((br_xavp = xavp_add_value(&br_xname, &root_xval, NULL)) == NULL) {
+		LM_ERR("error create xavp %s\n", br_xname.s);
+		goto err;
+	}
+
+	if(strncmp(xname->s, xavp_parsed_xname.s, xname->len) == 0) {
+		pvh_str_free(&br_xname);
+		return 1;
+	}
+
+	do {
+		if(pvh_skip_header(&sub->name))
+			continue;
+		if(sub->val.type == SR_XTYPE_DATA)
+			continue;
+		if(pvh_xavp_append_value(&sub->name, &sub->val, &br_xavp->val.v.xavp)
+				< 0) {
+			LM_ERR("cannot clone xavp %s\n", sub->name.s);
+			goto err;
+		}
+	} while((sub = sub->next) != NULL);
+
+	pvh_str_free(&br_xname);
+	return 1;
+
+err:
+	pvh_str_free(&br_xname);
+	return -1;
+}
diff --git a/src/modules/pv_headers_new/pvh_xavp.h b/src/modules/pv_headers_new/pvh_xavp.h
new file mode 100644
index 0000000..ccd5474
--- /dev/null
+++ b/src/modules/pv_headers_new/pvh_xavp.h
@@ -0,0 +1,41 @@
+/*
+ * pv_headers
+ *
+ * Copyright (C)
+ * 2020 Victor Seva <vseva@sipwise.com>
+ * 2018 Kirill Solomko <ksolomko@sipwise.com>
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * Kamailio is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * Kamailio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#ifndef PV_XAVP_H
+#define PV_XAVP_H
+
+#include "../../core/str.h"
+#include "../../core/xavp.h"
+
+#include "pv_headers.h"
+
+int pvh_reply_append(void);
+
+int pvh_set_xavp(struct sip_msg *msg, str *xname, str *name, void *data,
+		sr_xtype_t type, int idx, int append);
+
+int pvh_get_branch_xname(struct sip_msg *msg, str *xname, str *dst);
+int pvh_clone_branch_xavp(struct sip_msg *msg, str *xname);
+
+#endif /* PV_XAVP_H */
