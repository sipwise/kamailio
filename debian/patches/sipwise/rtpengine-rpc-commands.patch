--- a/modules/rtpengine/rtpengine.c
+++ b/modules/rtpengine/rtpengine.c
@@ -66,7 +66,6 @@
 #include "../../ut.h"
 #include "../../pt.h"
 #include "../../timer_proc.h"
-#include "../../lib/kmi/mi.h"
 #include "../../pvar.h"
 #include "../../lvalue.h"
 #include "../../msg_translator.h"
@@ -75,7 +74,8 @@
 #include "../../mod_fix.h"
 #include "../../dset.h"
 #include "../../route.h"
-#include "../../char_msg_val.h"
+#include "../../rpc.h"
+#include "../../rpc_lookup.h"
 #include "../../modules/tm/tm_load.h"
 #include "rtpengine.h"
 #include "rtpengine_funcs.h"
@@ -102,64 +102,13 @@
 #define HOSTNAME_SIZE				100
 
 #define DEFAULT_RTPP_SET_ID			0
-#define MAX_RTPP_TRIED_NODES			50
-#define MI_SET_NATPING_STATE			"nh_enable_ping"
-#define MI_DEFAULT_NATPING_STATE		1
-
-#define MI_ENABLE_RTP_PROXY			"nh_enable_rtpp"
-#define MI_SHOW_RTP_PROXIES			"nh_show_rtpp"
-#define MI_PING_RTP_PROXY			"nh_ping_rtpp"
-#define MI_SHOW_HASH_TOTAL			"nh_show_hash_total"
-#define MI_RELOAD_RTP_PROXY			"nh_reload_rtpp"
-
-#define MI_DB_NOT_FOUND				"RTP database not found"
-#define MI_DB_NOT_FOUND_LEN			(sizeof(MI_DB_NOT_FOUND)-1)
-#define MI_DB_ERR				"Error reloading from RTP database"
-#define MI_DB_ERR_LEN				(sizeof(MI_DB_ERR)-1)
-#define MI_DB_OK				"Success reloading from RTP database"
-#define MI_DB_OK_LEN				(sizeof(MI_DB_OK)-1)
-#define MI_RTP_PROXY_NOT_FOUND			"RTP proxy not found"
-#define MI_RTP_PROXY_NOT_FOUND_LEN		(sizeof(MI_RTP_PROXY_NOT_FOUND)-1)
-#define MI_PING_DISABLED			"NAT ping disabled from script"
-#define MI_PING_DISABLED_LEN			(sizeof(MI_PING_DISABLED)-1)
-#define MI_DISABLED_PERMANENT			"1(permanent)"
-#define MI_DISABLED_PERMANENT_LEN		(sizeof(MI_DISABLED_PERMANENT)-1)
-#define MI_SET					"set"
-#define MI_SET_LEN				(sizeof(MI_SET)-1)
-#define MI_INDEX				"index"
-#define MI_INDEX_LEN				(sizeof(MI_INDEX)-1)
-#define MI_ENABLED				"enabled"
-#define MI_ENABLED_LEN				(sizeof(MI_ENABLED)-1)
-#define MI_DISABLED				"disabled"
-#define MI_DISABLED_LEN				(sizeof(MI_DISABLED)-1)
-#define MI_WEIGHT				"weight"
-#define MI_WEIGHT_LEN				(sizeof(MI_WEIGHT)-1)
-#define MI_RECHECK_TICKS			"recheck_ticks"
-#define MI_RECHECK_T_LEN			(sizeof(MI_RECHECK_TICKS)-1)
-
-#define MI_ERROR				"Error when adding rtpp node details"
-#define MI_ERROR_LEN				(sizeof(MI_ERROR)-1)
-#define MI_ALL					"all"
-#define MI_ALL_LEN				(sizeof(MI_ALL)-1)
-#define MI_ENABLE				"enable"
-#define MI_ENABLE_LEN				(sizeof(MI_ENABLE)-1)
-#define MI_DISABLE				"disable"
-#define MI_DISABLE_LEN				(sizeof(MI_DISABLE)-1)
-#define MI_PING					"ping"
-#define MI_PING_LEN				(sizeof(MI_PING)-1)
-#define MI_SUCCESS				"success"
-#define MI_SUCCESS_LEN				(sizeof(MI_SUCCESS)-1)
-#define MI_FAIL					"fail"
-#define MI_FAIL_LEN				(sizeof(MI_FAIL)-1)
-#define MI_HASH_ENTRIES				"entries"
-#define MI_HASH_ENTRIES_LEN			(sizeof(MI_HASH_ENTRIES)-1)
-#define MI_HASH_ENTRIES_FAIL			"Fail to get entry details"
-#define MI_HASH_ENTRIES_FAIL_LEN		(sizeof(MI_HASH_ENTRIES_FAIL)-1)
-
-#define MI_FOUND_ALL				2
-#define MI_FOUND_ONE				1
-#define MI_FOUND_NONE				0
+#define MAX_RTPP_TRIED_NODES            30
 
+enum {
+	RPC_FOUND_ALL = 2,
+	RPC_FOUND_ONE = 1,
+	RPC_FOUND_NONE = 0,
+};
 
 #define	CPORT					"22222"
 
@@ -187,7 +136,7 @@
 
 static int parse_flags(struct ng_flags_parse *, struct sip_msg *, enum rtpe_operation *, const char *);
 
-static int rtpengine_offer_answer(struct sip_msg *msg, const char *flags, enum rtpe_operation op, int more);
+static int rtpengine_offer_answer(struct sip_msg *msg, const char *flags, int op, int more);
 static int fixup_set_id(void ** param, int param_no);
 static int set_rtpengine_set_f(struct sip_msg * msg, char * str1, char * str2);
 static struct rtpp_set * select_rtpp_set(int id_set);
@@ -210,21 +159,13 @@
 static int get_ip_scope(char *str_addr); // useful for link-local ipv6
 static int bind_force_send_ip(int sock_idx);
 
-static int add_rtpp_node_info(struct mi_node *node, struct rtpp_node *crt_rtpp, struct rtpp_set *rtpp_list);
+static int add_rtpp_node_info(void *ptrs, struct rtpp_node *crt_rtpp, struct rtpp_set *rtpp_list);
 static int rtpp_test_ping(struct rtpp_node *node);
 
 /* Pseudo-Variables */
 static int pv_get_rtpstat_f(struct sip_msg *, pv_param_t *, pv_value_t *);
 static int set_rtp_inst_pvar(struct sip_msg *msg, const str * const uri);
 
-/*mi commands*/
-static struct mi_root* mi_enable_rtp_proxy(struct mi_root* cmd_tree, void* param);
-static struct mi_root* mi_show_rtp_proxy(struct mi_root* cmd_tree, void* param);
-static struct mi_root* mi_ping_rtp_proxy(struct mi_root* cmd_tree, void* param);
-static struct mi_root* mi_show_hash_total(struct mi_root* cmd_tree, void* param);
-static struct mi_root* mi_reload_rtp_proxy(struct mi_root* cmd_tree, void* param);
-
-
 static int rtpengine_disable_tout = 60;
 static int rtpengine_allow_op = 0;
 static int rtpengine_retr = 5;
@@ -358,23 +299,13 @@
 	{0, 0, 0}
 };
 
-static mi_export_t mi_cmds[] = {
-	{MI_ENABLE_RTP_PROXY,     mi_enable_rtp_proxy,  0,  0,  0},
-	{MI_SHOW_RTP_PROXIES,     mi_show_rtp_proxy,    0,  0,  0},
-	{MI_PING_RTP_PROXY,       mi_ping_rtp_proxy,    0,  0,  0},
-	{MI_SHOW_HASH_TOTAL,      mi_show_hash_total,   0,  0,  0},
-	{MI_RELOAD_RTP_PROXY,     mi_reload_rtp_proxy,  0,  0,  0},
-	{ 0, 0, 0, 0, 0}
-};
-
-
 struct module_exports exports = {
 	"rtpengine",
 	DEFAULT_DLFLAGS, /* dlopen flags */
 	cmds,
 	params,
 	0,           /* exported statistics */
-	mi_cmds,     /* exported MI functions */
+	0,           /* exported MI functions */
 	mod_pvs,     /* exported pseudo-variables */
 	0,           /* extra processes */
 	mod_init,
@@ -405,7 +336,7 @@
 int rtpengine_delete_node(struct rtpp_node *rtpp_node)
 {
 	rtpp_node->rn_displayed = 0;
-	rtpp_node->rn_disabled = MI_MAX_RECHECK_TICKS;
+	rtpp_node->rn_disabled = RTPENGINE_MAX_RECHECK_TICKS;
 
 	return 1;
 }
@@ -796,7 +727,7 @@
 		lock_get(rtpp_no_lock);
 		pnode->idx = *rtpp_no;
 
-		if (ticks == MI_MAX_RECHECK_TICKS) {
+		if (ticks == RTPENGINE_MAX_RECHECK_TICKS) {
 			pnode->rn_recheck_ticks = ticks;
 		} else {
 			pnode->rn_recheck_ticks = ticks + get_ticks();
@@ -1057,565 +988,296 @@
 	return -1;
 }
 
-static struct mi_root* mi_enable_rtp_proxy(struct mi_root *cmd_tree, void *param)
-{
-	struct mi_node *node, *crt_node;
-	struct rtpp_set *rtpp_list;
-	struct rtpp_node *crt_rtpp, *found_rtpp;
-	struct mi_root *root = NULL;
-	struct mi_attr *attr;
-	unsigned int enable;
-	int found, found_rtpp_disabled;
-	str rtpp_url;
-	str snode, sattr, svalue;
-
-	found = MI_FOUND_NONE;
-	found_rtpp_disabled = 0;
-	found_rtpp = NULL;
-	enable = 0;
 
-	if (rtpp_set_list == NULL) {
-		return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
-	}
+static void rtpengine_rpc_reload(rpc_t* rpc, void* ctx)
+{
+	unsigned int current_rtpp_no;
 
-	node = cmd_tree->node.kids;
-	if (node == NULL) {
-		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	if (rtpp_db_url.s == NULL) {
+		// no database
+		rpc->fault(ctx, 500, "No Database URL");
+		return;
 	}
 
-	if (node->value.s == NULL || node->value.len ==0) {
-		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	if (init_rtpproxy_db() < 0) {
+		// fail reloading from database
+		rpc->fault(ctx, 500, "Failed reloading db");
+		return;
 	}
 
-	/* get proxy */
-	rtpp_url = node->value;
-
-	node = node->next;
-	if (node == NULL) {
-		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
-	}
+	lock_get(rtpp_no_lock);
+	current_rtpp_no = *rtpp_no;
+	lock_release(rtpp_no_lock);
 
-	if (node->value.s == NULL || node->value.len ==0) {
-		return init_mi_tree(400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	if (rtpp_socks_size != current_rtpp_no) {
+		build_rtpp_socks(current_rtpp_no);
 	}
+}
 
-	/* get value (enable/disable) */
-	if(strno2int(&node->value, &enable) < 0) {
-		goto error;
-	}
+static int rtpengine_rpc_iterate(rpc_t* rpc, void* ctx, const str *rtpp_url,
+		int (*cb)(struct rtpp_node *, struct rtpp_set *, void *), void *data)
+{
+	struct rtpp_set *rtpp_list;
+	struct rtpp_node *crt_rtpp;
+	int found = RPC_FOUND_NONE, err = 0;
+	int ret;
 
-	node = node->next;
-	if (node != NULL) {
-		return init_mi_tree(400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
+	if (!rtpp_set_list) {
+		rpc->fault(ctx, 404, "Instance not found (no sets loaded)");
+		return -1;
 	}
 
 	/* found a matching all - show all rtpp */
-	if (strncmp(MI_ALL, rtpp_url.s, MI_ALL_LEN) == 0) {
-		found = MI_FOUND_ALL;
+	if (strncmp("all", rtpp_url->s, 3) == 0) {
+		found = RPC_FOUND_ALL;
 	}
 
 	lock_get(rtpp_set_list->rset_head_lock);
-	for(rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
+	for (rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
 			rtpp_list = rtpp_list->rset_next) {
 
 		lock_get(rtpp_list->rset_lock);
-		for(crt_rtpp = rtpp_list->rn_first; crt_rtpp != NULL;
+		for (crt_rtpp = rtpp_list->rn_first; crt_rtpp != NULL;
 				crt_rtpp = crt_rtpp->rn_next) {
 
 			if (!crt_rtpp->rn_displayed) {
 				continue;
 			}
 
-			/* found a matching rtpp - show it */
-			if (found == MI_FOUND_ALL ||
-			   (crt_rtpp->rn_url.len == rtpp_url.len &&
-			   strncmp(crt_rtpp->rn_url.s, rtpp_url.s, rtpp_url.len) == 0)) {
-
-				/* do ping when try to enable the rtpp */
-				if (enable) {
-
-					/* if ping success, enable the rtpp and reset ticks */
-					if (rtpp_test_ping(crt_rtpp) == 0) {
-						crt_rtpp->rn_disabled = 0;
-						crt_rtpp->rn_recheck_ticks = MI_MIN_RECHECK_TICKS;
-
-					/* if ping fail, disable the rtpps but _not_ permanently*/
-					} else {
-						crt_rtpp->rn_recheck_ticks = get_ticks() + rtpengine_disable_tout;
-						crt_rtpp->rn_disabled = 1;
-						found_rtpp_disabled = 1;
-					}
-
-				/* do not ping when disable the rtpp; disable it permanenty */
-				} else {
-					crt_rtpp->rn_disabled = 1;
-					crt_rtpp->rn_recheck_ticks = MI_MAX_RECHECK_TICKS;
+			/* found a matching rtpp - ping it */
+			if (found == RPC_FOUND_ALL ||
+			   (crt_rtpp->rn_url.len == rtpp_url->len &&
+			   strncmp(crt_rtpp->rn_url.s, rtpp_url->s, rtpp_url->len) == 0)) {
+
+				ret = cb(crt_rtpp, rtpp_list, data);
+				if (ret) {
+					err = 1;
+					break;
 				}
 
-				if (found == MI_FOUND_NONE) {
-					found = MI_FOUND_ONE;
-					found_rtpp = crt_rtpp;
+				if (found == RPC_FOUND_NONE) {
+					found = RPC_FOUND_ONE;
 				}
 			}
 		}
 		lock_release(rtpp_list->rset_lock);
-	}
-	lock_release(rtpp_set_list->rset_head_lock);
-
-	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
-	if (!root) {
-		LM_ERR("the MI tree cannot be initialized!\n");
-		return 0;
-	}
-	node = &root->node;
 
-	switch (found) {
-		case MI_FOUND_ALL:
-			snode.s = MI_ALL;
-			snode.len = MI_ALL_LEN;
+		if (err)
 			break;
-		case MI_FOUND_ONE:
-			snode.s = found_rtpp->rn_url.s;
-			snode.len = found_rtpp->rn_url.len;
-			break;
-		default:
-			if (root) {
-				free_mi_tree(root);
-			}
-			return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
-	}
-
-	svalue.s = MI_SUCCESS;
-	svalue.len = MI_SUCCESS_LEN;
-
-	if (enable) {
-		sattr.s = MI_ENABLE;
-		sattr.len = MI_ENABLE_LEN;
-
-		if (found_rtpp_disabled) {
-			svalue.s = MI_FAIL;
-			svalue.len = MI_FAIL_LEN;
-		}
-	} else {
-		sattr.s = MI_DISABLE;
-		sattr.len = MI_DISABLE_LEN;
 	}
+	lock_release(rtpp_set_list->rset_head_lock);
 
-	if (!(crt_node = add_mi_node_child(node, 0, snode.s, snode.len, 0, 0))) {
-		LM_ERR("cannot add the child node to the tree\n");
-		goto error;
-	}
+	if (err)
+		return -1;
 
-	if ((attr = add_mi_attr(crt_node, MI_DUP_VALUE, sattr.s, sattr.len, svalue.s, svalue.len)) == 0) {
-		LM_ERR("cannot add attributes to the node\n");
-		goto error;
+	if (found == RPC_FOUND_NONE) {
+		rpc->fault(ctx, 404, "Instance not found");
+		return -1;
 	}
 
-
-	return root;
-
-error:
-	if (root) {
-		free_mi_tree(root);
-	}
-	return init_mi_tree(404, MI_ERROR, MI_ERROR_LEN);
+	return found;
 }
 
-
-
-
-#define add_rtpp_node_int_info(_parent, _name, _name_len, _value, _child,\
-								_len, _string, _error)\
-	do {\
-		(_string) = int2str((_value), &(_len));\
-		if((_string) == 0){\
-			LM_ERR("cannot convert int value\n");\
-				goto _error;\
-		}\
-		if(((_child) = add_mi_node_child((_parent), MI_DUP_VALUE, (_name), \
-				(_name_len), (_string), (_len))) == 0)\
-			goto _error;\
-	}while(0);
-
-
-static int add_rtpp_node_info (struct mi_node *node, struct rtpp_node *crt_rtpp, struct rtpp_set *rtpp_list)
+static int add_rtpp_node_info (void *ptrsp, struct rtpp_node *crt_rtpp, struct rtpp_set *rtpp_list)
 {
-	int id_len, len;
+	void *vh;
+	void **ptrs = ptrsp;
+	rpc_t *rpc;
+	void *ctx;
 	int rtpp_ticks;
-	struct mi_node *crt_node, *child;
-	struct mi_attr *attr;
-	char *string, *id;
-
-	string = id = 0;
-
-	id = int2str(rtpp_list->id_set, &id_len);
-	if (!id) {
-		LM_ERR("cannot convert set id\n");
-		goto error;
-	}
-
-	if (!(crt_node = add_mi_node_child(node, 0, crt_rtpp->rn_url.s, crt_rtpp->rn_url.len, 0,0))) {
-		LM_ERR("cannot add the child node to the tree\n");
-		goto error;
-	}
 
-	LM_DBG("adding node name %s \n",crt_rtpp->rn_url.s );
+	rpc = ptrs[0];
+	ctx = ptrs[1];
 
-	if ((attr = add_mi_attr(crt_node, MI_DUP_VALUE, MI_SET, MI_SET_LEN, id, id_len)) == 0) {
-		LM_ERR("cannot add attributes to the node\n");
-		goto error;
+	if (rpc->add(ctx, "{", &vh) < 0) {
+		rpc->fault(ctx, 500, "Server error");
+		return -1;
 	}
 
-	add_rtpp_node_int_info(crt_node, MI_INDEX, MI_INDEX_LEN,
-		crt_rtpp->idx, child, len, string, error);
+	rpc->struct_add(vh, "Sddd",
+			"url", &crt_rtpp->rn_url,
+			"set", rtpp_list->id_set,
+			"index", crt_rtpp->idx,
+			"weight", crt_rtpp->rn_weight);
 
-	if ((1 == crt_rtpp->rn_disabled ) && (crt_rtpp->rn_recheck_ticks == MI_MAX_RECHECK_TICKS)) {
-		if (!(child = add_mi_node_child(crt_node, MI_DUP_VALUE, MI_DISABLED, MI_DISABLED_LEN,
-		   MI_DISABLED_PERMANENT, MI_DISABLED_PERMANENT_LEN))) {
-			LM_ERR("cannot add disabled (permanent) message\n");
-			goto error;
-		}
+	if ((1 == crt_rtpp->rn_disabled ) && (crt_rtpp->rn_recheck_ticks == RTPENGINE_MAX_RECHECK_TICKS)) {
+		rpc->struct_add(vh, "s", "disabled", "1(permanent)");
 	} else {
-		add_rtpp_node_int_info(crt_node, MI_DISABLED, MI_DISABLED_LEN,
-			crt_rtpp->rn_disabled, child, len, string, error);
+		rpc->struct_add(vh, "d", "disabled", crt_rtpp->rn_disabled);
 	}
 
-	add_rtpp_node_int_info(crt_node, MI_WEIGHT, MI_WEIGHT_LEN,
-		crt_rtpp->rn_weight, child, len, string, error);
-
-	if (crt_rtpp->rn_recheck_ticks == MI_MAX_RECHECK_TICKS) {
-		if (!(child = add_mi_node_child(crt_node, MI_DUP_VALUE,
-		   MI_RECHECK_TICKS, MI_RECHECK_T_LEN,
-		   "N/A", sizeof("N/A") - 1))) {
-			LM_ERR("cannot add MAX recheck_ticks value\n");
-			goto error;
-		}
+	if (crt_rtpp->rn_recheck_ticks == RTPENGINE_MAX_RECHECK_TICKS) {
+		rpc->struct_add(vh, "s", "recheck_ticks", "N/A");
 	} else {
 		rtpp_ticks = crt_rtpp->rn_recheck_ticks - get_ticks();
 		rtpp_ticks = rtpp_ticks < 0 ? 0 : rtpp_ticks;
-		add_rtpp_node_int_info(crt_node, MI_RECHECK_TICKS, MI_RECHECK_T_LEN,
-			rtpp_ticks, child, len, string, error);
+		rpc->struct_add(vh, "d", "recheck_ticks", rtpp_ticks);
 	}
 
 	return 0;
-
-error:
-	return -1;
 }
 
-static struct mi_root* mi_show_rtp_proxy(struct mi_root* cmd_tree, void* param)
+static int rtpengine_iter_cb_enable(struct rtpp_node *crt_rtpp, struct rtpp_set *rtpp_list, void *flagp)
 {
-	struct mi_node *node;
-	struct mi_root *root = NULL;
-	struct rtpp_set *rtpp_list;
-	struct rtpp_node *crt_rtpp;
-	int found;
-	str rtpp_url;
+	int *flag = flagp;
 
-	found = MI_FOUND_NONE;
+	/* do ping when try to enable the rtpp */
+	if (*flag) {
 
-	if (rtpp_set_list == NULL) {
-		return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
-	}
-
-	node = cmd_tree->node.kids;
-	if (node == NULL) {
-		return init_mi_tree( 400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
-	}
+		/* if ping success, enable the rtpp and reset ticks */
+		if (rtpp_test_ping(crt_rtpp) == 0) {
+			crt_rtpp->rn_disabled = 0;
+			crt_rtpp->rn_recheck_ticks = RTPENGINE_MIN_RECHECK_TICKS;
 
-	if (node->value.s == NULL || node->value.len ==0) {
-		return init_mi_tree( 400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
-	}
-
-	rtpp_url = node->value;
-	if (strncmp(MI_ALL, rtpp_url.s, MI_ALL_LEN) != 0 && rtpp_set_list == NULL) {
-		return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
-	}
-
-	node = node->next;
-	if (node != NULL) {
-		return init_mi_tree( 400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
-	}
-
-	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
-	if (!root) {
-		LM_ERR("the MI tree cannot be initialized!\n");
-		return 0;
-	}
-
-	node = &root->node;
-
-	/* found a matching all - show all rtpp */
-	if (strncmp(MI_ALL, rtpp_url.s, MI_ALL_LEN) == 0) {
-		found = MI_FOUND_ALL;
-	}
-
-	lock_get(rtpp_set_list->rset_head_lock);
-	for(rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
-			rtpp_list = rtpp_list->rset_next) {
-
-		lock_get(rtpp_list->rset_lock);
-		for(crt_rtpp = rtpp_list->rn_first; crt_rtpp != NULL;
-				crt_rtpp = crt_rtpp->rn_next) {
-
-			if (!crt_rtpp->rn_displayed) {
-				continue;
-			}
-
-			/* found a matching rtpp - show it */
-			if (found == MI_FOUND_ALL ||
-			   (crt_rtpp->rn_url.len == rtpp_url.len &&
-			   strncmp(crt_rtpp->rn_url.s, rtpp_url.s, rtpp_url.len) == 0)) {
-
-				if (add_rtpp_node_info(node, crt_rtpp, rtpp_list) < 0) {
-					lock_release(rtpp_list->rset_lock);
-					lock_release(rtpp_set_list->rset_head_lock);
-					goto error;
-				}
-
-				if (found == MI_FOUND_NONE) {
-					found = MI_FOUND_ONE;
-				}
-			}
+		/* if ping fail, disable the rtpps but _not_ permanently*/
+		} else {
+			crt_rtpp->rn_recheck_ticks = get_ticks() + rtpengine_disable_tout;
+			crt_rtpp->rn_disabled = 1;
+			*flag = 2; /* return value to caller */
 		}
-		lock_release(rtpp_list->rset_lock);
-	}
-	lock_release(rtpp_set_list->rset_head_lock);
 
-	switch (found) {
-		case MI_FOUND_ALL:
-		case MI_FOUND_ONE:
-			break;
-		default:
-			if (root) {
-				free_mi_tree(root);
-			}
-			return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
+	/* do not ping when disable the rtpp; disable it permanenty */
+	} else {
+		crt_rtpp->rn_disabled = 1;
+		crt_rtpp->rn_recheck_ticks = RTPENGINE_MAX_RECHECK_TICKS;
 	}
 
-	return root;
-
-error:
-	if (root) {
-		free_mi_tree(root);
-	}
-	return init_mi_tree(404, MI_ERROR, MI_ERROR_LEN);
+	return 0;
 }
 
-static struct mi_root* mi_ping_rtp_proxy(struct mi_root* cmd_tree, void* param)
+static void rtpengine_rpc_enable(rpc_t* rpc, void* ctx)
 {
-	struct mi_node *node, *crt_node;
-	struct mi_attr *attr;
-	struct mi_root *root = NULL;
-	struct rtpp_set *rtpp_list;
-	struct rtpp_node *crt_rtpp, *found_rtpp;
-	int found, found_rtpp_disabled;
+	void *vh;
 	str rtpp_url;
-	str snode, sattr, svalue;
-
-	found = 0;
-	found_rtpp_disabled = 0;
-	found_rtpp = NULL;
-
-	if (rtpp_set_list == NULL) {
-		return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
-	}
-
-	node = cmd_tree->node.kids;
-	if (node == NULL) {
-		return init_mi_tree( 400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
-	}
+	int flag, found;
 
-	if (node->value.s == NULL || node->value.len ==0) {
-		return init_mi_tree( 400, MI_BAD_PARM_S, MI_BAD_PARM_LEN);
+	if (rpc->scan(ctx, "Sd", &rtpp_url, &flag) < 2) {
+		rpc->fault(ctx, 500, "Not enough parameters");
+		return;
 	}
 
-	rtpp_url = node->value;
+	flag = flag ? 1 : 0; /* also used as a return value */
 
-	node = node->next;
-	if (node != NULL) {
-		return init_mi_tree( 400, MI_MISSING_PARM_S, MI_MISSING_PARM_LEN);
-	}
+	found = rtpengine_rpc_iterate(rpc, ctx, &rtpp_url, rtpengine_iter_cb_enable, &flag);
+	if (found == -1)
+		return;
 
-	/* found a matching all - ping all rtpp */
-	if (strncmp(MI_ALL, rtpp_url.s, MI_ALL_LEN) == 0) {
-		found = MI_FOUND_ALL;
+	if (rpc->add(ctx, "{", &vh) < 0) {
+		rpc->fault(ctx, 500, "Server error");
+		return;
 	}
 
-	lock_get(rtpp_set_list->rset_head_lock);
-	for (rtpp_list = rtpp_set_list->rset_first; rtpp_list != NULL;
-			rtpp_list = rtpp_list->rset_next) {
-
-		lock_get(rtpp_list->rset_lock);
-		for (crt_rtpp = rtpp_list->rn_first; crt_rtpp != NULL;
-				crt_rtpp = crt_rtpp->rn_next) {
-
-			if (!crt_rtpp->rn_displayed) {
-				continue;
-			}
+	rpc->struct_add(vh, "S", "url", &rtpp_url);
 
-			/* found a matching rtpp - ping it */
-			if (found == MI_FOUND_ALL ||
-			   (crt_rtpp->rn_url.len == rtpp_url.len &&
-			   strncmp(crt_rtpp->rn_url.s, rtpp_url.s, rtpp_url.len) == 0)) {
-
-				/* if ping fail */
-				if (rtpp_test_ping(crt_rtpp) < 0) {
-					crt_rtpp->rn_recheck_ticks = get_ticks() + rtpengine_disable_tout;
-					found_rtpp_disabled = 1;
-					crt_rtpp->rn_disabled = 1;
-				}
-
-				if (found == MI_FOUND_NONE) {
-					found = MI_FOUND_ONE;
-					found_rtpp = crt_rtpp;
-				}
-			}
-		}
-		lock_release(rtpp_list->rset_lock);
-	}
-	lock_release(rtpp_set_list->rset_head_lock);
+	if (flag == 0)
+		rpc->struct_add(vh, "s", "status", "disable");
+	else if (flag == 1)
+		rpc->struct_add(vh, "s", "status", "enable");
+	else
+		rpc->struct_add(vh, "s", "status", "fail");
+}
 
-	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
-	if (!root) {
-		LM_ERR("the MI tree cannot be initialized!\n");
-		return 0;
-	}
+static int rtpengine_iter_cb_show(struct rtpp_node *crt_rtpp, struct rtpp_set *rtpp_list, void *ptrsp)
+{
+	if (add_rtpp_node_info(ptrsp, crt_rtpp, rtpp_list) < 0)
+		return -1;
+	return 0;
+}
 
-	node = &root->node;
+static void rtpengine_rpc_show(rpc_t* rpc, void* ctx)
+{
+	str rtpp_url;
+	void *ptrs[2] = {rpc, ctx};
 
-	switch (found) {
-		case MI_FOUND_ALL:
-			snode.s = MI_ALL;
-			snode.len = MI_ALL_LEN;
-			break;
-		case MI_FOUND_ONE:
-			snode.s = found_rtpp->rn_url.s;
-			snode.len = found_rtpp->rn_url.len;
-			break;
-		default:
-			if (root) {
-				free_mi_tree(root);
-			}
-			return init_mi_tree(404, MI_RTP_PROXY_NOT_FOUND, MI_RTP_PROXY_NOT_FOUND_LEN);
+	if (rpc->scan(ctx, "S", &rtpp_url) < 1) {
+		rpc->fault(ctx, 500, "Not enough parameters");
+		return;
 	}
 
-	sattr.s = MI_PING;
-	sattr.len = MI_PING_LEN;
-
-	if (found_rtpp_disabled) {
-		svalue.s = MI_FAIL;
-		svalue.len = MI_FAIL_LEN;
-	} else {
-		svalue.s = MI_SUCCESS;
-		svalue.len = MI_SUCCESS_LEN;
-	}
+	rtpengine_rpc_iterate(rpc, ctx, &rtpp_url, rtpengine_iter_cb_show, ptrs);
+}
 
-	if (!(crt_node = add_mi_node_child(node, 0, snode.s, snode.len, 0, 0))) {
-		LM_ERR("cannot add the child node to the tree\n");
-		goto error;
-	}
+static int rtpengine_iter_cb_ping(struct rtpp_node *crt_rtpp, struct rtpp_set *rtpp_list, void *data)
+{
+	int *found_rtpp_disabled = data;
 
-	if ((attr = add_mi_attr(crt_node, MI_DUP_VALUE, sattr.s, sattr.len, svalue.s, svalue.len)) == 0) {
-		LM_ERR("cannot add attributes to the node\n");
-		goto error;
+	/* if ping fail */
+	if (rtpp_test_ping(crt_rtpp) < 0) {
+		crt_rtpp->rn_recheck_ticks = get_ticks() + rtpengine_disable_tout;
+		*found_rtpp_disabled = 1;
+		crt_rtpp->rn_disabled = 1;
 	}
 
-	return root;
-
-error:
-	if (root) {
-		free_mi_tree(root);
-	}
-	return init_mi_tree(404, MI_ERROR, MI_ERROR_LEN);
+	return 0;
 }
 
-
-static struct mi_root* mi_show_hash_total(struct mi_root* cmd_tree, void* param)
+static void rtpengine_rpc_ping(rpc_t* rpc, void* ctx)
 {
-	struct mi_node *node, *crt_node;
-	struct mi_attr *attr;
-	struct mi_root *root = NULL;
-	unsigned int total;
-	str total_str;
-
-	// Init print tree
-	root = init_mi_tree(200, MI_OK_S, MI_OK_LEN);
-	if (!root) {
-		LM_ERR("the MI tree cannot be initialized!\n");
-		return 0;
-	}
-	node = &root->node;
-
-	// Create new node and add it to the roots's kids
-	if (!(crt_node = add_mi_node_child(node, MI_DUP_NAME, "total", strlen("total"), 0, 0))) {
-		LM_ERR("cannot add the child node to the tree\n");
-		goto error;
-	}
+	void *vh;
+	int found;
+	int found_rtpp_disabled = 0;
+	str rtpp_url;
 
-	// Get total number of entries
-	total = rtpengine_hash_table_total();
-	total_str.s = int2str(total, &total_str.len);
-
-	// Add node attributes
-	if ((attr = add_mi_attr(crt_node, MI_DUP_VALUE, MI_HASH_ENTRIES, MI_HASH_ENTRIES_LEN, total_str.s, total_str.len)) == 0) {
-		LM_ERR("cannot add attributes to the node\n");
-		goto error;
+	if (rpc->scan(ctx, "S", &rtpp_url) < 1) {
+		rpc->fault(ctx, 500, "Not enough parameters");
+		return;
 	}
 
-	return root;
+	found = rtpengine_rpc_iterate(rpc, ctx, &rtpp_url, rtpengine_iter_cb_ping, &found_rtpp_disabled);
+	if (found == -1)
+		return;
 
-error:
-	if (root) {
-		free_mi_tree(root);
+	if (rpc->add(ctx, "{", &vh) < 0) {
+		rpc->fault(ctx, 500, "Server error");
+		return;
 	}
 
-	return init_mi_tree(404, MI_HASH_ENTRIES_FAIL, MI_HASH_ENTRIES_FAIL_LEN);
+	rpc->struct_add(vh, "Ss",
+			"url", &rtpp_url,
+			"status", (found_rtpp_disabled ? "fail" : "success"));
 }
 
-static struct mi_root*
-mi_reload_rtp_proxy(struct mi_root* cmd_tree, void* param)
+static void rtpengine_rpc_get_hash_total(rpc_t* rpc, void* ctx)
 {
-	struct mi_root *root = NULL;
-	unsigned int current_rtpp_no;
+	rpc->add(ctx, "u", rtpengine_hash_table_total());
+}
 
-	if (rtpp_db_url.s == NULL) {
-		// no database
-		root = init_mi_tree(404, MI_DB_NOT_FOUND, MI_DB_NOT_FOUND_LEN);
-		if (!root) {
-			LM_ERR("the MI tree cannot be initialized!\n");
-			return 0;
-		}
-	} else {
-		if (init_rtpproxy_db() < 0) {
-			// fail reloading from database
-			root = init_mi_tree(404, MI_DB_ERR, MI_DB_ERR_LEN);
-			if (!root) {
-				LM_ERR("the MI tree cannot be initialized!\n");
-				return 0;
-			}
-		} else {
-			lock_get(rtpp_no_lock);
-			current_rtpp_no = *rtpp_no;
-			lock_release(rtpp_no_lock);
 
-			if (rtpp_socks_size != current_rtpp_no) {
-				build_rtpp_socks(current_rtpp_no);
-			}
+static const char* rtpengine_rpc_reload_doc[2] = {
+	"Reload rtpengine proxies from database", 0
+};
+static const char* rtpengine_rpc_ping_doc[2] = {
+	"Ping an rtpengine instance", 0
+};
+static const char* rtpengine_rpc_show_doc[2] = {
+	"Get details about an rtpengine instance", 0
+};
+static const char* rtpengine_rpc_enable_doc[2] = {
+	"Enable or disable an rtpengine instance", 0
+};
+static const char* rtpengine_rpc_get_hash_total_doc[2] = {
+	"Get total number of entries in hash table", 0
+};
 
-			// success reloading from database
-			root = init_mi_tree(200, MI_DB_OK, MI_DB_OK_LEN);
-			if (!root) {
-				LM_ERR("the MI tree cannot be initialized!\n");
-				return 0;
-			}
-		}
-	}
+rpc_export_t rtpengine_rpc[] = {
+	{"rtpengine.reload", rtpengine_rpc_reload, rtpengine_rpc_reload_doc, 0},
+	{"rtpengine.ping", rtpengine_rpc_ping, rtpengine_rpc_ping_doc, 0},
+	{"rtpengine.show", rtpengine_rpc_show, rtpengine_rpc_show_doc, RET_ARRAY},
+	{"rtpengine.enable", rtpengine_rpc_enable, rtpengine_rpc_enable_doc, 0},
+	{"rtpengine.get_hash_total", rtpengine_rpc_get_hash_total, rtpengine_rpc_get_hash_total_doc, 0},
+	{0, 0, 0, 0}
+};
 
-	return root;
+static int rtpengine_rpc_init(void)
+{
+	if (rpc_register_array(rtpengine_rpc)!=0)
+	{
+		LM_ERR("failed to register RPC commands\n");
+		return -1;
+	}
+	return 0;
 }
 
-
 static int
 mod_init(void)
 {
@@ -1624,9 +1286,9 @@
 	unsigned short avp_flags;
 	str s;
 
-	if(register_mi_mod(exports.name, mi_cmds)!=0)
+	if(rtpengine_rpc_init()<0)
 	{
-		LM_ERR("failed to register MI commands\n");
+		LM_ERR("failed to register RPC commands\n");
 		return -1;
 	}
 
@@ -1757,11 +1419,6 @@
 	if (rtpp_strings)
 		pkg_free(rtpp_strings);
 
-	if ((queried_nodes_limit < 1) || (queried_nodes_limit > MAX_RTPP_TRIED_NODES)) {
-		LM_ERR("queried_nodes_limit must be a number in the range 1..50 \n");
-		return -1;
-	}
-
 	if (load_tm_api( &tmb ) < 0)
 	{
 		LM_DBG("could not load the TM-functions - answer-offer model"
@@ -1932,12 +1589,12 @@
 	memset(rtpp_socks, -1, sizeof(int)*(rtpp_socks_size));
 
 	// vector of pointers to queried nodes
-	queried_nodes_ptr = (struct rtpp_node**)pkg_malloc(queried_nodes_limit * sizeof(struct rtpp_node*));
+	queried_nodes_ptr = (struct rtpp_node**)pkg_malloc(MAX_RTPP_TRIED_NODES * sizeof(struct rtpp_node*));
 	if (!queried_nodes_ptr) {
 		LM_ERR("no more pkg memory for queried_nodes_ptr\n");
 		return -1;
 	}
-	memset(queried_nodes_ptr, 0, queried_nodes_limit * sizeof(struct rtpp_node*));
+	memset(queried_nodes_ptr, 0, MAX_RTPP_TRIED_NODES * sizeof(struct rtpp_node*));
 
 	/* Iterate known RTP proxies - create sockets */
 	if (rtpp_socks_size) {
@@ -2171,8 +1828,6 @@
 						ng_flags->via = 3;
 					else if (str_eq(&val, "extra"))
 						ng_flags->via = -1;
-					else if (str_eq(&val, "next"))
-						ng_flags->via = -2;
 					else
 						goto error;
 					goto next;
@@ -2242,8 +1897,6 @@
 	struct rtpp_node *node;
 	char *cp;
 	pv_value_t pv_val;
-	char md5[MD5_LEN];
-	char branch_buf[MAX_BRANCH_PARAM_LEN];
 
 	/*** get & init basic stuff needed ***/
 
@@ -2316,30 +1969,12 @@
 	bencode_dictionary_add_str(ng_flags.dict, "call-id", &callid);
 
 	if (ng_flags.via) {
-		ret = -1;
-		switch (ng_flags.via) {
-			case 3:
-				ng_flags.via = (msg->first_line.type == SIP_REPLY) ? 2 : 1;
-				/* fall thru */
-			case 1:
-			case 2:
-				ret = get_via_branch(msg, ng_flags.via, &viabranch);
-				break;
-			case -1:
-				if (extra_id_pv)
-					ret = get_extra_id(msg, &viabranch);
-				break;
-			case -2:
-				if (!char_msg_val(msg, md5))
-					break;
-				msg->hash_index = hash(msg->callid->body, get_cseq(msg)->number);
-
-				viabranch.s = branch_buf;
-				if (branch_builder(msg->hash_index, 0, md5, 0, branch_buf, &viabranch.len))
-					ret = 0;
-				break;
-		}
-
+		if (ng_flags.via == 1 || ng_flags.via == 2)
+			ret = get_via_branch(msg, ng_flags.via, &viabranch);
+		else if (ng_flags.via == -1 && extra_id_pv)
+			ret = get_extra_id(msg, &viabranch);
+		else
+			ret = -1;
 		if (ret == -1 || viabranch.len == 0) {
 			LM_ERR("can't get Via branch/extra ID\n");
 			goto error;
@@ -2536,7 +2171,7 @@
 	char *cp;
 	int ret;
 
-	if(node->rn_recheck_ticks == MI_MAX_RECHECK_TICKS){
+	if(node->rn_recheck_ticks == RTPENGINE_MAX_RECHECK_TICKS){
 		LM_DBG("rtpp %s disabled for ever\n", node->rn_url.s);
 		return 1;
 	}
@@ -2588,6 +2223,7 @@
 {
 	struct sockaddr_un addr;
 	int fd, len, i, vcnt;
+	int rtpengine_retr, rtpengine_tout_ms = 1000;
 	char *cp;
 	static char buf[0x10000];
 	struct pollfd fds[1];
@@ -2650,6 +2286,7 @@
 		}
 		v[0].iov_base = gencookie();
 		v[0].iov_len = strlen(v[0].iov_base);
+        rtpengine_retr = rtpengine_retr;
 		for (i = 0; i < rtpengine_retr; i++) {
 			do {
 				len = writev(rtpp_socks[node->idx], v, vcnt + 1);
@@ -2659,6 +2296,7 @@
 				LM_ERR("can't send command \"%.*s\" to RTP proxy <%s>\n", out.len, out.s, node->rn_url.s);
 				goto badproxy;
 			}
+            rtpengine_tout_ms = rtpengine_tout_ms;
 			while ((poll(fds, 1, rtpengine_tout_ms) == 1) &&
 				(fds[0].revents & POLLIN) != 0) {
 				do {
@@ -2910,7 +2548,7 @@
 
 	// if proper configuration and node manually or timeout disabled, return it
 	if (rtpengine_allow_op) {
-		if (node->rn_recheck_ticks == MI_MAX_RECHECK_TICKS) {
+		if (node->rn_recheck_ticks == RTPENGINE_MAX_RECHECK_TICKS) {
 			LM_DBG("node=%.*s for calllen=%d callid=%.*s is disabled(permanent) (probably still UP)! Return it\n",
 				node->rn_url.len, node->rn_url.s, callid.len, callid.len, callid.s);
 		} else {
@@ -3212,7 +2850,7 @@
 }
 
 static int
-rtpengine_offer_answer(struct sip_msg *msg, const char *flags, enum rtpe_operation op, int more)
+rtpengine_offer_answer(struct sip_msg *msg, const char *flags, int op, int more)
 {
 	bencode_buffer_t bencbuf;
 	bencode_item_t *dict;
--- a/modules/rtpengine/rtpengine.h
+++ b/modules/rtpengine/rtpengine.h
@@ -27,8 +27,8 @@
 #include "../../str.h"
 #include "../../locking.h"
 
-#define MI_MIN_RECHECK_TICKS		0
-#define MI_MAX_RECHECK_TICKS		((unsigned int)-1)
+#define RTPENGINE_MIN_RECHECK_TICKS		0
+#define RTPENGINE_MAX_RECHECK_TICKS		((unsigned int)-1)
 
 enum rtpe_operation {
         OP_OFFER = 1,
--- a/modules/rtpengine/rtpengine_db.c
+++ b/modules/rtpengine/rtpengine_db.c
@@ -111,7 +111,7 @@
 		weight = VAL_INT(values+2);
 		disabled = VAL_INT(values+3);
 		if (disabled) {
-			ticks = MI_MAX_RECHECK_TICKS;
+			ticks = RTPENGINE_MAX_RECHECK_TICKS;
 		} else {
 			ticks = 0;
 		}
