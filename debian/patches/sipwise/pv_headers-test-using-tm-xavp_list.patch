From: Victor Seva <vseva@sipwise.com>
Date: Fri, 17 Jan 2020 10:30:24 +0100
Subject: pv_headers: test using tm xavp_list

Change-Id: I68070aac0ad8dc97205e2669c4dbfa62eefe5073
---
 src/modules/pv_headers/pv_headers.c | 158 ++++++++++++++++++++++++++----------
 1 file changed, 114 insertions(+), 44 deletions(-)

diff --git a/src/modules/pv_headers/pv_headers.c b/src/modules/pv_headers/pv_headers.c
index 4d41b55..1d256f0 100644
--- a/src/modules/pv_headers/pv_headers.c
+++ b/src/modules/pv_headers/pv_headers.c
@@ -90,6 +90,7 @@ static int mod_init(void);
 
 static void handle_tm_t(tm_cell_t *t, int type, struct tmcb_params* params);
 static int  handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb);
+static int  handle_msg_reply_cb(struct sip_msg *msg, unsigned int flags, void *cb);
 
 static int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2);
 static int pv_apply_headers(struct sip_msg *msg, char *is_auto, char *_s2);
@@ -220,10 +221,15 @@ int mod_init(void)
         LM_NOTICE("could not bind to the 'tm' module, automatic headers collect/apply is disabled\n");
         auto_msg_param = 0;
     } else {
-        if (auto_msg_param &&
-            register_script_cb(handle_msg_cb, PRE_SCRIPT_CB|REQUEST_CB|ONREPLY_CB, 0) < 0) {
+        if (auto_msg_param) {
+            if(register_script_cb(handle_msg_cb, PRE_SCRIPT_CB|REQUEST_CB, 0) < 0) {
                 LM_ERR("cannot register PRE_SCRIPT_CB callbacks\n");
                 return -1;
+            }
+            if(register_script_cb(handle_msg_reply_cb, PRE_SCRIPT_CB|ONREPLY_CB, 0) < 0) {
+                LM_ERR("cannot register ONREPLY_CB callbacks\n");
+                return -1;
+            }
         }
     }
 
@@ -273,15 +279,11 @@ int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb)
 {
     int cbs = TMCB_REQUEST_FWDED | TMCB_RESPONSE_FWDED | TMCB_RESPONSE_IN | TMCB_ON_BRANCH_FAILURE;
 
-    if (flags & (PRE_SCRIPT_CB|REQUEST_CB|ONREPLY_CB)) {
-        if (tmb.register_tmcb( msg, 0, cbs, handle_tm_t, 0, 0) <=0) {
-            LM_ERR("cannot register TM callbacks\n");
-            return -1;
-        }
-        pv_collect_headers(msg, "1", NULL);
-    } else {
-        LM_ERR("unknown callback: %d\n", flags);
+    if (tmb.register_tmcb( msg, 0, cbs, handle_tm_t, 0, 0) <=0) {
+        LM_ERR("cannot register TM callbacks\n");
+        return -1;
     }
+    pv_collect_headers(msg, "1", NULL);
 
     return 1;
 }
@@ -290,38 +292,111 @@ int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb)
  * We keep a $xavp(xavp_name=>reply_counter) with the number of replies
  * so we will use $xavp(xavp_name.r.<id>) on reply_route
  */
+int pvh_reply_init(int value)
+{
+    sr_xavp_t *xavp = NULL;
+    sr_xval_t xval;
+
+    memset(&xval, 0, sizeof(sr_xval_t));
+    xval.type = SR_XTYPE_INT;
+    xval.v.i = value;
+
+    xavp = xavp_get(&xavp_name, NULL);
+    if(xavp == NULL) {
+        if(xavp_add_xavp_value(&xavp_name, &reply_counter, &xval, NULL) == NULL) {
+            LM_ERR("can't create xavp:%.*s\n", xavp_name.len, xavp_name.s);
+            return -1;
+        }
+        LM_DBG("xavp_name:%.*s created\n", xavp_name.len, xavp_name.s);
+    } else {
+        if(xavp_set_value(&reply_counter, 0, &xval, &xavp->val.v.xavp) == NULL) {
+            LM_ERR("can't set reply_counter value\n");
+            return -1;
+        }
+        LM_DBG("added value\n");
+    }
+    LM_DBG("reply message: %d\n", xval.v.i);
+    return xval.v.i;
+}
+
 int pvh_reply_append(void)
 {
-	sr_xavp_t *xavp = NULL;
-	sr_xval_t xval;
-
-	xavp = xavp_get_child_with_ival(&xavp_name, &reply_counter);
-	if(xavp) {
-		xavp->val.v.i++;
-		LM_DBG("reply message: %d\n", xavp->val.v.i);
-		return 1;
-	}
+    sr_xavp_t *xavp = NULL;
+    sr_xval_t xval;
 
-	memset(&xval, 0, sizeof(sr_xval_t));
-	xval.type = SR_XTYPE_INT;
-	xval.v.i = 0;
+    xavp = xavp_get_child_with_ival(&xavp_name, &reply_counter);
+    if(xavp) {
+        xavp->val.v.i++;
+        LM_DBG("reply message: %d\n", xavp->val.v.i);
+        return xavp->val.v.i;
+    }
 
-	xavp = xavp_get(&xavp_name, NULL);
-	if(xavp == NULL) {
-		if(xavp_add_xavp_value(&xavp_name, &reply_counter, &xval, NULL) == NULL) {
-			LM_ERR("can't create xavp:%.*s\n", xavp_name.len, xavp_name.s);
-			return -1;
-		}
-		LM_DBG("xavp_name:%.*s created\n", xavp_name.len, xavp_name.s);
-	} else {
-		if(xavp_add_value(&reply_counter, &xval, &xavp) == NULL) {
-			LM_ERR("can't add reply_counter value\n");
-			return -1;
-		}
-		LM_DBG("added value\n");
-	}
-	LM_DBG("reply message: %d\n", xval.v.i);
-	return 1;
+    memset(&xval, 0, sizeof(sr_xval_t));
+    xval.type = SR_XTYPE_INT;
+    xval.v.i = 0;
+
+    xavp = xavp_get(&xavp_name, NULL);
+    if(xavp == NULL) {
+        if(xavp_add_xavp_value(&xavp_name, &reply_counter, &xval, NULL) == NULL) {
+            LM_ERR("can't create xavp:%.*s\n", xavp_name.len, xavp_name.s);
+            return -1;
+        }
+        LM_DBG("xavp_name:%.*s created\n", xavp_name.len, xavp_name.s);
+    } else {
+        if(xavp_add_value(&reply_counter, &xval, &xavp->val.v.xavp) == NULL) {
+            LM_ERR("can't add reply_counter value\n");
+            return -1;
+        }
+        LM_DBG("added value\n");
+    }
+    LM_DBG("reply message: %d\n", xval.v.i);
+    return xval.v.i;
+}
+
+int handle_msg_reply_cb(struct sip_msg *msg, unsigned int flags, void *cb)
+{
+    tm_cell_t *t = NULL;
+    int branch;
+    sr_xavp_t **backup_xavps = NULL;
+    int backup_m_flags = msg->msg_flags;
+    int reply_count;
+
+    if(likely(!(msg->msg_flags&FL_TM_RPL_MATCHED))) {
+        msg->msg_flags |= FL_TM_RPL_MATCHED;
+        LM_DBG("fake FL_TM_RPL_MATCHED, to skip tm_cb TMCB_RESPONSE_IN\n");
+    }
+
+    if (tmb.t_check(msg, &branch) == -1) {
+        LM_ERR("failed find UAC branch\n");
+    }
+    else {
+        t = tmb.t_gett();
+        if(t == NULL || t == T_UNDEFINED) {
+           LM_DBG("cannot lookup the transaction\n");
+        } else {
+           LM_DBG("T:%p branch:%d\n", t, branch);
+           backup_xavps = xavp_set_list(&t->xavps_list);
+        }
+    }
+
+    if(msg->msg_flags != backup_m_flags) {
+        msg->msg_flags = backup_m_flags;
+        LM_DBG("restored msg_flags\n");
+    }
+    if((reply_count = pvh_reply_append()) < 0) {
+        return -1;
+    }
+
+    pv_collect_headers(msg, "1", NULL);
+    if(backup_xavps) {
+        xavp_set_list(backup_xavps);
+        LM_DBG("restored backup_xavps\n");
+        if(pvh_reply_init(reply_count) < 0) {
+            return -1;
+        }
+    }
+
+    return 1;
 }
 
 int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2)
@@ -343,10 +418,6 @@ int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2)
             return -1;
     }
 
-    if(msg->first_line.type == SIP_REPLY) {
-        pvh_reply_append();
-    }
-
     if (parse_headers(msg, HDR_EOH_F, 0) < 0) {
         LM_ERR("error parsing headers\n");
         return -1;
@@ -394,7 +465,6 @@ int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2)
         if (pv_set_xavp(msg, &xavp_name, &name, &val, SR_XTYPE_STR, 0, 1) < 0)
             goto err;
     }
-
     if (pv_set_xavp(msg, &xavp_helper_xname, &xavp_helper_name, &xavp_name, SR_XTYPE_STR, 0, 0) < 0)
         goto err;
 
@@ -2107,7 +2177,7 @@ int pv_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
     }
     if (msg->first_line.type == SIP_REPLY) {
         xavp = xavp_get_child_with_ival(&xavp_name, &reply_counter);
-		if(!xavp) {
+		if(xavp==NULL) {
 			LM_DBG("no %.*s=>%.*s found, this should not happend\n",
 				xavp_name.len, xavp_name.s,
 				reply_counter.len, reply_counter.s);
