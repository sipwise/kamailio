From: Victor Seva <vseva@sipwise.com>
Date: Fri, 17 Jan 2020 10:30:24 +0100
Subject: pv_headers: test using tm xavp_list

Change-Id: Icae89c47a8e91902302e8ffff517595a0797f535
---
 src/modules/pv_headers/pv_headers.c | 63 ++++++++++++++++++++++++++++++-------
 1 file changed, 51 insertions(+), 12 deletions(-)

diff --git a/src/modules/pv_headers/pv_headers.c b/src/modules/pv_headers/pv_headers.c
index 4d41b55..d602592 100644
--- a/src/modules/pv_headers/pv_headers.c
+++ b/src/modules/pv_headers/pv_headers.c
@@ -90,6 +90,7 @@ static int mod_init(void);
 
 static void handle_tm_t(tm_cell_t *t, int type, struct tmcb_params* params);
 static int  handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb);
+static int  handle_msg_reply_cb(struct sip_msg *msg, unsigned int flags, void *cb);
 
 static int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2);
 static int pv_apply_headers(struct sip_msg *msg, char *is_auto, char *_s2);
@@ -220,10 +221,15 @@ int mod_init(void)
         LM_NOTICE("could not bind to the 'tm' module, automatic headers collect/apply is disabled\n");
         auto_msg_param = 0;
     } else {
-        if (auto_msg_param &&
-            register_script_cb(handle_msg_cb, PRE_SCRIPT_CB|REQUEST_CB|ONREPLY_CB, 0) < 0) {
+        if (auto_msg_param) {
+            if(register_script_cb(handle_msg_cb, PRE_SCRIPT_CB|REQUEST_CB, 0) < 0) {
                 LM_ERR("cannot register PRE_SCRIPT_CB callbacks\n");
                 return -1;
+            }
+            if(register_script_cb(handle_msg_reply_cb, ONREPLY_CB, 0) < 0) {
+                LM_ERR("cannot register ONREPLY_CB callbacks\n");
+                return -1;
+            }
         }
     }
 
@@ -273,14 +279,48 @@ int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb)
 {
     int cbs = TMCB_REQUEST_FWDED | TMCB_RESPONSE_FWDED | TMCB_RESPONSE_IN | TMCB_ON_BRANCH_FAILURE;
 
-    if (flags & (PRE_SCRIPT_CB|REQUEST_CB|ONREPLY_CB)) {
-        if (tmb.register_tmcb( msg, 0, cbs, handle_tm_t, 0, 0) <=0) {
-            LM_ERR("cannot register TM callbacks\n");
-            return -1;
+    if (tmb.register_tmcb( msg, 0, cbs, handle_tm_t, 0, 0) <=0) {
+        LM_ERR("cannot register TM callbacks\n");
+        return -1;
+    }
+    pv_collect_headers(msg, "1", NULL);
+
+    return 1;
+}
+
+int handle_msg_reply_cb(struct sip_msg *msg, unsigned int flags, void *cb)
+{
+    tm_cell_t *t = NULL;
+    int branch;
+    sr_xavp_t **backup_xavps = NULL;
+    int backup_m_flags = msg->msg_flags;
+
+    if(likely(!(msg->msg_flags&FL_TM_RPL_MATCHED))) {
+        msg->msg_flags |= FL_TM_RPL_MATCHED;
+        LM_DBG("fake FL_TM_RPL_MATCHED, to skip tm_cb TMCB_RESPONSE_IN\n");
+    }
+
+    if (tmb.t_check(msg, &branch) == -1) {
+        LM_ERR("failed find UAC branch\n");
+    }
+    else {
+        t = tmb.t_gett();
+        if(t == NULL || t == T_UNDEFINED) {
+           LM_DBG("cannot lookup the transaction\n");
+        } else {
+           LM_DBG("T:%p branch:%d\n", t, branch);
+           backup_xavps = xavp_set_list(&t->xavps_list);
         }
-        pv_collect_headers(msg, "1", NULL);
-    } else {
-        LM_ERR("unknown callback: %d\n", flags);
+    }
+
+    if(msg->msg_flags != backup_m_flags) {
+        msg->msg_flags = backup_m_flags;
+        LM_DBG("restored msg_flags\n");
+    }
+    pv_collect_headers(msg, "1", NULL);
+    if(backup_xavps) {
+        xavp_set_list(backup_xavps);
+        LM_DBG("restored backup_xavps\n");
     }
 
     return 1;
@@ -314,7 +354,7 @@ int pvh_reply_append(void)
 		}
 		LM_DBG("xavp_name:%.*s created\n", xavp_name.len, xavp_name.s);
 	} else {
-		if(xavp_add_value(&reply_counter, &xval, &xavp) == NULL) {
+		if(xavp_add_value(&reply_counter, &xval, &xavp->val.v.xavp) == NULL) {
 			LM_ERR("can't add reply_counter value\n");
 			return -1;
 		}
@@ -394,7 +434,6 @@ int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2)
         if (pv_set_xavp(msg, &xavp_name, &name, &val, SR_XTYPE_STR, 0, 1) < 0)
             goto err;
     }
-
     if (pv_set_xavp(msg, &xavp_helper_xname, &xavp_helper_name, &xavp_name, SR_XTYPE_STR, 0, 0) < 0)
         goto err;
 
@@ -2107,7 +2146,7 @@ int pv_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
     }
     if (msg->first_line.type == SIP_REPLY) {
         xavp = xavp_get_child_with_ival(&xavp_name, &reply_counter);
-		if(!xavp) {
+		if(xavp==NULL) {
 			LM_DBG("no %.*s=>%.*s found, this should not happend\n",
 				xavp_name.len, xavp_name.s,
 				reply_counter.len, reply_counter.s);
