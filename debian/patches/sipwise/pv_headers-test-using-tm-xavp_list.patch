From: Victor Seva <vseva@sipwise.com>
Date: Fri, 17 Jan 2020 10:30:24 +0100
Subject: pv_headers: test using tm xavp_list

Change-Id: Icae89c47a8e91902302e8ffff517595a0797f535
---
 src/modules/pv_headers/pv_headers.c | 75 ++++++++++++++++++++++++++++++++-----
 1 file changed, 65 insertions(+), 10 deletions(-)

diff --git a/src/modules/pv_headers/pv_headers.c b/src/modules/pv_headers/pv_headers.c
index 4d41b55..737f668 100644
--- a/src/modules/pv_headers/pv_headers.c
+++ b/src/modules/pv_headers/pv_headers.c
@@ -272,20 +272,71 @@ void handle_tm_t(tm_cell_t *t, int type, struct tmcb_params* params)
 int handle_msg_cb(struct sip_msg *msg, unsigned int flags, void *cb)
 {
     int cbs = TMCB_REQUEST_FWDED | TMCB_RESPONSE_FWDED | TMCB_RESPONSE_IN | TMCB_ON_BRANCH_FAILURE;
+    tm_cell_t *t = NULL;
+    int branch;
+    sr_xavp_t **backup_xavps = NULL;
+    int backup_m_flags = msg->msg_flags;
 
-    if (flags & (PRE_SCRIPT_CB|REQUEST_CB|ONREPLY_CB)) {
-        if (tmb.register_tmcb( msg, 0, cbs, handle_tm_t, 0, 0) <=0) {
-            LM_ERR("cannot register TM callbacks\n");
-            return -1;
+    if(flags&ONREPLY_CB) {
+        LM_DBG("ONREPLY_CB\n");
+    }
+    if(flags&REQUEST_CB) {
+        LM_DBG("REQUEST_CB\n");
+    }
+
+    if(likely(!(msg->msg_flags&FL_TM_RPL_MATCHED))) {
+        msg->msg_flags |= FL_TM_RPL_MATCHED;
+        LM_DBG("fake FL_TM_RPL_MATCHED, to skip tm_cb TMCB_RESPONSE_IN\n");
+    }
+
+    if (tmb.t_check(msg, &branch) == -1) {
+        LM_ERR("failed find UAC branch\n");
+    }
+    else {
+        t = tmb.t_gett();
+        if(t == NULL || t == T_UNDEFINED) {
+           LM_DBG("cannot lookup the transaction\n");
+        } else {
+           LM_DBG("T:%p branch:%d\n", t, branch);
+           backup_xavps = xavp_set_list(&t->xavps_list);
         }
-        pv_collect_headers(msg, "1", NULL);
-    } else {
-        LM_ERR("unknown callback: %d\n", flags);
+    }
+
+    if(msg->msg_flags != backup_m_flags) {
+        msg->msg_flags = backup_m_flags;
+        LM_DBG("restored msg_flags\n");
+    }
+
+    if (tmb.register_tmcb( msg, 0, cbs, handle_tm_t, 0, 0) <=0) {
+        LM_ERR("cannot register TM callbacks\n");
+        return -1;
+    }
+    pv_collect_headers(msg, "1", NULL);
+    if(backup_xavps) {
+        xavp_set_list(backup_xavps);
+        LM_DBG("restored backup_xavps\n");
     }
 
     return 1;
 }
 
+void pvh_check_reply_counter(struct sip_msg *msg) {
+    sr_xavp_t *xavp = NULL;
+
+    if(msg && msg->first_line.type != SIP_REPLY) {
+        return;
+    }
+
+    xavp = xavp_get_child_with_ival(&xavp_name, &reply_counter);
+    if(xavp==NULL) {
+        LM_DBG("no %.*s=>%.*s found, this should not happend\n",
+                xavp_name.len, xavp_name.s,
+                reply_counter.len, reply_counter.s);
+    } else {
+        LM_DBG("OK: %d\n", xavp->val.v.i);
+    }
+}
+
 /**
  * We keep a $xavp(xavp_name=>reply_counter) with the number of replies
  * so we will use $xavp(xavp_name.r.<id>) on reply_route
@@ -314,13 +365,14 @@ int pvh_reply_append(void)
 		}
 		LM_DBG("xavp_name:%.*s created\n", xavp_name.len, xavp_name.s);
 	} else {
-		if(xavp_add_value(&reply_counter, &xval, &xavp) == NULL) {
+		if(xavp_add_value(&reply_counter, &xval, &xavp->val.v.xavp) == NULL) {
 			LM_ERR("can't add reply_counter value\n");
 			return -1;
 		}
 		LM_DBG("added value\n");
 	}
 	LM_DBG("reply message: %d\n", xval.v.i);
+    pvh_check_reply_counter(NULL);
 	return 1;
 }
 
@@ -391,12 +443,15 @@ int pv_collect_headers(struct sip_msg *msg, char *is_auto, char *_s2)
             }
             continue;
         }
+        pvh_check_reply_counter(msg);
         if (pv_set_xavp(msg, &xavp_name, &name, &val, SR_XTYPE_STR, 0, 1) < 0)
             goto err;
+        pvh_check_reply_counter(msg);
     }
-
+    pvh_check_reply_counter(msg);
     if (pv_set_xavp(msg, &xavp_helper_xname, &xavp_helper_name, &xavp_name, SR_XTYPE_STR, 0, 0) < 0)
         goto err;
+    pvh_check_reply_counter(msg);
 
     pv_str_free(&name);
     pv_str_free(&val);
@@ -2107,7 +2162,7 @@ int pv_get_branch_xname(struct sip_msg *msg, str *xname, str *dst)
     }
     if (msg->first_line.type == SIP_REPLY) {
         xavp = xavp_get_child_with_ival(&xavp_name, &reply_counter);
-		if(!xavp) {
+		if(xavp==NULL) {
 			LM_DBG("no %.*s=>%.*s found, this should not happend\n",
 				xavp_name.len, xavp_name.s,
 				reply_counter.len, reply_counter.s);
