--- a/src/modules/topos_redis/topos_redis_storage.c
+++ b/src/modules/topos_redis/topos_redis_storage.c
@@ -677,7 +677,7 @@ int tps_redis_load_invite_branch(sip_msg
 				&& strncmp(skey.s, tt_key_x_vbranch.s, skey.len)==0) {
 			TPS_REDIS_DATA_APPEND(sd, &skey, &sval, &sd->x_vbranch1);
 		} else {
-			LM_INFO("unuseful key[%.*s]\n", skey.len, skey.s);
+			LM_INFO("useless key[%.*s]\n", skey.len, skey.s);
 		}
 	}
 
@@ -879,7 +879,7 @@ int tps_redis_load_branch(sip_msg_t *msg
 				&& strncmp(skey.s, tt_key_b_tag.s, skey.len)==0) {
 			TPS_REDIS_DATA_APPEND(sd, &skey, &sval, &sd->b_tag);
 		} else {
-			LM_WARN("unknow key[%.*s]\n", skey.len, skey.s);
+			LM_WARN("unknown key[%.*s]\n", skey.len, skey.s);
 		}
 	}
 
@@ -1084,7 +1084,7 @@ int tps_redis_load_dialog(sip_msg_t *msg
 				&& strncmp(skey.s, td_key_s_cseq.s, skey.len)==0) {
 			TPS_REDIS_DATA_APPEND(sd, &skey, &sval, &sd->s_cseq);
 		} else {
-			LM_WARN("unknow key[%.*s]\n", skey.len, skey.s);
+			LM_WARN("unknown key[%.*s]\n", skey.len, skey.s);
 		}
 	}
 
--- a/src/modules/topos/README
+++ b/src/modules/topos/README
@@ -33,10 +33,12 @@ Daniel-Constantin Mierla
               3.6. dialog_expire (int)
               3.7. clean_interval (int)
               3.8. event_callback (str)
+              3.9. event_mode (int)
 
         4. Event Routes
 
               4.1. event_route[topos:msg-outgoing]
+              4.2. event_route[topos:msg-sending]
 
    List of Examples
 
@@ -48,7 +50,9 @@ Daniel-Constantin Mierla
    1.6. Set dialog_expire parameter
    1.7. Set clean_interval parameter
    1.8. Set event_callback parameter
-   1.9. Usage of event_route[topos:msg-outgoing]
+   1.9. Set event_mode parameter
+   1.10. Usage of event_route[topos:msg-outgoing]
+   1.11. Usage of event_route[topos:msg-sending]
 
 Chapter 1. Admin Guide
 
@@ -70,10 +74,12 @@ Chapter 1. Admin Guide
         3.6. dialog_expire (int)
         3.7. clean_interval (int)
         3.8. event_callback (str)
+        3.9. event_mode (int)
 
    4. Event Routes
 
         4.1. event_route[topos:msg-outgoing]
+        4.2. event_route[topos:msg-sending]
 
 1. Overview
 
@@ -84,7 +90,10 @@ Chapter 1. Admin Guide
    The module is transparent for the configuration writer. It only needs
    to be loaded (tune the parameters if needed).
 
-   It works for SIP MESSAGE requests.
+   It also works for SIP MESSAGE or other requests that do not create a
+   call dialog -- record_route() must be used for them as well, the
+   headers are not going to be in the messages sent to the network, they
+   are needed to know local addresses used to communicate with each side.
 
 2. Dependencies
 
@@ -95,7 +104,8 @@ Chapter 1. Admin Guide
 
    The following modules must be loaded before this module:
      * rr module - server must perform record routing to ensure in-dialog
-       requests are encoded/decoded.
+       requests are encoded/decoded (it must be done for all initial
+       requests).
      * database module - to store the data for topology stripping and
        restoring.
 
@@ -115,6 +125,7 @@ Chapter 1. Admin Guide
    3.6. dialog_expire (int)
    3.7. clean_interval (int)
    3.8. event_callback (str)
+   3.9. event_mode (int)
 
 3.1. storage (str)
 
@@ -159,7 +170,7 @@ modparam("topos", "mask_callid", 1)
 
    If set to 1, topoh module will bind to sanity module in order to
    perform sanity checks over received SIP request. Default sanity checks
-   are done. It is useful to check if received request is well formated
+   are done. It is useful to check if received request is well formatted
    before proceeding to encoding/decoding.
 
    Default value is 0 (do not bind to sanity module).
@@ -223,9 +234,23 @@ function ksr_topos_event(evname)
 end
 ...
 
+3.9. event_mode (int)
+
+   Control what event_route blocks to be executed. It is a bitmask of: 1 -
+   execute event_route[topos:outgoing]; 2 - execute
+   event_route[topos:sending].
+
+   Default value is 3 (execute both event_route blocks).
+
+   Example 1.9. Set event_mode parameter
+...
+modparam("topos", "event_mode", 2)
+...
+
 4. Event Routes
 
    4.1. event_route[topos:msg-outgoing]
+   4.2. event_route[topos:msg-sending]
 
 4.1. event_route[topos:msg-outgoing]
 
@@ -239,11 +264,30 @@ end
    reparsing the outgoing SIP message for the cases when topology hiding
    is not wanted.
 
-   Example 1.9. Usage of event_route[topos:msg-outgoing]
+   Example 1.10. Usage of event_route[topos:msg-outgoing]
 ...
 event_route[topos:msg-outgoing] {
   if($sndto(ip)=="10.1.1.10") {
     drop;
   }
 }
+...
+
+4.2. event_route[topos:msg-sending]
+
+   It is executed before doing topology stripping processing for a SIP
+   message to be sent out, being executed after
+   event_route[topos:sending].
+
+   Inside the event route the variables $sndto(ip), $sndto(port) and
+   $sndto(proto) point to the destination. The SIP message is the one to
+   be sent out.
+
+   Example 1.11. Usage of event_route[topos:msg-sending]
+...
+event_route[topos:msg-sending] {
+  if(is_request() and $fU=="alice") {
+    drop;
+  }
+}
 ...
--- a/src/modules/topos/doc/topos_admin.xml
+++ b/src/modules/topos/doc/topos_admin.xml
@@ -153,7 +153,7 @@ modparam("topos", "mask_callid", 1)
 			If set to 1, topoh module will bind to sanity module in order
 			to perform sanity checks over received SIP request. Default
 			sanity checks are done. It is useful to check if received request
-			is well formated before proceeding to encoding/decoding.
+			is well formatted before proceeding to encoding/decoding.
 		</para>
 		<para>
 		<emphasis>
@@ -257,10 +257,31 @@ end
 </programlisting>
 		</example>
 	</section>
+	<section id="topos.p.event_mode">
+		<title><varname>event_mode</varname> (int)</title>
+		<para>
+			Control what event_route blocks to be executed. It is a bitmask of:
+			1 - execute event_route[topos:outgoing]; 2 - execute
+			event_route[topos:sending].
+		</para>
+		<para>
+		<emphasis>
+			Default value is 3 (execute both event_route blocks).
+		</emphasis>
+		</para>
+		<example>
+		<title>Set <varname>event_mode</varname> parameter</title>
+		<programlisting format="linespecific">
+...
+modparam("topos", "event_mode", 2)
+...
+</programlisting>
+		</example>
+	</section>
 	</section>
 	<section>
 	<title>Event Routes</title>
-	<section>
+	<section id="topos.e.msg_outgoing">
 		<title>event_route[topos:msg-outgoing]</title>
 		<para>
 		It is executed before doing topology stripping processing for an outgoing
@@ -283,6 +304,30 @@ event_route[topos:msg-outgoing] {
     drop;
   }
 }
+...
+</programlisting>
+		</example>
+	</section>
+	<section id="topos.e.msg_sending">
+		<title>event_route[topos:msg-sending]</title>
+		<para>
+		It is executed before doing topology stripping processing for a SIP
+		message to be sent out, being executed after event_route[topos:sending].
+		</para>
+		<para>
+		Inside the event route the variables $sndto(ip), $sndto(port) and
+		$sndto(proto) point to the destination. The SIP message is the one
+		to be sent out.
+		</para>
+		<example>
+		<title>Usage of event_route[topos:msg-sending]</title>
+		<programlisting format="linespecific">
+...
+event_route[topos:msg-sending] {
+  if(is_request() and $fU=="alice") {
+    drop;
+  }
+}
 ...
 </programlisting>
 		</example>
--- a/src/modules/topos/topos_mod.c
+++ b/src/modules/topos/topos_mod.c
@@ -26,11 +26,12 @@
  * Module: \ref topos
  */
 
-/*! \defgroup topoh Kamailio :: Topology stripping
+/*! \defgroup topos Kamailio :: Topology stripping
  *
  * This module removes the SIP routing headers that show topology details.
  * The script interpreter gets the SIP messages with full content, so all
  * existing functionality is preserved.
+ * @{
  */
 
 #include <stdio.h>
@@ -84,16 +85,22 @@ extern int _tps_dialog_expire;
 
 int _tps_clean_interval = 60;
 
+#define TPS_EVENTRT_OUTGOING 1
+#define TPS_EVENTRT_SENDING  2
+static int _tps_eventrt_mode = TPS_EVENTRT_OUTGOING | TPS_EVENTRT_SENDING;
 static int _tps_eventrt_outgoing = -1;
 static str _tps_eventrt_callback = STR_NULL;
-static str _tps_eventrt_name = str_init("topos:msg-outgoing");
+static str _tps_eventrt_outgoing_name = str_init("topos:msg-outgoing");
+static int _tps_eventrt_sending = -1;
+static str _tps_eventrt_sending_name = str_init("topos:msg-sending");
 
 sanity_api_t scb;
 
 int tps_msg_received(sr_event_param_t *evp);
 int tps_msg_sent(sr_event_param_t *evp);
 
-static int tps_execute_event_route(sip_msg_t *msg, sr_event_param_t *evp);
+static int tps_execute_event_route(sip_msg_t *msg, sr_event_param_t *evp,
+		int evtype, int evidx, str *evname);
 
 /** module functions */
 /* Module init function prototype */
@@ -121,6 +128,7 @@ static param_export_t params[]={
 	{"dialog_expire",	PARAM_INT, &_tps_dialog_expire},
 	{"clean_interval",	PARAM_INT, &_tps_clean_interval},
 	{"event_callback",	PARAM_STR, &_tps_eventrt_callback},
+	{"event_mode",		PARAM_STR, &_tps_eventrt_mode},
 	{0,0,0}
 };
 
@@ -146,11 +154,16 @@ struct module_exports exports= {
  */
 static int mod_init(void)
 {
-	_tps_eventrt_outgoing = route_lookup(&event_rt, _tps_eventrt_name.s);
+	_tps_eventrt_outgoing = route_lookup(&event_rt, _tps_eventrt_outgoing_name.s);
 	if(_tps_eventrt_outgoing<0
 			|| event_rt.rlist[_tps_eventrt_outgoing]==NULL) {
 		_tps_eventrt_outgoing = -1;
 	}
+	_tps_eventrt_sending = route_lookup(&event_rt, _tps_eventrt_sending_name.s);
+	if(_tps_eventrt_sending<0
+			|| event_rt.rlist[_tps_eventrt_sending]==NULL) {
+		_tps_eventrt_sending = -1;
+	}
 
 	if(faked_msg_init()<0) {
 		LM_ERR("failed to init fmsg\n");
@@ -374,7 +387,8 @@ int tps_msg_sent(sr_event_param_t *evp)
 
 	obuf = (str*)evp->data;
 
-	if(tps_execute_event_route(NULL, evp)==1) {
+	if(tps_execute_event_route(NULL, evp, TPS_EVENTRT_OUTGOING,
+				_tps_eventrt_outgoing, &_tps_eventrt_outgoing_name)==1) {
 		return 0;
 	}
 
@@ -390,7 +404,14 @@ int tps_msg_sent(sr_event_param_t *evp)
 		goto done;
 	}
 
+	if(tps_execute_event_route(&msg, evp, TPS_EVENTRT_SENDING,
+				_tps_eventrt_sending, &_tps_eventrt_sending_name)==1) {
+		goto done;
+	}
+
 	if(msg.first_line.type==SIP_REQUEST) {
+
+
 		dialog = (get_to(&msg)->tag_value.len>0)?1:0;
 
 		local = 0;
@@ -399,12 +420,9 @@ int tps_msg_sent(sr_event_param_t *evp)
 		}
 
 		if(local==1 && dialog==0) {
-			if((get_cseq(&msg)->method_id) & (METHOD_OPTIONS|METHOD_NOTIFY)) {
-				/* skip local out-of-dialog requests (e.g., keepalive) */
-				goto done;
-			}
-			if(get_cseq(&msg)->method.len==4
-					&& strncmp(get_cseq(&msg)->method.s, "KDMQ", 4)) {
+			if((get_cseq(&msg)->method_id)
+						& (METHOD_OPTIONS|METHOD_NOTIFY|METHOD_KDMQ)) {
+				/* skip local out-of-dialog requests (e.g., keepalive, dmq) */
 				goto done;
 			}
 		}
@@ -445,7 +463,8 @@ int tps_get_branch_expire(void)
 /**
  *
  */
-static int tps_execute_event_route(sip_msg_t *msg, sr_event_param_t *evp)
+static int tps_execute_event_route(sip_msg_t *msg, sr_event_param_t *evp,
+		int evtype, int evidx, str *evname)
 {
 	struct sip_msg *fmsg;
 	struct run_act_ctx ctx;
@@ -453,7 +472,11 @@ static int tps_execute_event_route(sip_m
 	sr_kemi_eng_t *keng = NULL;
 	struct onsend_info onsnd_info = {0};
 
-	if(_tps_eventrt_outgoing<0) {
+	if(!(_tps_eventrt_mode & evtype)) {
+		return 0;
+	}
+
+	if(evidx<0) {
 		if(_tps_eventrt_callback.s!=NULL || _tps_eventrt_callback.len>0) {
 			keng = sr_kemi_eng_get();
 			if(keng==NULL) {
@@ -464,12 +487,12 @@ static int tps_execute_event_route(sip_m
 		}
 	}
 
-	if(_tps_eventrt_outgoing<0 && keng==NULL) {
+	if(evidx<0 && keng==NULL) {
 		return 0;
 	}
 
-	LM_DBG("executing event_route[topos:...] (%d)\n",
-			_tps_eventrt_outgoing);
+	LM_DBG("executing event_route[topos:%.*s] (%d)\n", evname->len, evname->s,
+			evidx);
 	fmsg = faked_msg_next();
 
 	onsnd_info.to = &evp->dst->to;
@@ -488,12 +511,12 @@ static int tps_execute_event_route(sip_m
 	rtb = get_route_type();
 	set_route_type(REQUEST_ROUTE);
 	init_run_actions_ctx(&ctx);
-	if(_tps_eventrt_outgoing>=0) {
-		run_top_route(event_rt.rlist[_tps_eventrt_outgoing], fmsg, &ctx);
+	if(evidx>=0) {
+		run_top_route(event_rt.rlist[evidx], (msg)?msg:fmsg, &ctx);
 	} else {
 		if(keng!=NULL) {
-			if(keng->froute(fmsg, EVENT_ROUTE,
-						&_tps_eventrt_callback, &_tps_eventrt_name)<0) {
+			if(keng->froute((msg)?msg:fmsg, EVENT_ROUTE,
+						&_tps_eventrt_callback, evname)<0) {
 				LM_ERR("error running event route kemi callback\n");
 				p_onsend=NULL;
 				return -1;
@@ -527,4 +550,6 @@ int bind_topos(topos_api_t *api)
 	api->get_branch_expire = tps_get_branch_expire;
 
 	return 0;
-}
\ No newline at end of file
+}
+
+/** @} */
--- a/src/modules/topos/tps_msg.c
+++ b/src/modules/topos/tps_msg.c
@@ -936,7 +936,7 @@ int tps_request_sent(sip_msg_t *msg, int
 	memset(&mtsd, 0, sizeof(tps_data_t));
 	memset(&btsd, 0, sizeof(tps_data_t));
 	memset(&stsd, 0, sizeof(tps_data_t));
-	ptsd = &mtsd;
+	ptsd = NULL;
 
 	if(tps_pack_message(msg, &mtsd)<0) {
 		LM_ERR("failed to extract and pack the headers\n");
@@ -956,14 +956,6 @@ int tps_request_sent(sip_msg_t *msg, int
 
 	tps_storage_lock_get(&lkey);
 
-	if(tps_storage_load_branch(msg, &mtsd, &btsd, 0)!=0) {
-		if(tps_storage_record(msg, ptsd, dialog)<0) {
-			goto error;
-		}
-	} else {
-		ptsd = &btsd;
-	}
-
 	if(dialog!=0) {
 		if(tps_storage_load_dialog(msg, &mtsd, &stsd)==0) {
 			ptsd = &stsd;
@@ -975,6 +967,16 @@ int tps_request_sent(sip_msg_t *msg, int
 		mtsd.direction = direction;
 	}
 
+	if(tps_storage_load_branch(msg, &mtsd, &btsd, 0)!=0) {
+		if(tps_storage_record(msg, &mtsd, dialog, direction)<0) {
+			goto error;
+		}
+	} else {
+		if(ptsd==NULL) ptsd = &btsd;
+	}
+
+	if(ptsd==NULL) ptsd = &mtsd;
+
 	/* local generated requests */
 	if(local) {
 		/* ACK and CANCEL go downstream */
--- a/src/modules/topos/tps_storage.c
+++ b/src/modules/topos/tps_storage.c
@@ -360,6 +360,11 @@ int tps_storage_link_msg(sip_msg_t *msg,
 		}
 	}
 
+	LM_DBG("downstream: %s - acontact: [%.*s] - bcontact: [%.*s]\n",
+			(dir==TPS_DIR_DOWNSTREAM)?"yes":"no",
+			td->a_contact.len, (td->a_contact.len>0)?td->a_contact.s:"",
+			td->b_contact.len, (td->b_contact.len>0)?td->b_contact.s:"");
+
 	return 0;
 
 error:
@@ -369,9 +374,9 @@ error:
 /**
  *
  */
-int tps_storage_record(sip_msg_t *msg, tps_data_t *td, int dialog)
+int tps_storage_record(sip_msg_t *msg, tps_data_t *td, int dialog, int dir)
 {
-	int ret;
+	int ret = -1; /* error if dialog == 0 */
 	str suid;
 
 	if(dialog==0) {
@@ -394,12 +399,12 @@ int tps_storage_record(sip_msg_t *msg, t
 	ret = tps_storage_fill_contact(msg, td, &suid, TPS_DIR_UPSTREAM);
 	if(ret<0) goto error;
 
-	ret = tps_storage_link_msg(msg, td, TPS_DIR_DOWNSTREAM);
+	ret = tps_storage_link_msg(msg, td, dir);
 	if(ret<0) goto error;
-	if(td->as_contact.len <= 0 && td->bs_contact.len <= 0) {
-		LM_WARN("no local address - do record routing for all initial requests\n");
-	}
 	if(dialog==0) {
+		if(td->as_contact.len <= 0 && td->bs_contact.len <= 0) {
+			LM_WARN("no local address - do record routing for all initial requests\n");
+		}
 		ret = _tps_storage_api.insert_dialog(td);
 		if(ret<0) goto error;
 	}
--- a/src/modules/topos/tps_storage.h
+++ b/src/modules/topos/tps_storage.h
@@ -87,7 +87,7 @@ int tps_storage_branch_find(sip_msg_t *m
 int tps_storage_branch_save(sip_msg_t *msg, tps_data_t *td);
 int tps_storage_branch_rm(sip_msg_t *msg, tps_data_t *td);
 
-int tps_storage_record(sip_msg_t *msg, tps_data_t *td, int dialog);
+int tps_storage_record(sip_msg_t *msg, tps_data_t *td, int dialog, int dir);
 int tps_storage_load_branch(sip_msg_t *msg, tps_data_t *md, tps_data_t *sd,
 		uint32_t mode);
 int tps_storage_update_branch(sip_msg_t *msg, tps_data_t *md, tps_data_t *sd,
--- a/src/core/parser/msg_parser.h
+++ b/src/core/parser/msg_parser.h
@@ -74,7 +74,12 @@ typedef enum request_method {
 	METHOD_UPDATE=2048,       /*!< 2048 - 2^11 */
 	METHOD_REFER=4096,        /*!< 4096 - 2^12 */
 	METHOD_PUBLISH=8192,      /*!< 8192 - 2^13 */
-	METHOD_OTHER=16384        /*!< 16384 - 2^14 */
+	METHOD_KDMQ=16384,        /*!< 16384 - 2^14 */
+	METHOD_GET=32768,         /*!< 32768 - 2^15 */
+	METHOD_POST=65536,        /*!< 65536 - 2^16 */
+	METHOD_PUT=131072,        /*!< 131072 - 2^17 */
+	METHOD_DELETE=262144,     /*!< 262144 - 2^18 */
+	METHOD_OTHER=524288       /*!< 524288 - 2^19 */
 } request_method_t;
 
 #define FL_FORCE_RPORT  (1 << 0)  /*!< force rport */
