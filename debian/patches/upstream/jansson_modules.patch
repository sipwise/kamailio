Description: jansson* modules from 4.3.1
Author: Victor Seva <linuxmaniac@torreviejawireless.org>

diff --git a/modules/jansson/Makefile b/modules/jansson/Makefile
new file mode 100644
index 0000000..2d033a4
--- /dev/null
+++ b/modules/jansson/Makefile
@@ -0,0 +1,22 @@
+#
+# jansson module makefile
+#
+# 
+# WARNING: do not run this directly, it should be run by the master Makefile
+
+include ../../Makefile.defs
+auto_gen=
+NAME=jansson.so
+
+BUILDER = $(shell which pkg-config)
+ifeq ($(BUILDER),)
+	DEFS+=-I$(LOCALBASE)/include \
+	LIBS+=-L$(SYSBASE)/include/lib -L$(LOCALBASE)/lib -ljansson
+else
+	DEFS+= $(shell pkg-config --cflags jansson)
+	LIBS+= $(shell pkg-config --libs jansson)
+endif
+DEFS+=-DOPENSER_MOD_INTERFACE
+
+SERLIBPATH=../../lib
+include ../../Makefile.modules
diff --git a/modules/jansson/README b/modules/jansson/README
new file mode 100644
index 0000000..c5be0a6
--- /dev/null
+++ b/modules/jansson/README
@@ -0,0 +1,236 @@
+JANSSON Module
+
+Joe Hillenbrand
+
+   <joe@flowroute.com>
+
+Edited by
+
+Matthew Williams
+
+   <matthew@flowroute.com>
+
+   Copyright © 2013 Flowroute LLC (flowroute.com)
+     __________________________________________________________________
+
+   Table of Contents
+
+   1. Admin Guide
+
+        1. Overview
+        2. Dependencies
+
+              2.1. Kamailio Modules
+              2.2. External Libraries or Applications
+
+        3. Parameters
+
+              3.1.
+
+        4. Functions
+
+              4.1. jansson_get(key/path, src, dst)
+              4.2. jansson_set(type, key/path, value, result)
+              4.3. jansson_append(type, key/path, value, result)
+              4.4. jansson_array_size(key/path, src, dst)
+              4.5. jansson_get_field(src, field_name, dst)
+
+   List of Examples
+
+   1.1. jansson_get usage
+   1.2. jansson_set usage
+   1.3. jansson_append usage
+   1.4. jansson_array_size usage
+   1.5. array concatination
+   1.6. jansson_get_field usage
+
+Chapter 1. Admin Guide
+
+   Table of Contents
+
+   1. Overview
+   2. Dependencies
+
+        2.1. Kamailio Modules
+        2.2. External Libraries or Applications
+
+   3. Parameters
+
+        3.1.
+
+   4. Functions
+
+        4.1. jansson_get(key/path, src, dst)
+        4.2. jansson_set(type, key/path, value, result)
+        4.3. jansson_append(type, key/path, value, result)
+        4.4. jansson_array_size(key/path, src, dst)
+        4.5. jansson_get_field(src, field_name, dst)
+
+1. Overview
+
+   This module provides operations on JSON strings using JANSSON library.
+   It has support for JSON-PATH operations.
+
+2. Dependencies
+
+   2.1. Kamailio Modules
+   2.2. External Libraries or Applications
+
+2.1. Kamailio Modules
+
+   The following modules must be loaded before this module:
+     * None
+
+2.2. External Libraries or Applications
+
+   The following libraries or applications must be installed before
+   running Kamailio with this module loaded:
+     * jansson (http://www.digip.org/jansson/), tested with: 2.2+
+
+3. Parameters
+
+   3.1.
+
+   None
+
+4. Functions
+
+   4.1. jansson_get(key/path, src, dst)
+   4.2. jansson_set(type, key/path, value, result)
+   4.3. jansson_append(type, key/path, value, result)
+   4.4. jansson_array_size(key/path, src, dst)
+   4.5. jansson_get_field(src, field_name, dst)
+
+4.1. jansson_get(key/path, src, dst)
+
+   Copy the value at the location 'path' from the json object 'src' and
+   store it in pvar 'dst'.
+
+   The path string supports dot delimited notation (e.g. foo.bar.baz),
+   array notation (e.g. [0]), or a combination of the two (e.g.
+   foo.bar[0][1].baz).
+
+   The function can put a string, integer, null, or new json string into
+   destination.
+
+   Example 1.1. jansson_get usage
+...
+jansson_get("inner.deep.list[3]", $var(myjson), "$var(n)");
+xlog("foo is $var(n)");
+...
+
+4.2. jansson_set(type, key/path, value, result)
+
+   Insert 'value' as 'type' at location 'path' into 'result'.
+
+   The path string works the same as in jansson_get.
+
+   Valid 'type' parameters are 'integer', 'real', 'string', 'object',
+   'array', 'true', 'false', and 'null' as well as abbriviated names such
+   as 'int', 'str', and 'obj'. 'value' is ignored when type is 'true',
+   'false', or 'null'.
+
+   Example 1.2. jansson_set usage
+...
+# create a new json object and put a string in it at key "mystr"
+jansson_set("string", "mystr", "my input string", "$var(myjson)");
+# $var(myjson) =='{"mystr":"my input string"}'
+
+# add other values
+jansson_set("integer", "count", 9000, "$var(myjson)");
+jansson_set("true", "mybool", 0, "$var(myjson)");
+jansson_set("real", "pi", "3.14159", "$var(myjson)");
+# $var(myjson) == '{"mystr":"my input string", "count":9000, "mybool":true, "pi"
+:3.14159}'
+
+# add a nested object
+jansson_set("obj", "myobj", '{"foo":"bar"}', "$var(myjson)");
+# $var(myjson) =='{"mystr":"my input string", "count":9000, "mybool":true, "pi":
+3.14159, "myobj":{"foo":"bar"}}'
+
+# change the nested object
+jansson_set("str", "myobj.foo", "baz", "$var(myjson)");
+# $var(myjson) == '{"mystr":"my input string", "count":9000, "mybool":true, "pi"
+:3.14159, "myobj":{"foo":"baz"}}'
+...
+
+4.3. jansson_append(type, key/path, value, result)
+
+   Like jansson_set but can be used to append to arrays. It can also be
+   used to combine two json objects.
+
+   Note that when appending a json object to another json object, if there
+   is a key that is shared between the two objects, that value will be
+   overwritten by the new object.
+
+   Example 1.3. jansson_append usage
+...
+# create a new json array and append values to it
+$var(myarray) = '[]';
+jansson_append("int", "", 0, "$var(myarray)");
+jansson_append("int", "", 1, "$var(myarray)");
+jansson_append("int", "", 2, "$var(myarray)");
+jansson_append("int", "", 3, "$var(myarray)");
+jansson_append("int", "", 4, "$var(myarray)");
+# $var(myarray) == '[0,1,2,3,4]'
+
+# add that array to an object
+jansson_set("array", "list", $var(myarray), "$var(myjson)");
+# $var(myjson) == '{"list":[0,1,2,3,4]}'
+
+# append another value to the list
+jansson_append("int", "list", 5, "$var(myjson)");
+# $var(myjson) == '{"list":[0,1,2,3,4,5]}'
+
+# combining two json objects
+$var(newobj) = '{"b":2, "c":3}';
+jansson_append('obj', "", '{"a":1, "b":100}', "$var(newobj)");
+# $var(newobj) == '{"a":1,"b":100","c":3}';
+...
+
+4.4. jansson_array_size(key/path, src, dst)
+
+   Puts the size of the array in 'src' at location 'path' into the pvar
+   'dst'.
+
+   This is particularly useful for looping through an array. See example.
+
+   Example 1.4. jansson_array_size usage
+...
+$var(array) = "{\"loopme\":[0,1,2,3,4,5]}";
+$var(count) = 0;
+jansson_array_size("loopme", $var(array), "$var(size)");
+while($var(count) < $var(size)) {
+    jansson_get("loopme[$var(count)]", $var(array), "$var(v)");
+    xlog("loopme[$var(count)] == $var(v)\n");
+    $var(count) = $var(count) + 1;
+}
+...
+
+   Example 1.5. array concatination
+...
+$var(count) = 0;
+$var(appendme) = '[0,1]';
+$var(mylist) = '[2,3,4,5]';
+jansson_array_size("", $var(mylist), "$var(appendme_size)");
+while($var(count) < $var(appendme_size)) {
+    jansson_get("[$var(count)]", $var(mylist), "$var(tmp)");
+    jansson_append('int', "", $var(tmp), "$var(appendme)");
+    $var(count) = $var(count) + 1;
+}
+...
+
+4.5. jansson_get_field(src, field_name, dst)
+
+   Copy field 'field_name' from json object 'src' and store it in pvar
+   'dst'.
+
+   This function is deprecated but kept for backwards compatibility. Right
+   now it is just a wrapper around jansson_get, and its functionality is
+   the same.
+
+   Example 1.6. jansson_get_field usage
+...
+jansson_get_field("{'foo':'bar'}", "foo", "$var(foo)");
+xlog("foo is $var(foo)");
+...
diff --git a/modules/jansson/doc/Makefile b/modules/jansson/doc/Makefile
new file mode 100644
index 0000000..2cafa1e
--- /dev/null
+++ b/modules/jansson/doc/Makefile
@@ -0,0 +1,4 @@
+docs = jansson.xml
+
+docbook_dir = ../../../docbook
+include $(docbook_dir)/Makefile.module
diff --git a/modules/jansson/doc/jansson.xml b/modules/jansson/doc/jansson.xml
new file mode 100644
index 0000000..4d05657
--- /dev/null
+++ b/modules/jansson/doc/jansson.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding='ISO-8859-1'?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../docbook/entities.xml">
+%docentities;
+
+]>
+
+<book xmlns:xi="http://www.w3.org/2001/XInclude">
+    <bookinfo>
+	<title>JANSSON Module</title>
+	<productname class="trade">kamailio.org</productname>
+	<authorgroup>
+	    <author>
+		<firstname>Joe</firstname>
+		<surname>Hillenbrand</surname>
+		<email>joe@flowroute.com</email>
+	    </author>
+	    <editor>
+			<firstname>Matthew</firstname>
+			<surname>Williams</surname>
+			<email>matthew@flowroute.com</email>
+	    </editor>
+	</authorgroup>
+	<copyright>
+	    <year>2013</year>
+	    <holder>Flowroute LLC (flowroute.com)</holder>
+	</copyright>
+    </bookinfo>
+    <toc></toc>
+    
+    <xi:include href="jansson_admin.xml"/>
+    
+    
+</book>
diff --git a/modules/jansson/doc/jansson_admin.xml b/modules/jansson/doc/jansson_admin.xml
new file mode 100644
index 0000000..b1b0eab
--- /dev/null
+++ b/modules/jansson/doc/jansson_admin.xml
@@ -0,0 +1,230 @@
+<?xml version="1.0" encoding='ISO-8859-1'?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../docbook/entities.xml">
+%docentities;
+
+]>
+<!-- Module User's Guide -->
+
+<chapter>
+
+    <title>&adminguide;</title>
+
+    <section>
+    <title>Overview</title>
+    <para>
+		This module provides operations on JSON strings using JANSSON
+		library. It has support for JSON-PATH operations.
+    </para>
+    </section>
+
+    <section>
+    <title>Dependencies</title>
+    <section>
+        <title>&kamailio; Modules</title>
+        <para>
+        The following modules must be loaded before this module:
+            <itemizedlist>
+            <listitem>
+            <para>
+                <emphasis>None</emphasis>
+            </para>
+            </listitem>
+            </itemizedlist>
+        </para>
+    </section>
+    <section>
+        <title>External Libraries or Applications</title>
+        <para>
+        The following libraries or applications must be installed before running
+        &kamailio; with this module loaded:
+            <itemizedlist>
+            <listitem>
+            <para>
+                <emphasis>jansson (http://www.digip.org/jansson/)</emphasis>, tested with: 2.2+
+            </para>
+            </listitem>
+            </itemizedlist>
+        </para>
+    </section>
+    </section>
+    <section>
+    <title>Parameters</title>
+    <section>
+        <para>
+            <emphasis>None</emphasis>
+        </para>
+    </section>
+    </section>
+
+    <section>
+    <title>Functions</title>
+    <section>
+        <title>
+            <function moreinfo="none">jansson_get(key/path, src, dst)</function>
+        </title>
+        <para>
+            Copy the value at the location 'path' from the json object 'src' and store it in pvar 'dst'.
+        </para>
+        <para>
+            The path string supports dot delimited notation (e.g. foo.bar.baz), array notation (e.g. [0]), or a combination of the two (e.g. foo.bar[0][1].baz).
+        </para>
+        <para>
+            The function can put a string, integer, null, or new json string into destination.
+        </para>
+        <example>
+        <title><function>jansson_get</function> usage</title>
+        <programlisting format="linespecific">
+...
+jansson_get("inner.deep.list[3]", $var(myjson), "$var(n)");
+xlog("foo is $var(n)");
+...
+        </programlisting>
+        </example>
+    </section>
+    <section>
+        <title>
+            <function moreinfo="none">jansson_set(type, key/path, value, result)</function>
+        </title>
+        <para>
+            Insert 'value' as 'type' at location 'path' into 'result'.
+        </para>
+        <para>
+            The path string works the same as in jansson_get.
+        </para>
+        <para>
+            Valid 'type' parameters are 'integer', 'real', 'string', 'object', 'array', 'true', 'false', and 'null'  as well as
+            abbriviated names such as 'int', 'str', and 'obj'. 'value' is ignored when type is 'true', 'false', or 'null'.
+        </para>
+        <example>
+        <title><function>jansson_set</function> usage</title>
+        <programlisting format="linespecific">
+...
+# create a new json object and put a string in it at key "mystr"
+jansson_set("string", "mystr", "my input string", "$var(myjson)");
+# $var(myjson) =='{"mystr":"my input string"}'
+
+# add other values
+jansson_set("integer", "count", 9000, "$var(myjson)");
+jansson_set("true", "mybool", 0, "$var(myjson)");
+jansson_set("real", "pi", "3.14159", "$var(myjson)");
+# $var(myjson) == '{"mystr":"my input string", "count":9000, "mybool":true, "pi":3.14159}'
+
+# add a nested object
+jansson_set("obj", "myobj", '{"foo":"bar"}', "$var(myjson)");
+# $var(myjson) =='{"mystr":"my input string", "count":9000, "mybool":true, "pi":3.14159, "myobj":{"foo":"bar"}}'
+
+# change the nested object
+jansson_set("str", "myobj.foo", "baz", "$var(myjson)");
+# $var(myjson) == '{"mystr":"my input string", "count":9000, "mybool":true, "pi":3.14159, "myobj":{"foo":"baz"}}'
+...
+        </programlisting>
+        </example>
+    </section>
+    <section>
+        <title>
+            <function moreinfo="none">jansson_append(type, key/path, value, result)</function>
+        </title>
+        <para>
+            Like jansson_set but can be used to append to arrays. It can also be used to combine two json objects.
+        </para>
+        <para>
+            Note that when appending a json object to another json object, if there is a key that is shared between the two objects, that value will be overwritten by the new object.
+        </para>
+        <example>
+        <title><function>jansson_append</function> usage</title>
+        <programlisting format="linespecific">
+...
+# create a new json array and append values to it
+$var(myarray) = '[]';
+jansson_append("int", "", 0, "$var(myarray)");
+jansson_append("int", "", 1, "$var(myarray)");
+jansson_append("int", "", 2, "$var(myarray)");
+jansson_append("int", "", 3, "$var(myarray)");
+jansson_append("int", "", 4, "$var(myarray)");
+# $var(myarray) == '[0,1,2,3,4]'
+
+# add that array to an object
+jansson_set("array", "list", $var(myarray), "$var(myjson)");
+# $var(myjson) == '{"list":[0,1,2,3,4]}'
+
+# append another value to the list
+jansson_append("int", "list", 5, "$var(myjson)");
+# $var(myjson) == '{"list":[0,1,2,3,4,5]}'
+
+# combining two json objects
+$var(newobj) = '{"b":2, "c":3}';
+jansson_append('obj', "", '{"a":1, "b":100}', "$var(newobj)");
+# $var(newobj) == '{"a":1,"b":100","c":3}';
+...
+        </programlisting>
+        </example>
+    </section>
+    <section>
+        <title>
+            <function moreinfo="none">jansson_array_size(key/path, src, dst)</function>
+        </title>
+        <para>
+            Puts the size of the array in 'src' at location 'path' into the pvar 'dst'.
+        </para>
+        <para>
+            This is particularly useful for looping through an array. See example.
+        </para>
+        <example>
+        <title><function>jansson_array_size</function> usage</title>
+        <programlisting format="linespecific">
+...
+$var(array) = "{\"loopme\":[0,1,2,3,4,5]}";
+$var(count) = 0;
+jansson_array_size("loopme", $var(array), "$var(size)");
+while($var(count) &lt; $var(size)) {
+    jansson_get("loopme[$var(count)]", $var(array), "$var(v)");
+    xlog("loopme[$var(count)] == $var(v)\n");
+    $var(count) = $var(count) + 1;
+}
+...
+        </programlisting>
+        </example>
+        <example>
+        <title>array concatination</title>
+        <programlisting format="linespecific">
+...
+$var(count) = 0;
+$var(appendme) = '[0,1]';
+$var(mylist) = '[2,3,4,5]';
+jansson_array_size("", $var(mylist), "$var(appendme_size)");
+while($var(count) &lt; $var(appendme_size)) {
+    jansson_get("[$var(count)]", $var(mylist), "$var(tmp)");
+    jansson_append('int', "", $var(tmp), "$var(appendme)");
+    $var(count) = $var(count) + 1;
+}
+...
+        </programlisting>
+        </example>
+    </section>
+    <section>
+        <title>
+            <function moreinfo="none">jansson_get_field(src, field_name, dst)</function>
+        </title>
+        <para>
+            Copy field 'field_name' from json object 'src' and store it in pvar 'dst'.
+        </para>
+        <para>
+            <emphasis>This function is deprecated</emphasis> but kept for backwards compatibility. Right now it is just a wrapper around <function>jansson_get</function>, and its functionality is the same.
+        </para>
+        <example>
+        <title><function>jansson_get_field</function> usage</title>
+        <programlisting format="linespecific">
+...
+jansson_get_field("{'foo':'bar'}", "foo", "$var(foo)");
+xlog("foo is $var(foo)");
+...
+        </programlisting>
+        </example>
+    </section>
+    </section>
+</chapter>
+
diff --git a/modules/jansson/jansson_funcs.c b/modules/jansson/jansson_funcs.c
new file mode 100644
index 0000000..fbae741
--- /dev/null
+++ b/modules/jansson/jansson_funcs.c
@@ -0,0 +1,293 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <jansson.h>
+
+#include "../../mod_fix.h"
+#include "../../lvalue.h"
+
+#include "jansson_path.h"
+#include "jansson_funcs.h"
+#include "jansson_utils.h"
+
+int janssonmod_get(struct sip_msg* msg, char* path_in, char* src_in, char* dst)
+{
+	str src_s;
+	str path_s;
+	pv_spec_t *dst_pv;
+	pv_value_t dst_val;
+
+	if (fixup_get_svalue(msg, (gparam_p)src_in, &src_s) != 0) {
+		ERR("cannot get json string value\n");
+		return -1;
+	}
+
+	if (fixup_get_svalue(msg, (gparam_p)path_in, &path_s) != 0) {
+		ERR("cannot get path string value\n");
+		return -1;
+	}
+
+	dst_pv = (pv_spec_t *)dst;
+
+	json_t* json = NULL;
+	json_error_t parsing_error;
+
+	json = json_loads(src_s.s, JSON_REJECT_DUPLICATES, &parsing_error);
+
+	if(!json) {
+		ERR("failed to parse: %.*s\n", src_s.len, src_s.s);
+		ERR("json error at line %d: %s\n",
+				parsing_error.line, parsing_error.text);
+		goto fail;
+	}
+
+	char* path = path_s.s;
+
+	json_t* v = json_path_get(json, path);
+	if(!v) {
+		goto fail;
+	}
+
+	char* freeme = NULL;
+
+	if(jansson_to_val(&dst_val, &freeme, v)<0) goto fail;
+
+	dst_pv->setf(msg, &dst_pv->pvp, (int)EQ_T, &dst_val);
+
+	if(freeme!=NULL) {
+		free(freeme);
+	}
+
+	json_decref(json);
+	return 1;
+
+fail:
+	json_decref(json);
+	return -1;
+}
+
+#define STR_EQ_STATIC(a,b) ((a.len == sizeof(b)-1) && (strncmp(a.s, b, sizeof(b)-1)==0))
+
+int janssonmod_set(unsigned int append, struct sip_msg* msg, char* type_in,
+		 char* path_in, char* value_in, char* result_in)
+{
+	str type_s;
+	str value_s;
+	str path_s;
+
+	pv_spec_t* result_pv;
+	pv_value_t result_val;
+
+	if (fixup_get_svalue(msg, (gparam_p)type_in, &type_s) != 0){
+		ERR("cannot get type string value\n");
+		return -1;
+	}
+
+	if (fixup_get_svalue(msg, (gparam_p)value_in, &value_s) != 0){
+		ERR("cannot get value string\n");
+		return -1;
+	}
+
+	if (fixup_get_svalue(msg, (gparam_p)path_in, &path_s) != 0){
+		ERR("cannot get path string value\n");
+		return -1;
+	}
+
+	result_pv = (pv_spec_t *)result_in;
+
+	if(pv_get_spec_value(msg, result_pv, &result_val)!=0
+			|| result_val.flags != PV_VAL_STR) {
+		result_val.flags = PV_VAL_STR;
+		result_val.rs.s = "{}";
+		result_val.rs.len = strlen("{}");
+	}
+
+/*
+	ALERT("type is: %.*s\n", type_s.len, type_s.s);
+	ALERT("path is: %.*s\n", path_s.len, path_s.s);
+	ALERT("value is: %.*s\n", value_s.len, value_s.s);
+	ALERT("result is: %.*s\n", result_val.rs.len, result_val.rs.s);
+*/
+
+	char* result = result_val.rs.s;
+
+	json_t* result_json = NULL;
+	json_t* value = NULL;
+	char* freeme = NULL;
+	json_error_t parsing_error;
+	char* endptr;
+
+	/* check the type */
+	if(STR_EQ_STATIC(type_s, "object") || STR_EQ_STATIC(type_s, "obj")){
+		value = json_loads(value_s.s, JSON_REJECT_DUPLICATES, &parsing_error);
+		if(value && !json_is_object(value)) {
+			ERR("value to add is not an object\n");
+			goto fail;
+		}
+
+	}else if(STR_EQ_STATIC(type_s, "array")) {
+		value = json_loads(value_s.s, JSON_REJECT_DUPLICATES, &parsing_error);
+		if(value && !json_is_array(value)) {
+			ERR("value to add is not an array\n");
+			goto fail;
+		}
+
+	}else if(STR_EQ_STATIC(type_s, "string")
+				|| STR_EQ_STATIC(type_s, "str")) {
+		value = json_string(value_s.s);
+		if(!value || !json_is_string(value)) {
+			ERR("value to add is not a string\n");
+			goto fail;
+		}
+
+	}else if(STR_EQ_STATIC(type_s, "integer")
+				|| STR_EQ_STATIC(type_s, "int")) {
+		int i = strtol(value_s.s, &endptr, 10);
+		if(*endptr != '\0') {
+			ERR("parsing int failed for \"%s\"\n", value_s.s);
+			goto fail;
+		}
+		value = json_integer(i);
+		if(!value || !json_is_integer(value)) {
+			ERR("value to add is not an integer\n");
+			goto fail;
+		}
+
+	}else if(STR_EQ_STATIC(type_s, "real")) {
+		double d = strtod(value_s.s, &endptr);
+		if(*endptr != '\0') {
+			ERR("parsing real failed for \"%s\"\n", value_s.s);
+			goto fail;
+		}
+		value = json_real(d);
+		if(!value || !json_is_real(value)) {
+			ERR("value to add is not a real\n");
+			goto fail;
+		}
+
+	}else if(STR_EQ_STATIC(type_s, "true")) {
+		value = json_true();
+
+	}else if(STR_EQ_STATIC(type_s, "false")) {
+		value = json_false();
+
+	}else if(STR_EQ_STATIC(type_s, "null")) {
+		value = json_null();
+
+	} else {
+		ERR("unrecognized input type\n");
+		goto fail;
+	}
+
+	if(!value) {
+		ERR("parsing failed for \"%s\"\n", value_s.s);
+		ERR("value error at line %d: %s\n",
+				parsing_error.line, parsing_error.text);
+		goto fail;
+	}
+
+	char* path = path_s.s;
+
+	result_json = json_loads(result, JSON_REJECT_DUPLICATES, &parsing_error);
+
+	if(!result_json) {
+		ERR("result has json error at line %d: %s\n",
+				parsing_error.line, parsing_error.text);
+		goto fail;
+	}
+
+	if(json_path_set(result_json, path, value, append)<0) {
+		goto fail;
+	}
+
+	if(jansson_to_val(&result_val, &freeme, result_json)<0) goto fail;
+
+	result_pv->setf(msg, &result_pv->pvp, (int)EQ_T, &result_val);
+
+	if(freeme) free(freeme);
+	json_decref(result_json);
+	return 1;
+
+fail:
+	if(freeme) free(freeme);
+	json_decref(result_json);
+	return -1;
+}
+
+int janssonmod_array_size(struct sip_msg* msg, char* path_in, char* src_in, char* dst)
+{
+	str src_s;
+	str path_s;
+	pv_spec_t *dst_pv;
+	pv_value_t dst_val;
+
+	if (fixup_get_svalue(msg, (gparam_p)src_in, &src_s) != 0) {
+		ERR("cannot get json string value\n");
+		return -1;
+	}
+
+	if (fixup_get_svalue(msg, (gparam_p)path_in, &path_s) != 0) {
+		ERR("cannot get path string value\n");
+		return -1;
+	}
+
+	dst_pv = (pv_spec_t *)dst;
+
+	json_t* json = NULL;
+	json_error_t parsing_error;
+
+	json = json_loads(src_s.s, JSON_REJECT_DUPLICATES, &parsing_error);
+
+	if(!json) {
+		ERR("json error at line %d: %s\n",
+				parsing_error.line, parsing_error.text);
+		goto fail;
+	}
+
+	char* path = path_s.s;
+
+	json_t* v = json_path_get(json, path);
+	if(!v) {
+		ERR("failed to find %s in json\n", path);
+		goto fail;
+	}
+
+	if(!json_is_array(v)) {
+		ERR("value at %s is not an array\n", path);
+		goto fail;
+	}
+
+	int size = json_array_size(v);
+	dst_val.ri = size;
+	dst_val.flags = PV_TYPE_INT|PV_VAL_INT;
+
+	dst_pv->setf(msg, &dst_pv->pvp, (int)EQ_T, &dst_val);
+
+	json_decref(json);
+	return 1;
+
+fail:
+	json_decref(json);
+	return -1;
+}
diff --git a/modules/jansson/jansson_funcs.h b/modules/jansson/jansson_funcs.h
new file mode 100644
index 0000000..7babbc2
--- /dev/null
+++ b/modules/jansson/jansson_funcs.h
@@ -0,0 +1,35 @@
+/**
+ * Copyright (C) 2011 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _JANSSON_FUNCS_H_
+#define _JANSSON_FUNCS_H_
+
+#include "../../parser/msg_parser.h"
+
+int janssonmod_get(struct sip_msg* msg, char* path_in, char* json_in,
+		char* result);
+int janssonmod_set(unsigned int append, struct sip_msg* msg, char* type_in,
+		char* path_in, char* value_in, char* result);
+int janssonmod_array_size(struct sip_msg* msg, char* json_in,
+		char* path_in, char* dst);
+
+#endif
diff --git a/modules/jansson/jansson_mod.c b/modules/jansson/jansson_mod.c
new file mode 100644
index 0000000..58f4904
--- /dev/null
+++ b/modules/jansson/jansson_mod.c
@@ -0,0 +1,149 @@
+/**
+ * Copyright (C) 2011 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "../../mod_fix.h"
+#include "../../sr_module.h"
+
+#include "jansson_funcs.h"
+#include "jansson_utils.h"
+
+MODULE_VERSION
+
+/* module functions */
+static int mod_init(void);
+static int fixup_get_params(void** param, int param_no);
+static int fixup_get_params_free(void** param, int param_no);
+static int fixup_set_params(void** param, int param_no);
+static int fixup_set_params_free(void** param, int param_no);
+
+
+int janssonmod_set_replace(struct sip_msg* msg, char* type_in, char* path_in,
+		char* value_in, char* result){
+	return janssonmod_set(0, msg, type_in, path_in, value_in, result);
+}
+
+int janssonmod_set_append(struct sip_msg* msg, char* type_in, char* path_in,
+		char* value_in, char* result) {
+	return janssonmod_set(1, msg, type_in, path_in, value_in, result);
+}
+int janssonmod_get_field(struct sip_msg* msg, char* jansson_in, char* path_in,
+		char* result) {
+	return janssonmod_get(msg, path_in, jansson_in, result);
+}
+
+/* Exported functions */
+static cmd_export_t cmds[]={
+	{"jansson_get", (cmd_function)janssonmod_get, 3,
+		fixup_get_params, fixup_get_params_free, ANY_ROUTE},
+	{"jansson_array_size", (cmd_function)janssonmod_array_size, 3,
+		fixup_get_params, fixup_get_params_free, ANY_ROUTE},
+	{"jansson_set", (cmd_function)janssonmod_set_replace, 4,
+		fixup_set_params, fixup_set_params_free, ANY_ROUTE},
+	{"jansson_append", (cmd_function)janssonmod_set_append, 4,
+		fixup_set_params, fixup_set_params_free, ANY_ROUTE},
+	/* for backwards compatibility */
+	{"jansson_get_field", (cmd_function)janssonmod_get_field, 3,
+		fixup_get_params, fixup_get_params_free, ANY_ROUTE},
+	/* non-script functions */
+	{"jansson_to_val", (cmd_function)jansson_to_val, 0, 0, 0, 0},
+	{0, 0, 0, 0, 0, 0}
+};
+
+struct module_exports exports = {
+		"jansson",
+		DEFAULT_DLFLAGS,	/* dlopen flags */
+		cmds,				/* Exported functions */
+		0,					/* Exported parameters */
+		0,					/* exported statistics */
+		0,					/* exported MI functions */
+		0,					/* exported pseudo-variables */
+		0,					/* extra processes */
+		mod_init,			/* module initialization function */
+		0,					/* response function*/
+		0,					/* destroy function */
+		0					/* per-child init function */
+};
+
+
+static int fixup_get_params(void** param, int param_no)
+{
+	if (param_no <= 2) {
+		return fixup_spve_null(param, 1);
+	}
+
+	if (param_no == 3) {
+		return fixup_pvar_null(param, 1);
+	}
+
+	ERR("invalid parameter number <%d>\n", param_no);
+	return -1;
+}
+
+static int fixup_get_params_free(void** param, int param_no)
+{
+	if (param_no <= 2) {
+		return fixup_free_spve_null(param, 1);
+	}
+
+	if (param_no == 3) {
+		return fixup_free_pvar_null(param, 1);
+	}
+
+	ERR("invalid parameter number <%d>\n", param_no);
+	return -1;
+}
+
+static int fixup_set_params(void** param, int param_no)
+{
+	if(param_no <= 3) {
+		return fixup_spve_null(param, 1);
+	}
+
+	if (param_no == 4) {
+		return fixup_pvar_null(param, 1);
+	}
+
+	ERR("invalid parameter number <%d>\n", param_no);
+	return -1;
+}
+
+static int fixup_set_params_free(void** param, int param_no)
+{
+	if (param_no <= 3) {
+		return fixup_free_spve_null(param, 1);
+	}
+
+	if (param_no == 4) {
+		return fixup_free_pvar_null(param, 1);
+	}
+
+	ERR("invalid parameter number <%d>\n", param_no);
+	return -1;
+}
+
+/* just used for unit testing */
+static int mod_init(void) {
+	return 0;
+}
diff --git a/modules/jansson/jansson_path.c b/modules/jansson/jansson_path.c
new file mode 100644
index 0000000..d7c4c83
--- /dev/null
+++ b/modules/jansson/jansson_path.c
@@ -0,0 +1,279 @@
+/*
+ * Copyright (c) 2009-2012 Petri Lehtinen <petri@digip.org>
+ * Copyright (c) 2011-2012 Basile Starynkevitch <basile@starynkevitch.net>
+ * Copyright (c) 2012 Rogerz Zhang <rogerz.zhang@gmail.com>
+ * Copyright (c) 2013 Flowroute LLC (flowroute.com)
+ *
+ * Jansson is free software; you can redistribute it and/or modify
+ * it under the terms of the MIT license.
+ *
+ * Pulled from https://github.com/rogerz/jansson/blob/json_path/src/path.c
+ */
+
+#include <string.h>
+#include <assert.h>
+
+#include <jansson.h>
+
+#include "../../mod_fix.h"
+
+/* jansson private helper functions */
+void *jsonp_malloc(size_t size);
+void jsonp_free(void *ptr);
+char *jsonp_strdup(const char *str);
+
+static json_malloc_t do_malloc = malloc;
+static json_free_t do_free = free;
+
+json_t *json_path_get(const json_t *json, const char *path)
+{
+	static const char array_open = '[';
+	static const char *path_delims = ".[", *array_close = "]";
+	const json_t *cursor;
+	char *token, *buf, *peek, *endptr, delim = '\0';
+	const char *expect;
+
+	if (!json || !path)
+		return NULL;
+	else
+		buf = jsonp_strdup(path);
+
+	peek = buf;
+	token = buf;
+	cursor = json;
+	expect = path_delims;
+
+	if (*token == array_open) {
+		expect = array_close;
+		token++;
+	}
+
+	while (peek && *peek && cursor)
+	{
+		char *last_peek = peek;
+		peek = strpbrk(peek, expect);
+		if (peek) {
+			if (!token && peek != last_peek)
+				goto fail;
+			delim = *peek;
+			*peek++ = '\0';
+		} else if (expect != path_delims || !token) {
+			goto fail;
+		}
+
+		if (expect == path_delims) {
+			if (token) {
+				cursor = json_object_get(cursor, token);
+			}
+			expect = (delim == array_open ? array_close : path_delims);
+			token = peek;
+		} else if (expect == array_close) {
+			size_t index = strtol(token, &endptr, 0);
+			if (*endptr)
+				goto fail;
+			cursor = json_array_get(cursor, index);
+			token = NULL;
+			expect = path_delims;
+		} else {
+			goto fail;
+		}
+	}
+
+	jsonp_free(buf);
+	return (json_t *)cursor;
+fail:
+	jsonp_free(buf);
+	return NULL;
+}
+
+int json_path_set(json_t *json, const char *path, json_t *value,
+		unsigned int append)
+{
+	static const char array_open = '[';
+	static const char object_delim = '.';
+	static const char *path_delims = ".[";
+	static const char *array_close = "]";
+
+	json_t *cursor, *parent = NULL;
+	char *token, *buf = NULL, *peek, delim = '\0';
+	const char *expect;
+	int index_saved = -1;
+
+	if (!json || !path || !value) {
+		ERR("invalid arguments\n");
+		goto fail;
+	} else {
+		buf = jsonp_strdup(path);
+	}
+
+	peek = buf;
+	token = buf;
+	cursor = json;
+	expect = path_delims;
+
+	if (*token == array_open) {
+		expect = array_close;
+		token++;
+	}
+
+	while (peek && *peek && cursor)
+	{
+		char *last_peek = peek;
+		peek = strpbrk(last_peek, expect);
+
+		if (peek) {
+			if (!token && peek != last_peek) {
+				ERR("unexpected trailing chars in JSON path at pos %zu\n",
+						last_peek - buf);
+				goto fail;
+			}
+			delim = *peek;
+			*peek++ = '\0';
+		} else { // end of path
+			if (expect == path_delims) {
+				break;
+			} else {
+				ERR("missing ']' at pos %zu\n", peek - buf);
+				goto fail;
+			}
+		}
+
+		if (expect == path_delims) {
+			if (token) {
+				if (token[0] == '\0') {
+					ERR("empty token at pos %zu\n", peek - buf);
+					goto fail;
+				}
+
+				parent = cursor;
+				cursor = json_object_get(parent, token);
+
+				if (!cursor) {
+					if (!json_is_object(parent)) {
+						ERR("object expected at pos %zu\n", peek - buf);
+						goto fail;
+					}
+					if (delim == object_delim) {
+						cursor = json_object();
+						json_object_set_new(parent, token, cursor);
+					} else {
+						ERR("new array is not allowed at pos %zu\n", peek - buf);
+						goto fail;
+					}
+				}
+			}
+			expect = (delim == array_open ? array_close : path_delims);
+			token = peek;
+		} else if (expect == array_close) {
+			char *endptr;
+			size_t index;
+
+			parent = cursor;
+			if (!json_is_array(parent)) {
+				ERR("array expected at pos %zu\n", peek - buf);
+				goto fail;
+			}
+
+			index = strtol(token, &endptr, 0);
+			if (*endptr) {
+				ERR("invalid array index at pos %zu\n", peek - buf);
+				goto fail;
+			}
+
+			cursor = json_array_get(parent, index);
+			if (!cursor) {
+				ERR("array index out of bound at pos %zu\n", peek - buf);
+				goto fail;
+			}
+
+			index_saved = index;
+			token = NULL;
+			expect = path_delims;
+
+		} else {
+			ERR("fatal JSON error at pos %zu\n", peek - buf);
+			goto fail;
+		}
+	}
+
+	if (token && append) {
+
+		if(strlen(token) > 0) {
+			json_t* tmp  = json_object_get(cursor, token);
+			if(json_is_array(tmp)) {
+				json_array_append(tmp, value);
+				json_object_set(cursor, token, tmp);
+			} else if(json_is_object(tmp) && json_is_object(value) ) {
+				json_object_update(tmp, value);
+				json_object_set(cursor, token, tmp);
+			} else {
+				ERR("JSON array or object expected at pos %zu\n", peek - buf);
+				goto fail;
+			}
+		} else if(json_is_array(cursor)) {
+			json_array_append(cursor, value);
+
+		} else if(json_is_object(cursor) && json_is_object(value)) {
+			json_object_update(cursor, value);
+
+		} else {
+			ERR("JSON array or object expected at pos %zu\n", peek - buf);
+			goto fail;
+		}
+
+	} else if (token && strlen(token) != 0 ) {
+
+		if (json_is_object(cursor)) {
+			json_object_set(cursor, token, value);
+
+		} else {
+			ERR("JSON object expected at pos %zu\n", peek - buf);
+			goto fail;
+		}
+
+		cursor = json_object_get(cursor, token);
+	} else if (index_saved != -1 && json_is_array(parent)) {
+		json_array_set(parent, index_saved, value);
+		cursor = json_array_get(parent, index_saved);
+
+	} else {
+		ERR("invalid JSON path at pos %zu\n", peek - buf);
+		goto fail;
+	}
+
+	json_decref(value);
+	jsonp_free(buf);
+	return 0;
+
+fail:
+	json_decref(value);
+	jsonp_free(buf);
+	return -1;
+}
+
+/* jansson private helper functions */
+void *jsonp_malloc(size_t size) {
+	if(!size)
+		return NULL;
+
+	return (*do_malloc)(size);
+}
+
+void jsonp_free(void *ptr) {
+	if(!ptr)
+		return;
+
+	(*do_free)(ptr);
+}
+
+char *jsonp_strdup(const char *str) {
+	char *new_str;
+
+	new_str = jsonp_malloc(strlen(str) + 1); 
+	if(!new_str)
+		return NULL;
+
+	strcpy(new_str, str);
+	return new_str;
+}
+/* end jansson private helpers */
diff --git a/modules/jansson/jansson_path.h b/modules/jansson/jansson_path.h
new file mode 100644
index 0000000..9aefb49
--- /dev/null
+++ b/modules/jansson/jansson_path.h
@@ -0,0 +1,17 @@
+/*
+ * Copyright (c) 2012 Rogerz Zhang <rogerz.zhang@gmail.com>
+ *
+ * Jansson is free software; you can redistribute it and/or modify
+ * it under the terms of the MIT license. 
+ */
+
+
+#ifndef _JANSSON_FUNCS_H_
+#define _JANSSON_FUNCS_H_
+#include <jansson.h>
+
+json_t *json_path_get(const json_t *json, const char *path);
+int json_path_set(json_t *json, const char *path, json_t *value, unsigned int append);
+
+#endif
+
diff --git a/modules/jansson/jansson_utils.c b/modules/jansson/jansson_utils.c
new file mode 100644
index 0000000..4919b0e
--- /dev/null
+++ b/modules/jansson/jansson_utils.c
@@ -0,0 +1,70 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <jansson.h>
+
+#include "../../lvalue.h"
+
+#include "jansson_utils.h"
+
+int jansson_to_val(pv_value_t* val, char** freeme, json_t* v) {
+
+	val->flags = 0;
+
+	if(json_is_object(v) || json_is_array(v)) {
+		const char* value = json_dumps(v, JSON_COMPACT|JSON_PRESERVE_ORDER);
+		*freeme = (char*)value;
+		val->rs.s = (char*)value;
+		val->rs.len = strlen(value);
+		val->flags = PV_VAL_STR;
+	}else if(json_is_string(v)) {
+		const char* value = json_string_value(v);
+		val->rs.s = (char*)value;
+		val->rs.len = strlen(value);
+		val->flags = PV_VAL_STR;
+	}else if(json_is_boolean(v)) {
+		val->ri = json_is_true(v) ? 0 : 1;
+		val->flags = PV_TYPE_INT|PV_VAL_INT;
+	}else if(json_is_real(v)) {
+		char* value = NULL;
+		if(asprintf(&value, "%.15g", json_real_value(v))<0) {
+			ERR("asprintf failed\n");
+			return -1;
+		}
+		*freeme = value;
+		val->rs.s = value;
+		val->rs.len = strlen(value);
+		val->flags = PV_VAL_STR;
+	}else if(json_is_integer(v)) {
+		int value = json_integer_value(v);
+		val->ri = value;
+		val->flags = PV_TYPE_INT|PV_VAL_INT;
+	}else if(json_is_null(v)) {
+		val->flags = PV_VAL_NULL;
+	}else {
+		ERR("unrecognized json type: %d\n", json_typeof(v));
+		return -1;
+	}
+	return 0;
+}
diff --git a/modules/jansson/jansson_utils.h b/modules/jansson/jansson_utils.h
new file mode 100644
index 0000000..5f57509
--- /dev/null
+++ b/modules/jansson/jansson_utils.h
@@ -0,0 +1,34 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _JANSSON_UTILS_H_
+#define _JANSSON_UTILS_H_
+
+#include <jansson.h>
+
+#include "../../sr_module.h"
+#include "../../lvalue.h"
+
+typedef int (*jansson_to_val_f)(pv_value_t* val, char** freeme, json_t* v);
+int jansson_to_val(pv_value_t* val, char** freeme, json_t* v);
+
+#endif
diff --git a/modules/janssonrpc-c/Makefile b/modules/janssonrpc-c/Makefile
new file mode 100644
index 0000000..21e4d4c
--- /dev/null
+++ b/modules/janssonrpc-c/Makefile
@@ -0,0 +1,26 @@
+#
+# janssonrpc-c module makefile
+#
+# 
+# WARNING: do not run this directly, it should be run by the master Makefile
+
+include ../../Makefile.defs
+auto_gen=
+NAME=janssonrpc-c.so
+LIBS=-lm
+
+BUILDER = $(shell which pkg-config)
+ifeq ($(BUILDER),)
+	DEFS+=-I$(LOCALBASE)/include
+	LIBS+=-L$(SYSBASE)/include/lib -L$(LOCALBASE)/lib -levent -ljansson
+else
+	DEFS+= $(shell pkg-config --cflags jansson)
+	LIBS+= $(shell pkg-config --libs jansson)
+	DEFS+= $(shell pkg-config --cflags libevent)
+	LIBS+= $(shell pkg-config --libs libevent)
+endif
+ 
+DEFS+=-DOPENSER_MOD_INTERFACE
+
+SERLIBPATH=../../lib
+include ../../Makefile.modules
diff --git a/modules/janssonrpc-c/README b/modules/janssonrpc-c/README
new file mode 100644
index 0000000..d585e05
--- /dev/null
+++ b/modules/janssonrpc-c/README
@@ -0,0 +1,355 @@
+janssonrpc-c Module
+
+Joe Hillenbrand
+
+   <joe@flowroute.com>
+
+Edited by
+
+Matthew Williams
+
+   <matthew@flowroute.com>
+
+   Copyright © 2013 Flowroute LLC (flowroute.com)
+     __________________________________________________________________
+
+   Table of Contents
+
+   1. Admin Guide
+
+        1. Overview
+        2. Dependencies
+
+              2.1. Kamailio Modules
+              2.2. External Libraries or Applications
+
+        3. Parameters
+
+              3.1. min_srv_ttl (integer)
+              3.2. result_pv (string)
+              3.3. server (string)
+              3.4. retry_codes (string)
+
+        4. Functions
+
+              4.1. janssonrpc_notification(conn, method, parameters)
+              4.2. janssonrpc_request(conn, method, params[, options]])
+              4.3. Error Handling
+
+   List of Examples
+
+   1.1. Set min_srv_ttl parameter
+   1.2. Set result_pv parameter
+   1.3. Set server parameter
+   1.4. Set retry_codes parameter
+   1.5. janssonrpc_notification usage
+   1.6. janssonrpc_request usage
+   1.7. route example with internal_error handling
+
+Chapter 1. Admin Guide
+
+   Table of Contents
+
+   1. Overview
+   2. Dependencies
+
+        2.1. Kamailio Modules
+        2.2. External Libraries or Applications
+
+   3. Parameters
+
+        3.1. min_srv_ttl (integer)
+        3.2. result_pv (string)
+        3.3. server (string)
+        3.4. retry_codes (string)
+
+   4. Functions
+
+        4.1. janssonrpc_notification(conn, method, parameters)
+        4.2. janssonrpc_request(conn, method, params[, options]])
+        4.3. Error Handling
+
+1. Overview
+
+   This module provides access to JSON-RPC 2.0 services (operating over
+   TCP/Netstrings) in accordance with
+   http://www.jsonrpc.org/specification. It uses JANSSON library for JSON
+   document management.
+
+   It uses t_suspend() and t_continue() from the TM module.
+
+   Note that after invoking an asyncronous operation, the processing will
+   continue later, in another application process. Therefore, do not rely
+   on variables stored in private memory, use shared memory if you want to
+   get values after the processing is resumend (e.g., $shv(...) or htable
+   $sht(...)).
+
+2. Dependencies
+
+   2.1. Kamailio Modules
+   2.2. External Libraries or Applications
+
+2.1. Kamailio Modules
+
+   The following modules must be loaded before this module:
+     * jansson - jansson json handling.
+     * tm - transaction management.
+
+2.2. External Libraries or Applications
+
+   The following libraries or applications must be installed before
+   running Kamailio with this module loaded:
+     * jansson (http://www.digip.org/jansson/), tested with: 2.2+
+     * libevent 2.0.5+ (http://libevent.org/), tested with: 2.0.16
+
+3. Parameters
+
+   3.1. min_srv_ttl (integer)
+   3.2. result_pv (string)
+   3.3. server (string)
+   3.4. retry_codes (string)
+
+3.1. min_srv_ttl (integer)
+
+   The minimum acceptable TTL in seconds for SRV DNS entries. This means
+   that TTLs from the DNS will be ignored if they are lower than this
+   value. It cannot be set lower than 1 second.
+
+   Default is 5 seconds.
+
+   Example 1.1. Set min_srv_ttl parameter
+...
+modparam("janssonrpc-c", "min_srv_ttl", 30)
+...
+
+   This will set any SRV TTL lower than 30 seconds to 30 seconds.
+
+3.2. result_pv (string)
+
+   The PV spec where to store the result of a call to
+   janssonrpc_request(). It can be any writtable PV.
+
+   Default value is "$var(jsrpc_result)".
+
+   Example 1.2. Set result_pv parameter
+...
+modparam("janssonrpc-c", "result_pv", "$var(result)")
+...
+
+3.3. server (string)
+
+   The server providing the remote jsonrpc service. Format can be
+   "conn=example;addr=localhost;port=9999;priority=10;weight=20" or
+   "conn=bar;srv=_sip._tcp.example.net".
+
+     * conn - name for a collection of servers (required).
+     * srv - DNS SRV domain name (optional).
+     * addr - host address (required, except when using srv).
+     * port - host port (required, except when using srv).
+     * priority - server are grouped by priority. Servers with higher
+       priority (lower number) are used first. Default is 0. (optional
+       when using addr, invalid otherwise).
+     * weight - functions the same as a DNS SRV weight. Requests are
+       distributed between servers of the same priority proportional to
+       their weight. Default is 1. (optional when using addr, invalid
+       otherwise).
+
+   Example 1.3. Set server parameter
+...
+modparam("janssonrpc-c", "server", "conn=tests;srv=_test1._tcp.example.net");
+modparam("janssonrpc-c", "server", "conn=tests;srv=_test2._tcp.example.net");
+modparam("janssonrpc-c", "server", "conn=local;addr=localhost;port=8080;priority
+=10;weight=10");
+modparam("janssonrpc-c", "server", "conn=user_db;addr=rpc.prod.exmaple.net;port=
+5060;priority=10;weight=10");
+...
+
+3.4. retry_codes (string)
+
+   A comma delimited list of error codes or error code ranges to
+   automatically schedule a request retry if received.
+
+   This will only be used if there is no route specified for the request.
+
+   An error code can be any interger, but is typically a negative number.
+
+   An error code range is delimited by ".." . For example,
+   "-32099..-32000".
+
+   Spaces are ignored.
+
+   Example 1.4. Set retry_codes parameter
+...
+modparam("janssonrpc-s", "retry_codes", "-32603, -32000..-32099");
+...
+
+4. Functions
+
+   4.1. janssonrpc_notification(conn, method, parameters)
+   4.2. janssonrpc_request(conn, method, params[, options]])
+   4.3. Error Handling
+
+4.1. janssonrpc_notification(conn, method, parameters)
+
+     * conn - name for a collection of servers (required)
+     * method - jsonrpc method (required)
+     * params - jsonrpc request params (required) Use $null or empty
+       string to not send any parameters in the jsonrpc notification.
+
+   Unlike janssonrpc_request (below), notifications do not receive a
+   response. Script processing continues in the usual fashion as soon as
+   the notification has been sent.
+
+   If no servers can be reached, a message is sent to the logs.
+
+   The 'method' and 'params' can be a static string or dynamic string
+   value with config variables.
+
+   Example 1.5. janssonrpc_notification usage
+...
+janssonrpc_notification("user_db", "update_user", '{"id": 1234, "name": "Daniel"
+}');
+...
+
+4.2. janssonrpc_request(conn, method, params[, options]])
+
+   The conn, method, params, and options can be a static string or a
+   dynamic string value with config variables.
+
+     * conn - name for a collection of servers (required)
+     * method - jsonrpc method (required)
+     * params - jsonrpc request params (required) Use $null or empty
+       string to not send any parameters in the jsonrpc request.
+     * options
+       Options for the janssonrpc_request function. Format can be
+       "route=RESPONSE;retry=2;timeout=100". All these parameters are
+       optional.
+          + retry - number of times you retry a failed request. -1 means
+            retry forever. Default is 0. Request will be retried if they
+            either timeout or fail to send. Retries untilize exponential
+            back off between successive retries, up to 60 seconds. The
+            equation for time between retries is:
+            time = n^2 * timeout (for time < 60 seconds)
+            where n is the number of times a request has been tried.
+          + timeout - request timeout in milliseconds. Default is 500.
+          + route - resume script execution at this route.
+
+   When a response is received, processing continues for the SIP request
+   in the route specified.
+
+   If no route is specified, then any errors are logged and successes are
+   ignored. The function will also not interupt script execution.
+
+   Since the SIP request handling is resumed in another process, the
+   config file execution is lost. Only shared variables ($shv, $avp, etc)
+   should be used for any value that will be needed when the script is
+   resumed.
+
+   The result is stored in the pseudo-variable specified in the module
+   parameter 'result_pv'. This pseudo-variable is set after the response
+   is received.
+
+   Example 1.6. janssonrpc_request usage
+...
+janssonrpc_request("user_db", "get_user", '{"id": 1234}', "route=RESPONSE;retry=
+1");
+        ...
+
+route[RESPONSE] {
+        xlog("Result received: $var(result)");
+        ...
+}
+...
+
+4.3. Error Handling
+
+   When a route is specified as part of the janssonrpc_request() function,
+   a JSON object is stored in the result pseudo-variable (see
+   'Parameters').
+
+   The JSON object can be accessed using the jansson_get() function from
+   the jansson module and is of the form:
+...
+{
+  "result" : {...},
+  "error": {...},
+  "internal_error": { "code": ..., "message": ..., "data": ... }
+}
+...
+
+   'result' or 'error' come from the server and should follow the JSONRPC
+   specification. Keep in mind a server's 'error' might not follow the
+   JSONRPC specification and not include a 'code' and/or 'message', so be
+   sure to check that they are there before trying to use them.
+
+   When 'internal_error' is present, that means there was a problem with
+   sending or receiving the request. 'internal_error' contains a 'code'
+   which is an integer representing the type of error, a 'message' which
+   is the error in string form, and possibly 'data' which is usually the
+   failed request, which is optional and can be useful for debugging.
+
+   Here are the possible values for internal error codes:
+     * -1: "Failed to build request"
+     * -5: "Failed to send request"
+     * -10: "JSON parse error"
+     * -11: "Failed to convert response to a pseudo-variable"
+     * -20: "Bad response from server"
+     * -50: "Request retry failed"
+     * -75: "Request dropped for server disconnection"
+     * -100: "Message timeout"
+     * -1000: "There is a bug". Please report these errors to the module
+       maintainers.
+
+   Example 1.7. route example with internal_error handling
+...
+route {
+        janssonrpc_request("user_db", "get_user", '{"id": 1234}', "route=RESPONS
+E;retry=1");
+}
+
+route[RESPONSE] {
+        if(jansson_get($var(jsrpc_result), "internal_error", "$var(internal)"))
+{
+                route(INTERNAL);
+        } else if(jansson_get($var(jsrpc_result), "error", "$var(error)")) {
+                route(ERROR);
+        } else if(jansson_get($var(jsrpc_result), "result", "$var(result)")) {
+                route(RESULT);
+        }
+    t_reply("200", "OK");
+}
+
+route[RESULT] {
+        xlog("result is $var(result)\n");
+        xlog("success\n");
+}
+
+route[ERROR] {
+        xlog("There was an error\n");
+        if(jansson_get($var(error), "code", "$var(c)")) {
+                xlog("code is $var(c)\n");
+        }
+
+        if(jansson_get($var(error), "message", "$var(r)")) {
+                xlog("error is $var(r)\n");
+        }
+
+        if(jansson_get($var(error), "data", "$var(d)")) {
+                xlog("data is $var(d)\n");
+        }
+}
+
+route[INTERNAL] {
+        xlog("There was an internal error\n");
+
+        jansson_get($var(internal), "code", "$var(c)");
+        xlog("code is $var(c)\n");
+
+        jansson_get($var(internal), "message", "$var(r)");
+        xlog("error is $var(r)\n");
+
+        if(jansson_get($var(internal), "data", "$var(d)")) {
+                xlog("request is $var(d)\n");
+        }
+}
+...
diff --git a/modules/janssonrpc-c/doc/Makefile b/modules/janssonrpc-c/doc/Makefile
new file mode 100644
index 0000000..d7e5694
--- /dev/null
+++ b/modules/janssonrpc-c/doc/Makefile
@@ -0,0 +1,4 @@
+docs = janssonrpc-c.xml
+
+docbook_dir = ../../../docbook
+include $(docbook_dir)/Makefile.module
diff --git a/modules/janssonrpc-c/doc/janssonrpc-c.xml b/modules/janssonrpc-c/doc/janssonrpc-c.xml
new file mode 100644
index 0000000..13db606
--- /dev/null
+++ b/modules/janssonrpc-c/doc/janssonrpc-c.xml
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding='ISO-8859-1'?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../docbook/entities.xml">
+%docentities;
+
+]>
+
+<book xmlns:xi="http://www.w3.org/2001/XInclude">
+	<bookinfo>
+	<title>janssonrpc-c Module</title>
+	<productname class="trade">sip-router.org</productname>
+	<authorgroup>
+		<author>
+			<firstname>Joe</firstname>
+			<surname>Hillenbrand</surname>
+			<email>joe@flowroute.com</email>
+		</author>
+		<editor>
+			<firstname>Matthew</firstname>
+			<surname>Williams</surname>
+			<email>matthew@flowroute.com</email>
+		</editor>
+	</authorgroup>
+	<copyright>
+		<year>2013</year>
+		<holder>Flowroute LLC (flowroute.com)</holder>
+	</copyright>
+	</bookinfo>
+	<toc></toc>
+
+	<xi:include href="janssonrpc-c_admin.xml"/>
+
+</book>
diff --git a/modules/janssonrpc-c/doc/janssonrpc-c_admin.xml b/modules/janssonrpc-c/doc/janssonrpc-c_admin.xml
new file mode 100644
index 0000000..27f0f45
--- /dev/null
+++ b/modules/janssonrpc-c/doc/janssonrpc-c_admin.xml
@@ -0,0 +1,408 @@
+<?xml version="1.0" encoding='ISO-8859-1'?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../docbook/entities.xml">
+%docentities;
+
+]>
+<!-- Module User's Guide -->
+
+<chapter>
+
+	<title>&adminguide;</title>
+
+	<section>
+		<title>Overview</title>
+		<para>
+			This module provides access to JSON-RPC 2.0 services (operating over TCP/Netstrings)
+			in accordance with http://www.jsonrpc.org/specification. It uses JANSSON library for
+			JSON document management.
+		</para>
+		<para>
+			It uses t_suspend() and t_continue() from the TM module.
+		</para>
+		<para>
+			Note that after invoking an asyncronous operation, the processing
+			will continue later, in another application process. Therefore, do not
+			rely on variables stored in private memory, use shared memory if you
+			want to get values after the processing is resumend (e.g., $shv(...)
+			or htable $sht(...)).
+		</para>
+	</section>
+
+	<section>
+		<title>Dependencies</title>
+		<section>
+			<title>&kamailio; Modules</title>
+			<para>
+				The following modules must be loaded before this module:
+				<itemizedlist>
+					<listitem>
+						<emphasis>jansson</emphasis> - jansson json handling.
+					</listitem>
+					<listitem>
+						<emphasis>tm</emphasis> - transaction management.
+					</listitem>
+				</itemizedlist>
+			</para>
+		</section>
+		<section>
+			<title>External Libraries or Applications</title>
+			<para>
+				The following libraries or applications must be installed before running
+				&kamailio; with this module loaded:
+				<itemizedlist>
+					<listitem>
+						<emphasis>jansson (http://www.digip.org/jansson/)</emphasis>, tested with: 2.2+
+					</listitem>
+					<listitem>
+						<para>
+							<emphasis>libevent 2.0.5+ (http://libevent.org/)</emphasis>, tested with: 2.0.16
+						</para>
+					</listitem>
+				</itemizedlist>
+			</para>
+		</section>
+	</section>
+	<section>
+		<title>Parameters</title>
+		<section>
+			<title><varname>min_srv_ttl</varname> (integer)</title>
+			<para>
+				The minimum acceptable TTL in seconds for SRV DNS entries. This means that TTLs from the DNS will be ignored if they are lower than this value. It cannot be set lower than 1 second.
+			</para>
+			<para>
+			<emphasis>
+				Default is 5 seconds.
+			</emphasis>
+			</para>
+			<example>
+			<title>Set <varname>min_srv_ttl</varname> parameter</title>
+			<programlisting format="linespecific">
+...
+modparam("janssonrpc-c", "min_srv_ttl", 30)
+...
+			</programlisting>
+			<para>
+				This will set any SRV TTL lower than 30 seconds to 30 seconds.
+			</para>
+			</example>
+		</section>
+		<section>
+			<title><varname>result_pv</varname> (string)</title>
+			<para>
+				The PV spec where to store the result of a call to janssonrpc_request(). It can be any writtable PV.
+			</para>
+			<para>
+			<emphasis>
+				Default value is <quote>$var(jsrpc_result)</quote>.
+			</emphasis>
+			</para>
+			<example>
+			<title>Set <varname>result_pv</varname> parameter</title>
+			<programlisting format="linespecific">
+...
+modparam("janssonrpc-c", "result_pv", "$var(result)")
+...
+			</programlisting>
+		</example>
+		</section>
+		<section>
+			<title><varname>server</varname> (string)</title>
+			<para>
+				The server providing the remote jsonrpc service. Format can be "conn=example;addr=localhost;port=9999;priority=10;weight=20" or "conn=bar;srv=_sip._tcp.example.net".
+			</para>
+			<para>
+				<itemizedlist>
+					<listitem>
+						<emphasis>conn</emphasis> - name for a collection of servers (required).
+					</listitem>
+					<listitem>
+						<emphasis>srv</emphasis> - DNS SRV domain name (optional).
+					</listitem>
+					<listitem>
+						<emphasis>addr</emphasis> - host address (required, except when using srv).
+					</listitem>
+					<listitem>
+						<emphasis>port</emphasis> - host port (required, except when using srv).
+					</listitem>
+					<listitem>
+						<emphasis>priority</emphasis> - server are grouped by priority. Servers with higher priority (lower number) are used first. Default is 0. (optional when using addr, invalid otherwise).
+					</listitem>
+					<listitem>
+						<emphasis>weight</emphasis> - functions the same as a DNS SRV weight. Requests are distributed between servers of the same priority proportional to their weight. Default is 1. (optional when using addr, invalid otherwise).
+					</listitem>
+				</itemizedlist>
+			</para>
+			<example>
+				<title>Set <varname>server</varname> parameter</title>
+				<programlisting format="linespecific">
+...
+modparam("janssonrpc-c", "server", "conn=tests;srv=_test1._tcp.example.net");
+modparam("janssonrpc-c", "server", "conn=tests;srv=_test2._tcp.example.net");
+modparam("janssonrpc-c", "server", "conn=local;addr=localhost;port=8080;priority=10;weight=10");
+modparam("janssonrpc-c", "server", "conn=user_db;addr=rpc.prod.exmaple.net;port=5060;priority=10;weight=10");
+...
+				</programlisting>
+			</example>
+		</section>
+		<section>
+			<title><varname>retry_codes</varname> (string)</title>
+			<para>
+				A comma delimited list of error codes or error code ranges to automatically schedule a request retry if received.
+			</para>
+			<para>
+				This will only be used if there is no route specified for the request.
+			</para>
+			<para>
+				An error code can be any interger, but is typically a negative number.
+			</para>
+			<para>
+				An error code range is delimited by "<emphasis>..</emphasis>" . For example, "-32099..-32000".
+			</para>
+			<para>
+				Spaces are ignored.
+			</para>
+			<example>
+				<title>Set <varname>retry_codes</varname> parameter</title>
+				<programlisting format="linespecific">
+...
+modparam("janssonrpc-s", "retry_codes", "-32603, -32000..-32099");
+...
+				</programlisting>
+			</example>
+		</section>
+	</section>
+	<section>
+		<title>Functions</title>
+		<section>
+			<title>
+				<function moreinfo="none">janssonrpc_notification(conn, method, parameters)</function>
+			</title>
+			<para>
+				<itemizedlist>
+					<listitem>
+						<emphasis>conn</emphasis> - name for a collection of servers (required)
+					</listitem>
+					<listitem>
+						<emphasis>method</emphasis> - jsonrpc method (required)
+					</listitem>
+					<listitem>
+						<emphasis>params</emphasis> - jsonrpc request params (required)
+						Use $null or empty string to not send any parameters in the jsonrpc notification.
+					</listitem>
+				</itemizedlist>
+			</para>
+			<para>
+				Unlike janssonrpc_request (below), notifications do not receive a response.
+				Script processing continues in the usual fashion as soon as the notification
+				has been sent.
+			</para>
+			<para>
+				If no servers can be reached, a message is sent to the logs.
+			</para>
+			<para>
+				The 'method' and 'params' can be a static string or dynamic string value with
+				config variables.
+			</para>
+			<example>
+				<title><function>janssonrpc_notification</function> usage</title>
+				<programlisting format="linespecific">
+...
+janssonrpc_notification("user_db", "update_user", '{"id": 1234, "name": "Daniel"}');
+...
+				</programlisting>
+			</example>
+		</section>
+		<section>
+			<title>
+				<function moreinfo="none">janssonrpc_request(conn, method, params[, options]])</function>
+			</title>
+			<para>
+				The conn, method, params, and options can be a static string or
+				a dynamic string value with config variables.
+			</para>
+			<para>
+				<itemizedlist>
+					<listitem>
+						<emphasis>conn</emphasis> - name for a collection of servers (required)
+					</listitem>
+					<listitem>
+						<emphasis>method</emphasis> - jsonrpc method (required)
+					</listitem>
+					<listitem>
+						<emphasis>params</emphasis> - jsonrpc request params (required)
+						Use $null or empty string to not send any parameters in the jsonrpc request.
+					</listitem>
+					<listitem>
+						<para><emphasis>options</emphasis></para>
+						<para>
+							Options for the janssonrpc_request function. Format can be "route=RESPONSE;retry=2;timeout=100".
+							All these parameters are optional.
+						</para>
+						<para>
+							<itemizedlist>
+								<listitem>
+									<emphasis>retry</emphasis> - number of times you retry a failed request. 
+									-1 means retry forever. Default is 0.
+									Request will be retried if they either timeout or fail to send.
+									Retries untilize exponential back off between successive retries,
+									up to 60 seconds. The equation for time between retries is:
+									<para>
+									time = n^2 * timeout (for time &lt; 60 seconds)
+									</para>
+									 where n is the number of times a request has been tried.
+								</listitem>
+								<listitem>
+									<emphasis>timeout</emphasis> - request timeout in milliseconds. Default is 500.
+								</listitem>
+								<listitem>
+									<emphasis>route</emphasis> - resume script execution at this route.
+								</listitem>
+							</itemizedlist>
+						</para>
+					</listitem>
+				</itemizedlist>
+			</para>
+			<para>
+				When a response is received, processing continues for the SIP request in the route specified.
+			</para>
+			<para>
+				If no route is specified, then any errors are logged and successes are ignored.
+				The function will also not interupt script execution.
+			</para>
+			<para>
+				Since the SIP request handling is resumed in another process,
+				the config file execution is lost. Only shared variables ($shv, $avp, etc)
+				should be used for any value that will be needed when the script is resumed.
+			</para>
+			<para>
+				The result is stored in the pseudo-variable specified in the module parameter 'result_pv'.
+				This pseudo-variable is set <emphasis>after</emphasis> the response is received.
+			</para>
+			<example>
+				<title><function>janssonrpc_request</function> usage</title>
+				<programlisting format="linespecific">
+...
+janssonrpc_request("user_db", "get_user", '{"id": 1234}', "route=RESPONSE;retry=1");
+	...
+
+route[RESPONSE] {
+	xlog("Result received: $var(result)");
+	...
+}
+...
+				</programlisting>
+			</example>
+		</section>
+		<section>
+			<title>
+				Error Handling
+			</title>
+			<para>
+				When a route is specified as part of the janssonrpc_request() function,
+				a JSON object is stored in the result pseudo-variable (see 'Parameters').
+			</para>
+			<para>
+				The JSON object can be accessed using the jansson_get() function
+				from the jansson module and is of the form:
+				<programlisting format="linespecific">
+...
+{
+  "result" : {...},
+  "error": {...},
+  "internal_error": { "code": ..., "message": ..., "data": ... }
+}
+...
+				</programlisting>
+			</para>
+			<para>
+				'result' or 'error' come from the server and should follow the
+				JSONRPC specification.  Keep in mind a server's 'error' might
+				not follow the JSONRPC specification and not include a 'code'
+				and/or 'message', so be sure to check that they are there
+				before trying to use them.
+			</para>
+			<para>
+				When 'internal_error' is present, that means there was a
+				problem with sending or receiving the request. 'internal_error'
+				contains a 'code' which is an integer representing the type of
+				error, a 'message' which is the error in string form, and
+				possibly 'data' which is usually the failed request, which is
+				optional and can be useful for debugging.
+			</para>
+			<para>
+				Here are the possible values for internal error codes:
+				<itemizedlist>
+					<listitem><emphasis>-1</emphasis>: "Failed to build request"</listitem>
+					<listitem><emphasis>-5</emphasis>: "Failed to send request"</listitem>
+					<listitem><emphasis>-10</emphasis>: "JSON parse error"</listitem>
+					<listitem><emphasis>-11</emphasis>: "Failed to convert response to a pseudo-variable"</listitem>
+					<listitem><emphasis>-20</emphasis>: "Bad response from server"</listitem>
+					<listitem><emphasis>-50</emphasis>: "Request retry failed"</listitem>
+					<listitem><emphasis>-75</emphasis>: "Request dropped for server disconnection"</listitem>
+					<listitem><emphasis>-100</emphasis>: "Message timeout"</listitem>
+					<listitem><emphasis>-1000</emphasis>: "There is a bug". Please report these errors to the module maintainers.</listitem>
+				</itemizedlist>
+			</para>
+			<example>
+				<title>route example with internal_error handling</title>
+				<programlisting format="linespecific">
+...
+route {
+	janssonrpc_request("user_db", "get_user", '{"id": 1234}', "route=RESPONSE;retry=1");
+}
+
+route[RESPONSE] {
+	if(jansson_get($var(jsrpc_result), "internal_error", "$var(internal)")) {
+		route(INTERNAL);
+	} else if(jansson_get($var(jsrpc_result), "error", "$var(error)")) {
+		route(ERROR);
+	} else if(jansson_get($var(jsrpc_result), "result", "$var(result)")) {
+		route(RESULT);
+	}
+    t_reply("200", "OK");
+}
+
+route[RESULT] {
+	xlog("result is $var(result)\n");
+	xlog("success\n");
+}
+
+route[ERROR] {
+	xlog("There was an error\n");
+	if(jansson_get($var(error), "code", "$var(c)")) {
+		xlog("code is $var(c)\n");
+	}
+
+	if(jansson_get($var(error), "message", "$var(r)")) {
+		xlog("error is $var(r)\n");
+	}
+
+	if(jansson_get($var(error), "data", "$var(d)")) {
+		xlog("data is $var(d)\n");
+	}
+}
+
+route[INTERNAL] {
+	xlog("There was an internal error\n");
+
+	jansson_get($var(internal), "code", "$var(c)");
+	xlog("code is $var(c)\n");
+
+	jansson_get($var(internal), "message", "$var(r)");
+	xlog("error is $var(r)\n");
+
+	if(jansson_get($var(internal), "data", "$var(d)")) {
+		xlog("request is $var(d)\n");
+	}
+}
+...
+				</programlisting>
+			</example>
+		</section>
+	</section>
+</chapter>
+
diff --git a/modules/janssonrpc-c/janssonrpc.h b/modules/janssonrpc-c/janssonrpc.h
new file mode 100644
index 0000000..cfdf5e3
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc.h
@@ -0,0 +1,137 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _JANSSONRPC_H_
+#define _JANSSONRPC_H_
+
+#ifdef TEST
+
+#include "unit_tests/test.h"
+
+#else
+
+#include "../../sr_module.h"
+#include "../jansson/jansson_utils.h"
+jansson_to_val_f jsontoval;
+pv_spec_t jsonrpc_result_pv;
+
+#endif
+
+#define JSONRPC_VERSION "2.0"
+
+#define JSONRPC_INTERNAL_SERVER_ERROR -32603
+#define JSONRPC_ERROR_NO_MEMORY -1;
+
+/* DEFAULTS */
+/* time (in ms) after which the error route is called */
+#define JSONRPC_DEFAULT_TIMEOUT     500
+#define JSONRPC_RESULT_STR "$var(jsrpc_result)"
+#define JSONRPC_DEFAULT_RETRY       0
+
+/* helpful macros */
+#define CHECK_MALLOC_VOID(p)  if(!(p)) {ERR("Out of memory!\n"); return;}
+#define CHECK_MALLOC(p)  if(!(p)) {ERR("Out of memory!\n"); return JSONRPC_ERROR_NO_MEMORY;}
+#define CHECK_MALLOC_NULL(p)  if(!(p)) {ERR("Out of memory!\n"); return NULL;}
+#define CHECK_MALLOC_GOTO(p,loc)  if(!(p)) {ERR("Out of memory!\n"); goto loc;}
+#define CHECK_AND_FREE(p) if((p)!=NULL) shm_free(p)
+#define CHECK_AND_FREE_EV(p) \
+	if((p) && event_initialized((p))) {\
+		event_del(p); \
+		event_free(p); \
+		p = NULL; \
+	}
+
+#define STR(ss) (ss).len, (ss).s
+/* The lack of parens is intentional; this is intended to be used in a list
+ * of multiple arguments.
+ *
+ * Usage: printf("my str %.*s", STR(mystr))
+ *
+ * Expands to: printf("my str %.*s", (mystr).len, (mystr).s)
+ * */
+
+
+#define PIT_MATCHES(param) \
+	(pit->name.len == sizeof((param))-1 && \
+		strncmp(pit->name.s, (param), sizeof((param))-1)==0)
+
+#include <jansson.h>
+#include <event.h>
+
+typedef void (*libev_cb_f)(int sock, short flags, void *arg);
+
+typedef struct retry_range {
+	int start;
+	int end;
+	struct retry_range* next;
+} retry_range_t;
+
+/* globals */
+int cmd_pipe;
+extern const str null_str;
+str result_pv_str;
+retry_range_t* global_retry_ranges;
+
+static inline str pkg_strdup(str src)
+{
+	str res;
+
+	if (!src.s) {
+		res.s = NULL;
+		res.len = 0;
+	} else if (!(res.s = (char *) pkg_malloc(src.len + 1))) {
+		res.len = 0;
+	} else {
+		strncpy(res.s, src.s, src.len);
+		res.s[src.len] = 0;
+		res.len = src.len;
+	}
+	return res;
+}
+
+static inline str shm_strdup(str src)
+{
+	str res;
+
+	if (!src.s) {
+		res.s = NULL;
+		res.len = 0;
+	} else if (!(res.s = (char *) shm_malloc(src.len + 1))) {
+		res.len = 0;
+	} else {
+		strncpy(res.s, src.s, src.len);
+		res.s[src.len] = 0;
+		res.len = src.len;
+	}
+	return res;
+}
+
+static inline struct timeval ms_to_tv(unsigned int time)
+{
+	struct timeval tv = {0,0};
+	tv.tv_sec = time/1000;
+	tv.tv_usec = ((time % 1000) * 1000);
+	return tv;
+}
+
+
+#endif /* _JSONRPC_H_ */
diff --git a/modules/janssonrpc-c/janssonrpc_connect.c b/modules/janssonrpc-c/janssonrpc_connect.c
new file mode 100644
index 0000000..bfe66c9
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_connect.c
@@ -0,0 +1,317 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <event.h>
+
+#include "../../sr_module.h"
+#include "../../route.h"
+#include "../../route_struct.h"
+#include "../../resolve.h"
+#include "../../parser/parse_param.h"
+#include "../../mem/mem.h"
+#include "../../lvalue.h"
+
+#include "netstring.h"
+#include "janssonrpc.h"
+#include "janssonrpc_request.h"
+#include "janssonrpc_io.h"
+#include "janssonrpc_srv.h"
+#include "janssonrpc_server.h"
+#include "janssonrpc_connect.h"
+
+void wait_server_backoff(unsigned int timeout /* seconds */,
+		jsonrpc_server_t* server, bool delay);
+
+void bev_connect(jsonrpc_server_t* server);
+
+void bev_disconnect(struct bufferevent* bev)
+{
+	// close bufferevent
+	if(bev != NULL) {
+		short enabled = bufferevent_get_enabled(bev);
+		if(EV_READ & enabled)
+			bufferevent_disable(bev, EV_READ);
+		if(EV_WRITE & enabled)
+			bufferevent_disable(bev, EV_WRITE);
+		bufferevent_free(bev);
+		bev = NULL;
+	}
+}
+
+
+/* This will immediately close a server socket and clean out any pending
+ * requests that are waiting on that socket.
+ * */
+void force_disconnect(jsonrpc_server_t* server)
+{
+	if(!server) {
+		ERR("Trying to disconnect a NULL server.\n");
+		return;
+	}
+
+	// clear the netstring buffer when disconnecting
+	free_netstring(server->buffer);
+	server->buffer = NULL;
+
+	server->status = JSONRPC_SERVER_DISCONNECTED;
+
+	// close bufferevent
+	bev_disconnect(server->bev);
+	INFO("Disconnected from server %.*s:%d for conn %.*s.\n",
+			STR(server->addr), server->port, STR(server->conn));
+
+
+	/* clean out requests */
+	jsonrpc_request_t* req = NULL;
+	int key = 0;
+	for (key=0; key < JSONRPC_DEFAULT_HTABLE_SIZE; key++) {
+		for (req = request_table[key]; req != NULL; req = req->next) {
+			if(req->server != NULL && req->server == server) {
+				fail_request(JRPC_ERR_SERVER_DISCONNECT, req,
+						"Failing request for server shutdown");
+			}
+		}
+	}
+}
+
+typedef struct server_backoff_args {
+	struct event* ev;
+	jsonrpc_server_t* server;
+	unsigned int timeout;
+} server_backoff_args_t;
+
+void server_backoff_cb(int fd, short event, void *arg)
+{
+	if(!arg)
+		return;
+
+	server_backoff_args_t* a = (server_backoff_args_t*)arg;
+	if(!a)
+		return;
+
+	unsigned int timeout = a->timeout;
+
+	/* exponential backoff */
+	if(timeout < 1) {
+		timeout = 1;
+	} else {
+		timeout = timeout * 2;
+		if(timeout > 60) {
+			timeout = 60;
+		}
+	}
+
+	close(fd);
+	CHECK_AND_FREE_EV(a->ev);
+	pkg_free(arg);
+
+	wait_server_backoff(timeout, a->server, false);
+}
+
+void wait_server_backoff(unsigned int timeout /* seconds */,
+		jsonrpc_server_t* server, bool delay)
+{
+	if(!server) {
+		ERR("Trying to close/reconnect a NULL server\n");
+		return;
+	}
+
+	if(delay == false) {
+		if (requests_using_server(server) <= 0) {
+			if(server->status == JSONRPC_SERVER_RECONNECTING) {
+				bev_connect(server);
+			} else if(server->status == JSONRPC_SERVER_CLOSING) {
+				close_server(server);
+			}
+			return;
+		}
+	}
+
+	const struct timeval tv = {timeout, 0};
+
+	server_backoff_args_t* args = pkg_malloc(sizeof(server_backoff_args_t));
+	CHECK_MALLOC_VOID(args);
+	memset(args, 0, sizeof(server_backoff_args_t));
+
+	args->ev = evtimer_new(global_ev_base, server_backoff_cb, (void*)args);
+	CHECK_MALLOC_GOTO(args->ev, error);
+
+	args->server = server;
+	args->timeout = timeout;
+
+	if(evtimer_add(args->ev, &tv)<0) {
+		ERR("event_add failed while setting request timer (%s).", strerror(errno));
+		goto error;
+	}
+
+	return;
+
+error:
+	ERR("schedule_server failed.\n");
+
+	if(args) {
+		if(args->ev) {
+			evtimer_del(args->ev);
+		}
+		pkg_free(args);
+	}
+
+	if (server->status == JSONRPC_SERVER_CLOSING) {
+		ERR("Closing server now...\n");
+		close_server(server);
+	} else if (server->status == JSONRPC_SERVER_RECONNECTING) {
+		ERR("Reconnecting server now...\n");
+		force_reconnect(server);
+	}
+}
+
+void wait_close(jsonrpc_server_t* server)
+{
+	if(!server) {
+		ERR("Trying to close null server.\n");
+		return;
+	}
+
+	server->status = JSONRPC_SERVER_CLOSING;
+	wait_server_backoff(1, server, false);
+}
+
+void wait_reconnect(jsonrpc_server_t* server)
+{
+	if(!server) {
+		ERR("Trying to reconnect null server.\n");
+		return;
+	}
+
+	server->status = JSONRPC_SERVER_RECONNECTING;
+	wait_server_backoff(1, server, false);
+}
+
+void connect_servers(jsonrpc_server_group_t** group)
+{
+	INIT_SERVER_LOOP
+	FOREACH_SERVER_IN(group)
+		server = wgroup->server;
+		if(server->status != JSONRPC_SERVER_FAILURE
+				&& server->status != JSONRPC_SERVER_RECONNECTING)
+		{
+			bev_connect(server);
+		}
+	ENDFOR
+}
+
+void force_reconnect(jsonrpc_server_t* server)
+{
+	INFO("Reconnecting to server %.*s:%d for conn %.*s.\n",
+			STR(server->addr), server->port, STR(server->conn));
+	force_disconnect(server);
+	bev_connect(server);
+}
+
+/* helper for bev_connect_cb() and bev_connect() */
+void connect_failed(jsonrpc_server_t* server)
+{
+	bev_disconnect(server->bev);
+
+	server->status = JSONRPC_SERVER_RECONNECTING;
+	wait_server_backoff(JSONRPC_RECONNECT_INTERVAL, server, true);
+}
+
+void bev_connect_cb(struct bufferevent* bev, short events, void* arg)
+{
+	jsonrpc_server_t* server = (jsonrpc_server_t*)arg;
+	if(!arg) {
+		ERR("Trying to connect null server\n");
+		return;
+	}
+
+	if (events & (BEV_EVENT_ERROR|BEV_EVENT_EOF)) {
+		WARN("Connection error for %.*s:%d\n", STR(server->addr), server->port);
+		if (events & BEV_EVENT_ERROR) {
+			int err = bufferevent_socket_get_dns_error(bev);
+			if(err) {
+				ERR("DNS error for %.*s: %s\n",
+					STR(server->addr), evutil_gai_strerror(err));
+			}
+		}
+		goto failed;
+	} else if(events & BEV_EVENT_CONNECTED) {
+
+		if (server->status == JSONRPC_SERVER_CONNECTED) {
+			return;
+		}
+
+		server->status = JSONRPC_SERVER_CONNECTED;
+		INFO("Connected to host %.*s:%d\n",
+				STR(server->addr), server->port);
+	}
+
+	return;
+
+failed:
+	connect_failed(server);
+}
+
+void bev_connect(jsonrpc_server_t* server)
+{
+	if(!server) {
+		ERR("Trying to connect null server\n");
+		return;
+	}
+
+	INFO("Connecting to server %.*s:%d for conn %.*s.\n",
+			STR(server->addr), server->port, STR(server->conn));
+
+	server->bev = bufferevent_socket_new(
+			global_ev_base,
+			-1,
+			BEV_OPT_CLOSE_ON_FREE);
+	if(!(server->bev)) {
+		ERR("Could not create bufferevent for  %.*s:%d\n", STR(server->addr), server->port);
+		connect_failed(server);
+		return;
+	}
+
+	bufferevent_setcb(
+			server->bev,
+			bev_read_cb,
+			NULL,
+			bev_connect_cb,
+			server);
+	bufferevent_enable(server->bev, EV_READ|EV_WRITE);
+	if(bufferevent_socket_connect_hostname(
+			server->bev,
+			global_evdns_base,
+			AF_UNSPEC,
+			server->addr.s,
+			server->port)<0) {
+		WARN("Failed to connect to %.*s:%d\n", STR(server->addr), server->port);
+		connect_failed(server);
+	}
+}
+
diff --git a/modules/janssonrpc-c/janssonrpc_connect.h b/modules/janssonrpc-c/janssonrpc_connect.h
new file mode 100644
index 0000000..a9ce8e4
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_connect.h
@@ -0,0 +1,49 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _JANSSONRPC_CONNECT_H_
+#define _JANSSONRPC_CONNECT_H_
+
+enum
+{ JSONRPC_SERVER_DISCONNECTED = 0
+, JSONRPC_SERVER_CONNECTED
+, JSONRPC_SERVER_CONNECTING
+, JSONRPC_SERVER_FAILURE
+, JSONRPC_SERVER_CLOSING
+, JSONRPC_SERVER_RECONNECTING
+};
+
+/* interval (in seconds) at which failed servers are retried */
+#define JSONRPC_RECONNECT_INTERVAL  3
+
+void force_disconnect(jsonrpc_server_t* server);
+/* Do not call force_disconnect() from outside the IO process.
+ * Server's have a bufferevent that is part of local memory and free'd
+ * at disconnect */
+
+void wait_close(jsonrpc_server_t* server);
+void wait_reconnect(jsonrpc_server_t* server);
+void connect_servers(jsonrpc_server_group_t** group);
+void force_reconnect(jsonrpc_server_t* server);
+void bev_connect(jsonrpc_server_t* server);
+
+#endif /* _JSONRPC_CONNECT_H_ */
diff --git a/modules/janssonrpc-c/janssonrpc_funcs.c b/modules/janssonrpc-c/janssonrpc_funcs.c
new file mode 100644
index 0000000..65b9b77
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_funcs.c
@@ -0,0 +1,265 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "../../mod_fix.h"
+#include "../../pvar.h"
+#include "../../lvalue.h"
+#include "../tm/tm_load.h"
+
+#include "janssonrpc.h"
+#include "janssonrpc_request.h"
+#include "janssonrpc_io.h"
+#include "janssonrpc_funcs.h"
+
+
+struct tm_binds tmb;
+
+int jsonrpc_request(struct sip_msg* _m,
+		char* _conn,
+		char* _method,
+		char* _params,
+		char* _options)
+{
+	str conn;
+	str method;
+	str params;
+	str options;
+	str route;
+	param_hooks_t phooks;
+	param_t* pit=NULL;
+	param_t* freeme=NULL;
+	int retry;
+	int timeout;
+	int retval = -1;
+
+	/* defaults */
+	options = null_str;
+	route = null_str;
+	timeout = JSONRPC_DEFAULT_TIMEOUT;
+	retry = JSONRPC_DEFAULT_RETRY;
+
+	if (get_str_fparam(&conn, _m, (fparam_t*)_conn) != 0) {
+		ERR("cannot get connection value\n");
+		return -1;
+	}
+
+	if (get_str_fparam(&method, _m, (fparam_t*)_method) != 0) {
+		ERR("cannot get method value\n");
+		return -1;
+	}
+
+	if (get_str_fparam(&params, _m, (fparam_t*)_params) != 0) {
+		ERR("cannot get params value\n");
+		return -1;
+	}
+
+	if(_options == NULL) {
+
+	} else if (get_str_fparam(&options, _m, (fparam_t*)_options) != 0) {
+		ERR("cannot get options value\n");
+		return -1;
+
+	} else {
+		if(options.len == 0) {
+			goto skip_parse;
+		}else if (options.len > 0 && options.s[options.len-1] == ';') {
+			options.len--;
+		}
+
+		if (parse_params(&options, CLASS_ANY, &phooks, &pit)<0) {
+			ERR("failed parsing params value\n");
+			return -1;
+		}
+
+		freeme = pit;
+
+		for (; pit;pit=pit->next)
+		{
+			if PIT_MATCHES("route") {
+				route = pkg_strdup(pit->body);
+				CHECK_MALLOC_GOTO(route.s, end);
+
+			} else if PIT_MATCHES("timeout") {
+				timeout = atoi(pit->body.s);
+
+			} else if PIT_MATCHES("retry") {
+				retry = atoi(pit->body.s);
+
+			} else {
+				ERR("Unrecognized option: %.*s\n", STR(pit->name));
+				goto end;
+			}
+		}
+	}
+skip_parse:
+
+	/* check options */
+	if(timeout < 1) {
+		ERR("invalid timeout option (%d). Must be > 0.\n", timeout);
+		goto end;
+	}
+
+	if(retry < -1) {
+		ERR("invalid retry option (%d). Must be > -2.\n", retry);
+		goto end;
+	}
+
+	retval = 0;
+
+	retval = mod_jsonrpc_request(
+		_m,                     /* sip_msg */
+		conn,                   /* connection group */
+		method,                 /* RPC method */
+		params,                 /* JSON param */
+		route,                  /* result route */
+		false,                  /* notify only */
+		retry,                  /* retry attempts */
+		(unsigned int)timeout   /* request timeout */
+		);
+
+end:
+	if(freeme) free_params(freeme);
+	if(route.s) pkg_free(route.s);
+	return retval;
+}
+
+int jsonrpc_notification(struct sip_msg* _m,
+		char* _conn,
+		char* _method,
+		char* _params)
+{
+	str conn;
+	str method;
+	str params;
+
+	if (get_str_fparam(&conn, _m, (fparam_t*)_conn) != 0) {
+		ERR("cannot get connection value\n");
+		return -1;
+	}
+
+	if (get_str_fparam(&method, _m, (fparam_t*)_method) != 0) {
+		ERR("cannot get method value\n");
+		return -1;
+	}
+
+	if (get_str_fparam(&params, _m, (fparam_t*)_params) != 0) {
+		ERR("cannot get params value\n");
+		return -1;
+	}
+
+	return mod_jsonrpc_request(
+		_m,          /* sip_msg */
+		conn,        /* connection group */
+		method,      /* RPC method */
+		params,      /* JSON param */
+		null_str,    /* result route */
+		true,        /* notify only */
+		0,           /* retry attempts */
+		0            /* request timeout */
+		);
+}
+
+int mod_jsonrpc_request(
+		struct sip_msg* msg,
+		str conn,
+		str method,
+		str params,
+		str route,
+		bool notify_only,
+		int retry,
+		unsigned int timeout
+	)
+{
+	unsigned int hash_index;
+	unsigned int label;
+
+	if(retry < -1) {
+		ERR("retry can't be less than -1\n");
+		return -1;
+	}
+
+
+
+	jsonrpc_req_cmd_t* req_cmd = create_req_cmd();
+	CHECK_MALLOC(req_cmd);
+
+	req_cmd->conn   = shm_strdup(conn);
+	CHECK_MALLOC_GOTO(req_cmd->conn.s, error);
+
+	req_cmd->method = shm_strdup(method);
+	CHECK_MALLOC_GOTO(req_cmd->conn.s, error);
+
+	if(params.s) {
+		req_cmd->params = shm_strdup(params);
+		CHECK_MALLOC_GOTO(req_cmd->params.s, error);
+	}
+
+	if(route.s) {
+		req_cmd->route = shm_strdup(route);
+		CHECK_MALLOC_GOTO(req_cmd->route.s, error);
+	}
+
+	req_cmd->msg = msg;
+	req_cmd->retry = retry;
+	req_cmd->notify_only = notify_only;
+	req_cmd->timeout = timeout;
+
+	if(notify_only || route.len <= 0) {
+		req_cmd->route = null_str;
+		if(send_pipe_cmd(CMD_SEND, req_cmd)<0) goto error;
+		return 1; /* continue script execution */
+	}
+
+	tm_cell_t *t = 0;
+	t = tmb.t_gett();
+	if (t==NULL || t==T_UNDEFINED)
+	{
+		if(tmb.t_newtran(msg)<0)
+		{
+			ERR("cannot create the transaction\n");
+			goto error;
+		}
+		t = tmb.t_gett();
+		if (t==NULL || t==T_UNDEFINED)
+		{
+			ERR("cannot look up the transaction\n");
+			goto error;
+		}
+	}
+
+	if (tmb.t_suspend(msg, &hash_index, &label) < 0) {
+		ERR("t_suspend() failed\n");
+		goto error;
+	}
+	req_cmd->t_hash = hash_index;
+	req_cmd->t_label = label;
+
+	if(send_pipe_cmd(CMD_SEND, req_cmd)<0) goto error;
+
+	return 0;
+
+error:
+	free_req_cmd(req_cmd);
+	ERR("failed to send request to io process\n");
+	return -1;
+}
+
diff --git a/modules/janssonrpc-c/janssonrpc_funcs.h b/modules/janssonrpc-c/janssonrpc_funcs.h
new file mode 100644
index 0000000..755ba4e
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_funcs.h
@@ -0,0 +1,62 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _JANSSONRPC_FUNCS_H_
+#define _JANSSONRPC_FUNCS_H_
+
+#include <stdbool.h>
+#include "../../parser/msg_parser.h"
+
+int jsonrpc_request(struct sip_msg* _m,
+		char* _conn,
+		char* _method,
+		char* _params,
+		char* _options);
+
+int jsonrpc_notification(struct sip_msg* msg,
+		char* conn,
+		char* method,
+		char* params);
+
+int mod_jsonrpc_request(
+		struct sip_msg* msg,
+		str conn,
+		str method,
+		str params,
+		str route,
+		bool notify_only,
+		int retry,
+		unsigned int timeout
+	);
+
+typedef int (*mod_jsonrpc_request_f)(
+		struct sip_msg* msg,
+		str conn,
+		str method,
+		str params,
+		str route,
+		bool notify_only,
+		unsigned int retry,
+		unsigned int timeout
+	);
+
+#endif /* _JSONRPC_FUNCS_H_ */
diff --git a/modules/janssonrpc-c/janssonrpc_global.c b/modules/janssonrpc-c/janssonrpc_global.c
new file mode 100644
index 0000000..83192ca
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_global.c
@@ -0,0 +1,29 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef TEST
+#include "../../sr_module.h"
+#else
+#include "unit_tests/test.h"
+#endif
+
+const str null_str = {0,0};
diff --git a/modules/janssonrpc-c/janssonrpc_io.c b/modules/janssonrpc-c/janssonrpc_io.c
new file mode 100644
index 0000000..0a4ebd6
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_io.c
@@ -0,0 +1,854 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <jansson.h>
+#include <event.h>
+#include <event2/dns.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <signal.h>
+
+#include "../../sr_module.h"
+#include "../../route.h"
+#include "../../mem/mem.h"
+#include "../../action.h"
+#include "../../route_struct.h"
+#include "../../lvalue.h"
+#include "../../rand/fastrand.h"
+#include "../tm/tm_load.h"
+#include "../jansson/jansson_utils.h"
+
+#include "janssonrpc.h"
+#include "janssonrpc_request.h"
+#include "janssonrpc_server.h"
+#include "janssonrpc_io.h"
+#include "janssonrpc_connect.h"
+#include "netstring.h"
+
+struct tm_binds tmb;
+
+void cmd_pipe_cb(int fd, short event, void *arg);
+void io_shutdown(int sig);
+
+int jsonrpc_io_child_process(int cmd_pipe)
+{
+	global_ev_base = event_base_new();
+	global_evdns_base = evdns_base_new(global_ev_base, 1);
+
+	set_non_blocking(cmd_pipe);
+	struct event* pipe_ev = event_new(global_ev_base, cmd_pipe, EV_READ | EV_PERSIST, cmd_pipe_cb, NULL);
+	if(!pipe_ev) {
+		ERR("Failed to create pipe event\n");
+		return -1;
+	}
+
+	if(event_add(pipe_ev, NULL)<0) {
+		ERR("Failed to start pipe event\n");
+		return -1;
+	}
+
+	connect_servers(global_server_group);
+
+#if 0
+	/* attach shutdown signal handler */
+	/* The shutdown handler are intended to clean up the remaining memory
+	 * in the IO process. However, catching the signals causes unpreditable
+	 * behavior in the Kamailio shutdown process, so this should be disabled
+	 * except when doing memory debugging. */
+	struct sigaction sa;
+	sigemptyset(&sa.sa_mask);
+	sa.sa_flags = 0;
+	sa.sa_handler = io_shutdown;
+	if(sigaction(SIGTERM, &sa, NULL) == -1) {
+		ERR("Failed to attach IO shutdown handler to SIGTERM\n");
+	} else if(sigaction(SIGINT, NULL, &sa) == -1) {
+		ERR("Failed to attach IO shutdown handler to SIGINT\n");
+	}
+#endif
+
+	if(event_base_dispatch(global_ev_base)<0) {
+		ERR("IO couldn't start event loop\n");
+		return -1;
+	}
+	return 0;
+}
+
+void io_shutdown(int sig)
+{
+	INFO("Shutting down JSONRPC IO process...\n");
+	lock_get(jsonrpc_server_group_lock); /* blocking */
+
+	INIT_SERVER_LOOP
+	FOREACH_SERVER_IN(global_server_group)
+		close_server(server);
+	ENDFOR
+
+	evdns_base_free(global_evdns_base, 0);
+	event_base_loopexit(global_ev_base, NULL);
+	event_base_free(global_ev_base);
+
+	lock_release(jsonrpc_server_group_lock);
+}
+
+int send_to_script(pv_value_t* val, jsonrpc_req_cmd_t* req_cmd)
+{
+	if(!(req_cmd)) return -1;
+
+	if(req_cmd->route.len <= 0) return -1;
+
+	jsonrpc_result_pv.setf(req_cmd->msg, &jsonrpc_result_pv.pvp, (int)EQ_T, val);
+
+	int n = route_lookup(&main_rt, req_cmd->route.s);
+	if(n<0) {
+		ERR("no such route: %s\n", req_cmd->route.s);
+		return -1;
+	}
+
+	struct action* route = main_rt.rlist[n];
+
+	if(tmb.t_continue(req_cmd->t_hash, req_cmd->t_label, route)<0) {
+		ERR("Failed to resume transaction\n");
+		return -1;
+	}
+	return 0;
+}
+
+json_t* internal_error(int code, json_t* data)
+{
+	json_t* ret = json_object();
+	json_t* inner = json_object();
+	char* message;
+
+	switch(code){
+	case JRPC_ERR_REQ_BUILD:
+		message = "Failed to build request";
+		break;
+	case JRPC_ERR_SEND:
+		message = "Failed to send";
+		break;
+	case JRPC_ERR_BAD_RESP:
+		message = "Bad response result";
+		json_object_set(ret, "data", data);
+		break;
+	case JRPC_ERR_RETRY:
+		message = "Retry failed";
+		break;
+	case JRPC_ERR_SERVER_DISCONNECT:
+		message = "Server disconnected";
+		break;
+	case JRPC_ERR_TIMEOUT:
+		message = "Message timeout";
+		break;
+	case JRPC_ERR_PARSING:
+		message = "JSON parse error";
+		break;
+	case JRPC_ERR_BUG:
+		message = "There is a bug";
+		break;
+	default:
+		ERR("Unrecognized error code: %d\n", code);
+		message = "Unknown error";
+		break;
+	}
+
+	json_t* message_js = json_string(message);
+	json_object_set(inner, "message", message_js);
+	if(message_js) json_decref(message_js);
+
+	json_t* code_js = json_integer(code);
+	json_object_set(inner, "code", code_js);
+	if(code_js) json_decref(code_js);
+
+	if(data) {
+		json_object_set(inner, "data", data);
+	}
+
+	json_object_set(ret, "internal_error", inner);
+	if(inner) json_decref(inner);
+	return ret;
+}
+
+void fail_request(int code, jsonrpc_request_t* req, char* err_str)
+{
+	char* req_s;
+	char* freeme = NULL;
+	pv_value_t val;
+	json_t* error;
+
+	if(!req) {
+null_req:
+		WARN("%s: (null)\n", err_str);
+		goto end;
+	}
+
+	if(!(req->cmd) || (req->cmd->route.len <= 0)) {
+no_route:
+		req_s = json_dumps(req->payload, JSON_COMPACT);
+		if(req_s) {
+			WARN("%s: \n%s\n", err_str, req_s);
+			free(req_s);
+			goto end;
+		}
+		goto null_req;
+	}
+
+	error = internal_error(code, req->payload);
+	jsontoval(&val, &freeme, error);
+	if(error) json_decref(error);
+	if(send_to_script(&val, req->cmd)<0) {
+		goto no_route;
+	}
+
+end:
+	if(freeme) free(freeme);
+	free_req_cmd(req->cmd);
+	free_request(req);
+}
+
+void timeout_cb(int fd, short event, void *arg)
+{
+	jsonrpc_request_t* req = (jsonrpc_request_t*)arg;
+	if(!req)
+		return;
+
+	if(!(req->server)) {
+		ERR("No server defined for request\n");
+		return;
+	}
+
+	if(schedule_retry(req)<0) {
+		fail_request(JRPC_ERR_TIMEOUT, req, "Request timeout");
+	}
+}
+
+
+int server_tried(jsonrpc_server_t* server, server_list_t* tried)
+{
+	if(!server)
+		return 0;
+
+	int t = 0;
+	for(;tried!=NULL;tried=tried->next)
+	{
+		if(tried->server &&
+			server == tried->server)
+		{
+			t = 1;
+		}
+	}
+	return t;
+}
+
+/* loadbalance_by_weight() uses an algorithm to randomly pick a server out of
+ * a list based on its relative weight.
+ *
+ * It is loosely inspired by this:
+ * http://eli.thegreenplace.net/2010/01/22/weighted-random-generation-in-python/
+ *
+ * The insert_server_group() function provides the ability to get the combined
+ * weight of all the servers off the head of the list, making it possible to
+ * compute in O(n) in the worst case and O(1) in the best.
+ *
+ * A random number out of the total weight is chosen. Each node is inspected and
+ * its weight added to a recurring sum. Once the sum is larger than the random
+ * number the last server that was seen is chosen.
+ *
+ * A weight of 0 will almost never be chosen, unless if maybe all the other
+ * servers are offline.
+ *
+ * The exception is when all the servers in a group have a weight of 0. In
+ * this case, the load should be distributed evenly across each of them. This
+ * requires finding the size of the list beforehand.
+ * */
+void loadbalance_by_weight(jsonrpc_server_t** s,
+		jsonrpc_server_group_t* grp, server_list_t* tried)
+{
+	*s = NULL;
+
+	if(grp == NULL) {
+		ERR("Trying to pick from an empty group\n");
+		return;
+	}
+
+	if(grp->type != WEIGHT_GROUP) {
+		ERR("Trying to pick from a non weight group\n");
+		return;
+	}
+
+	jsonrpc_server_group_t* head = grp;
+	jsonrpc_server_group_t* cur = grp;
+
+	unsigned int pick = 0;
+	if(head->weight == 0) {
+		unsigned int size = 0;
+		size = server_group_size(cur);
+		if(size == 0) return;
+
+		pick = fastrand_max(size-1);
+
+		int i;
+		for(i=0;
+			(i <= pick || *s == NULL)
+				&& cur != NULL;
+			i++, cur=cur->next)
+		{
+			if(cur->server->status == JSONRPC_SERVER_CONNECTED) {
+				if(!server_tried(cur->server, tried)
+					&& (cur->server->hwm <= 0
+						|| cur->server->req_count < cur->server->hwm))
+				{
+					*s = cur->server;
+				}
+			}
+		}
+	} else {
+		pick = fastrand_max(head->weight - 1);
+
+		unsigned int sum = 0;
+		while(1) {
+			if(cur == NULL) break;
+			if(cur->server->status == JSONRPC_SERVER_CONNECTED) {
+				if(!server_tried(cur->server, tried)
+					&& (cur->server->hwm <= 0
+						|| cur->server->req_count < cur->server->hwm))
+				{
+					*s = cur->server;
+				}
+			}
+			sum += cur->server->weight;
+			if(sum > pick && *s != NULL) break;
+			cur = cur->next;
+		}
+	}
+}
+
+int jsonrpc_send(str conn, jsonrpc_request_t* req, bool notify_only)
+{
+	char* json = (char*)json_dumps(req->payload, JSON_COMPACT);
+
+	char* ns;
+	size_t bytes;
+	bytes = netstring_encode_new(&ns, json, (size_t)strlen(json));
+
+	bool sent = false;
+	jsonrpc_server_group_t* c_grp = NULL;
+	if(global_server_group != NULL)
+		c_grp = *global_server_group;
+	jsonrpc_server_group_t* p_grp = NULL;
+	jsonrpc_server_group_t* w_grp = NULL;
+	jsonrpc_server_t* s = NULL;
+	server_list_t* tried_servers = NULL;
+	DEBUG("SENDING DATA\n");
+	for(; c_grp != NULL; c_grp = c_grp->next) {
+
+		if(strncmp(conn.s, c_grp->conn.s, c_grp->conn.len) != 0) continue;
+
+		for(p_grp = c_grp->sub_group; p_grp != NULL; p_grp = p_grp->next)
+		{
+			w_grp = p_grp->sub_group;
+			while(!sent) {
+				loadbalance_by_weight(&s, w_grp, tried_servers);
+				if (s == NULL || s->status != JSONRPC_SERVER_CONNECTED) {
+					break;
+				}
+
+				if(bufferevent_write(s->bev, ns, bytes) == 0) {
+					sent = true;
+					if(!notify_only) {
+						s->req_count++;
+						if (s->hwm > 0 && s->req_count >= s->hwm) {
+							WARN("%.*s:%d in connection group %.*s has exceeded its high water mark (%d)\n",
+									STR(s->addr), s->port,
+									STR(s->conn), s->hwm);
+						}
+					}
+					req->server = s;
+					break;
+				} else {
+					addto_server_list(s, &tried_servers);
+				}
+			}
+
+			if (sent) {
+				break;
+			}
+
+			WARN("Failed to send to priority group, %d\n", p_grp->priority);
+			if(p_grp->next != NULL) {
+				INFO("Proceeding to next priority group, %d\n",
+						p_grp->next->priority);
+			}
+		}
+
+		if (sent) {
+			break;
+		}
+
+	}
+
+	if(!sent) {
+		WARN("Failed to send to connection group, \"%.*s\"\n",
+				STR(conn));
+		if(schedule_retry(req)<0) {
+			fail_request(JRPC_ERR_RETRY, req, "Failed to schedule retry");
+		}
+	}
+
+	free_server_list(tried_servers);
+	if(ns) pkg_free(ns);
+	if(json) free(json);
+
+	if (sent && notify_only == false) {
+
+		const struct timeval tv = ms_to_tv(req->timeout);
+
+		req->timeout_ev = evtimer_new(global_ev_base, timeout_cb, (void*)req);
+		if(event_add(req->timeout_ev, &tv)<0) {
+			ERR("event_add failed while setting request timer (%s).",
+					strerror(errno));
+			return -1;
+		}
+	}
+
+	return sent;
+}
+
+
+void cmd_pipe_cb(int fd, short event, void *arg)
+{
+	struct jsonrpc_pipe_cmd *cmd;
+
+	if (read(fd, &cmd, sizeof(cmd)) != sizeof(cmd)) {
+		ERR("FATAL ERROR: failed to read from command pipe: %s\n",
+				strerror(errno));
+		return;
+	}
+
+
+	switch(cmd->type) {
+	case CMD_CLOSE:
+		if(cmd->server) {
+			wait_close(cmd->server);
+		}
+		goto end;
+		break;
+	case CMD_RECONNECT:
+		if(cmd->server) {
+			wait_reconnect(cmd->server);
+		}
+		goto end;
+		break;
+	case CMD_CONNECT:
+		if(cmd->server) {
+			bev_connect(cmd->server);
+		}
+		goto end;
+		break;
+	case CMD_UPDATE_SERVER_GROUP:
+		if(cmd->new_grp) {
+			jsonrpc_server_group_t* old_grp = *global_server_group;
+			*global_server_group = cmd->new_grp;
+			free_server_group(&old_grp);
+		}
+		lock_release(jsonrpc_server_group_lock);
+		goto end;
+		break;
+
+	case CMD_SEND:
+		break;
+
+	default:
+		ERR("Unrecognized pipe command: %d\n", cmd->type);
+		goto end;
+		break;
+	}
+
+	/* command is SEND */
+
+	jsonrpc_req_cmd_t* req_cmd = cmd->req_cmd;
+	if(req_cmd == NULL) {
+		ERR("req_cmd is NULL. Invalid send command\n");
+		goto end;
+	}
+
+	jsonrpc_request_t* req = NULL;
+	req = create_request(req_cmd);
+	if (!req || !req->payload) {
+		json_t* error = internal_error(JRPC_ERR_REQ_BUILD, NULL);
+		pv_value_t val;
+		char* freeme = NULL;
+		jsontoval(&val, &freeme, error);
+		if(req_cmd->route.len <=0 && send_to_script(&val, req_cmd)<0) {
+			ERR("Failed to build request (method: %.*s, params: %.*s)\n",
+					STR(req_cmd->method), STR(req_cmd->params));
+		}
+		if(freeme) free(freeme);
+		if(error) json_decref(error);
+		free_req_cmd(req_cmd);
+		goto end;
+	}
+
+	int sent = jsonrpc_send(req_cmd->conn, req, req_cmd->notify_only);
+
+	char* type;
+	if (sent<0) {
+		if (req_cmd->notify_only == false) {
+			type = "Request";
+		} else {
+			type = "Notification";
+		}
+		WARN("%s could not be sent to connection group: %.*s\n",
+				type, STR(req_cmd->conn));
+		fail_request(JRPC_ERR_SEND, req, "Failed to send request");
+	}
+
+end:
+	free_pipe_cmd(cmd);
+}
+
+int handle_response(json_t* response)
+{
+	int retval = 0;
+	jsonrpc_request_t* req = NULL;
+	json_t* return_obj = NULL;
+	json_t* internal = NULL;
+	char* freeme = NULL;
+
+
+	/* check if json object */
+	if(!json_is_object(response)){
+		WARN("jsonrpc response is not an object\n");
+		return -1;
+	}
+
+	/* check version */
+	json_t* version = json_object_get(response, "jsonrpc");
+	if(!version) {
+		WARN("jsonrpc response does not have a version.\n");
+		retval = -1;
+		goto end;
+	}
+
+	const char* version_s = json_string_value(version);
+	if(!version_s){
+		WARN("jsonrpc response version is not a string.\n");
+		retval = -1;
+		goto end;
+	}
+
+	if (strlen(version_s) != (sizeof(JSONRPC_VERSION)-1)
+			|| strncmp(version_s, JSONRPC_VERSION, sizeof(JSONRPC_VERSION)-1) != 0) {
+		WARN("jsonrpc response version is not %s. version: %s\n",
+				JSONRPC_VERSION, version_s);
+		retval = -1;
+		goto end;
+	}
+
+	/* check for an id */
+	json_t* _id = json_object_get(response, "id");
+	if(!_id) {
+		WARN("jsonrpc response does not have an id.\n");
+		retval = -1;
+		goto end;
+	}
+
+	int id = json_integer_value(_id);
+	if (!(req = pop_request(id))) {
+		/* don't fail the server for an unrecognized id */
+		retval = 0;
+		goto end;
+	}
+
+	return_obj = json_object();
+
+	json_t* error = json_object_get(response, "error");
+	json_t* result = json_object_get(response, "result");
+
+	if(error) {
+		json_object_set(return_obj, "error", error);
+	}
+
+	if(result) {
+		json_object_set(return_obj, "result", result);
+	}
+
+	if ((!result && !error) || (result && error)) {
+		WARN("bad response\n");
+		internal = internal_error(JRPC_ERR_BAD_RESP, req->payload);
+		json_object_update(return_obj, internal);
+		if(internal) json_decref(internal);
+	}
+
+	pv_value_t val;
+
+	if(jsontoval(&val, &freeme, return_obj)<0) {
+		fail_request(
+				JRPC_ERR_TO_VAL,
+				req,
+				"Failed to convert response json to pv\n");
+		retval = -1;
+		goto end;
+	}
+
+	char* error_s = NULL;
+
+	if(send_to_script(&val, req->cmd)>=0) {
+		goto free_and_end;
+	}
+
+	if(error) {
+		// get code from error
+		json_t* _code = json_object_get(error, "code");
+		if(_code) {
+			int code = json_integer_value(_code);
+
+			// check if code is in global_retry_ranges
+			retry_range_t* tmpr;
+			for(tmpr = global_retry_ranges;
+					tmpr != NULL;
+					tmpr = tmpr->next) {
+				if((tmpr->start < tmpr->end
+						&& tmpr->start <= code && code <= tmpr->end)
+				|| (tmpr->end < tmpr->start
+						&& tmpr->end <= code && code <= tmpr->start)
+				|| (tmpr->start == tmpr->end && tmpr->start == code)) {
+					if(schedule_retry(req)==0) {
+						goto end;
+					}
+					break;
+				}
+			}
+
+		}
+		error_s = json_dumps(error, JSON_COMPACT);
+		if(error_s) {
+			WARN("Request recieved an error: \n%s\n", error_s);
+			free(error_s);
+		} else {
+			fail_request(
+					JRPC_ERR_BAD_RESP,
+					req,
+					"Could not convert 'error' response to string");
+			retval = -1;
+			goto end;
+		}
+	}
+
+
+free_and_end:
+	free_req_cmd(req->cmd);
+	free_request(req);
+
+end:
+	if(freeme) free(freeme);
+	if(return_obj) json_decref(return_obj);
+	return retval;
+}
+
+void handle_netstring(jsonrpc_server_t* server)
+{
+	unsigned int old_count = server->req_count;
+	server->req_count--;
+	if (server->hwm > 0
+			&& old_count >= server->hwm
+			&& server->req_count < server->hwm) {
+		INFO("%.*s:%d in connection group %.*s is back to normal\n",
+				STR(server->addr), server->port, STR(server->conn));
+	}
+
+	json_error_t error;
+
+	json_t* res = json_loads(server->buffer->string, 0, &error);
+
+	if (res) {
+		if(handle_response(res)<0){
+			ERR("Cannot handle jsonrpc response: %s\n", server->buffer->string);
+		}
+		json_decref(res);
+	} else {
+		ERR("Failed to parse json: %s\n", server->buffer->string);
+		ERR("PARSE ERROR: %s at %d,%d\n",
+				error.text, error.line, error.column);
+	}
+}
+
+void bev_read_cb(struct bufferevent* bev, void* arg)
+{
+	jsonrpc_server_t* server = (jsonrpc_server_t*)arg;
+	int retval = 0;
+	while (retval == 0) {
+		int retval = netstring_read_evbuffer(bev, &server->buffer);
+
+		if (retval == NETSTRING_INCOMPLETE) {
+			return;
+		} else if (retval < 0) {
+			char* msg = "";
+			switch(retval) {
+			case NETSTRING_ERROR_TOO_LONG:
+				msg = "too long";
+				break;
+			case NETSTRING_ERROR_NO_COLON:
+				msg = "no colon after length field";
+				break;
+			case NETSTRING_ERROR_TOO_SHORT:
+				msg = "too short";
+				break;
+			case NETSTRING_ERROR_NO_COMMA:
+				msg = "missing comma";
+				break;
+			case NETSTRING_ERROR_LEADING_ZERO:
+				msg = "length field has a leading zero";
+				break;
+			case NETSTRING_ERROR_NO_LENGTH:
+				msg = "missing length field";
+				break;
+			case NETSTRING_INCOMPLETE:
+				msg = "incomplete";
+				break;
+			default:
+				ERR("bad netstring: unknown error (%d)\n", retval);
+				goto reconnect;
+			}
+			ERR("bad netstring: %s\n", msg);
+reconnect:
+			force_reconnect(server);
+			return;
+		}
+
+		handle_netstring(server);
+		free_netstring(server->buffer);
+		server->buffer = NULL;
+	}
+}
+
+int set_non_blocking(int fd)
+{
+	int flags;
+
+	flags = fcntl(fd, F_GETFL);
+	if (flags < 0)
+		return flags;
+	flags |= O_NONBLOCK;
+	if (fcntl(fd, F_SETFL, flags) < 0)
+		return -1;
+
+	return 0;
+}
+
+jsonrpc_pipe_cmd_t* create_pipe_cmd()
+{
+	jsonrpc_pipe_cmd_t* cmd = NULL;
+	cmd = (jsonrpc_pipe_cmd_t*)shm_malloc(sizeof(jsonrpc_pipe_cmd_t));
+	if(!cmd) {
+		ERR("Failed to malloc pipe cmd.\n");
+		return NULL;
+	}
+	memset(cmd, 0, sizeof(jsonrpc_pipe_cmd_t));
+
+	return cmd;
+}
+
+void free_pipe_cmd(jsonrpc_pipe_cmd_t* cmd)
+{
+	if(!cmd) return;
+
+	shm_free(cmd);
+}
+
+jsonrpc_req_cmd_t* create_req_cmd()
+{
+	jsonrpc_req_cmd_t* req_cmd = NULL;
+	req_cmd = (jsonrpc_req_cmd_t*)shm_malloc(sizeof(jsonrpc_req_cmd_t));
+	CHECK_MALLOC_NULL(req_cmd);
+	memset(req_cmd, 0, sizeof(jsonrpc_req_cmd_t));
+
+	req_cmd->conn = null_str;
+	req_cmd->method = null_str;
+	req_cmd->params = null_str;
+	req_cmd->route = null_str;
+	return req_cmd;
+}
+
+void free_req_cmd(jsonrpc_req_cmd_t* req_cmd)
+{
+	if(req_cmd) {
+		CHECK_AND_FREE(req_cmd->conn.s);
+		CHECK_AND_FREE(req_cmd->method.s);
+		CHECK_AND_FREE(req_cmd->params.s);
+		CHECK_AND_FREE(req_cmd->route.s);
+		shm_free(req_cmd);
+	}
+}
+
+int send_pipe_cmd(cmd_type type, void* data)
+{
+	char* name = "";
+	jsonrpc_pipe_cmd_t* cmd = NULL;
+	cmd = create_pipe_cmd();
+	CHECK_MALLOC(cmd);
+
+	cmd->type = type;
+
+	switch(type) {
+	case CMD_CONNECT:
+		cmd->server = (jsonrpc_server_t*)data;
+		name = "connect";
+		break;
+	case CMD_RECONNECT:
+		cmd->server = (jsonrpc_server_t*)data;
+		name = "reconnect";
+		break;
+	case CMD_CLOSE:
+		cmd->server = (jsonrpc_server_t*)data;
+		name = "close";
+		break;
+	case CMD_UPDATE_SERVER_GROUP:
+		cmd->new_grp = (jsonrpc_server_group_t*)data;
+		name = "update";
+		break;
+	case CMD_SEND:
+		cmd->req_cmd = (jsonrpc_req_cmd_t*)data;
+		name = "send";
+		break;
+	default:
+		ERR("Unknown command type %d", type);
+		goto error;
+	}
+
+	DEBUG("sending %s command\n", name);
+
+	if (write(cmd_pipe, &cmd, sizeof(cmd)) != sizeof(cmd)) {
+		ERR("Failed to send '%s' cmd to io pipe: %s\n", name, strerror(errno));
+		goto error;
+	}
+
+	return 0;
+error:
+	free_pipe_cmd(cmd);
+	return -1;
+}
diff --git a/modules/janssonrpc-c/janssonrpc_io.h b/modules/janssonrpc-c/janssonrpc_io.h
new file mode 100644
index 0000000..5abb75e
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_io.h
@@ -0,0 +1,90 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _JANSSONRPC_IO_H_
+#define _JANSSONRPC_IO_H_
+
+#include <jansson.h>
+#include <event2/bufferevent.h>
+#include <stdbool.h>
+#include "../../route_struct.h"
+#include "../../pvar.h"
+#include "janssonrpc_server.h"
+#include "janssonrpc_request.h"
+#include "janssonrpc.h"
+
+/* event bases */
+struct event_base* global_ev_base;
+struct evdns_base* global_evdns_base;
+
+typedef enum
+{ CMD_CONNECT = 1000
+, CMD_RECONNECT
+, CMD_CLOSE
+, CMD_UPDATE_SERVER_GROUP
+, CMD_SEND
+} cmd_type;
+
+typedef struct jsonrpc_req_cmd {
+	str method, params, route, conn;
+	unsigned int t_hash, t_label, timeout;
+	bool notify_only;
+	int retry;
+	struct sip_msg *msg;
+} jsonrpc_req_cmd_t;
+
+typedef struct jsonrpc_pipe_cmd jsonrpc_pipe_cmd_t;
+struct jsonrpc_pipe_cmd
+{
+	cmd_type type;
+	union {
+		jsonrpc_server_t* server;
+		jsonrpc_req_cmd_t* req_cmd;
+		jsonrpc_server_group_t* new_grp;
+	};
+};
+
+int jsonrpc_io_child_process(int data_pipe);
+int send_pipe_cmd(cmd_type type, void* data);
+int handle_response(json_t *response);
+jsonrpc_pipe_cmd_t* create_pipe_cmd();
+void free_pipe_cmd(jsonrpc_pipe_cmd_t* cmd);
+jsonrpc_req_cmd_t* create_req_cmd();
+void free_req_cmd(jsonrpc_req_cmd_t* cmd);
+int  set_non_blocking(int fd);
+void bev_read_cb(struct bufferevent* bev, void* arg);
+
+/* Remember to update the docs if you add or change these */
+typedef enum
+{ JRPC_ERR_BUG       = -1000
+, JRPC_ERR_TIMEOUT   = -100
+, JRPC_ERR_SERVER_DISCONNECT = -75
+, JRPC_ERR_RETRY     = -50
+, JRPC_ERR_BAD_RESP  = -20
+, JRPC_ERR_TO_VAL    = -11
+, JRPC_ERR_PARSING   = -10
+, JRPC_ERR_SEND      = -5
+, JRPC_ERR_REQ_BUILD = -1
+} jsonrpc_error;
+
+
+#endif /* _JSONRPC_IO_H_ */
diff --git a/modules/janssonrpc-c/janssonrpc_mod.c b/modules/janssonrpc-c/janssonrpc_mod.c
new file mode 100644
index 0000000..7db22cc
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_mod.c
@@ -0,0 +1,362 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <arpa/inet.h>
+#include <sys/types.h>
+#include <errno.h>
+
+#include "../../pvar.h"
+#include "../../mod_fix.h"
+#include "../../trim.h"
+#include "../../sr_module.h"
+#include "../../timer_proc.h"
+#include "../tm/tm_load.h"
+#include "../jansson/jansson_utils.h"
+
+#include "janssonrpc_funcs.h"
+#include "janssonrpc_request.h"
+#include "janssonrpc_io.h"
+#include "janssonrpc_connect.h"
+#include "janssonrpc_server.h"
+#include "janssonrpc_srv.h"
+#include "janssonrpc.h"
+
+
+MODULE_VERSION
+
+
+static int mod_init(void);
+static int child_init(int);
+void mod_destroy(void);
+int parse_server_param(modparam_t type, void* val);
+int parse_retry_codes_param(modparam_t type, void* val);
+int parse_min_ttl_param(modparam_t type, void* val);
+static int fixup_req(void** param, int param_no);
+static int fixup_req_free(void** param, int param_no);
+static int fixup_notify(void** param, int param_no);
+static int fixup_notify_free(void** param, int param_no);
+int		  fixup_pvar_shm(void** param, int param_no);
+
+int  pipe_fds[2] = {-1,-1};
+
+struct tm_binds tmb;
+
+/*
+ * Exported Functions
+ */
+int jsonrpc_request_no_options(struct sip_msg* msg,
+		char* conn,
+		char* method,
+		char* params) {
+	return jsonrpc_request(msg, conn, method, params, NULL);
+}
+
+static cmd_export_t cmds[]={
+	{"janssonrpc_request", (cmd_function)jsonrpc_request,
+		4, fixup_req, fixup_req_free, ANY_ROUTE},
+	{"jsansonrpc_request", (cmd_function)jsonrpc_request_no_options,
+		3, fixup_req, fixup_req_free, ANY_ROUTE},
+	{"janssonrpc_notification", (cmd_function)jsonrpc_notification,
+		3, fixup_notify, fixup_notify_free, ANY_ROUTE},
+	{"mod_janssonrpc_request", (cmd_function)mod_jsonrpc_request,
+		0, 0, 0, 0},
+	{0, 0, 0, 0, 0, 0}
+};
+
+/*
+ * Script Parameters
+ */
+static param_export_t mod_params[]={
+	{"server",      STR_PARAM|USE_FUNC_PARAM, (void*)parse_server_param},
+	{"retry_codes",  STR_PARAM|USE_FUNC_PARAM, (void*)parse_retry_codes_param},
+	{"min_srv_ttl", INT_PARAM|USE_FUNC_PARAM, (void*)parse_min_ttl_param},
+	{"result_pv",   STR_PARAM,                &result_pv_str.s},
+	{ 0,0,0 }
+};
+
+/*
+ * Exports
+ */
+struct module_exports exports = {
+		"janssonrpc-c",       /* module name */
+		DEFAULT_DLFLAGS, /* dlopen flags */
+		cmds,            /* Exported functions */
+		mod_params,      /* Exported parameters */
+		0,               /* exported statistics */
+		0,               /* exported MI functions */
+		0,               /* exported pseudo-variables */
+		0,               /* extra processes */
+		mod_init,        /* module initialization function */
+		0,               /* response function*/
+		mod_destroy,     /* destroy function */
+		child_init       /* per-child init function */
+};
+
+
+static int mod_init(void)
+{
+	/* load the tm functions  */
+	if(load_tm_api(&tmb)<0) return -1;
+
+	/* load json_to_val from json module */
+	jsontoval = (jansson_to_val_f)find_export("jansson_to_val", 0, 0);
+	if(jsontoval == 0) {
+		ERR("ERROR:jsonrpc:mod_init: cannot import json_to_val\n");
+		return -1;
+	}
+
+	/* setup result pvar */
+	if (result_pv_str.s == NULL)
+		result_pv_str.s = JSONRPC_RESULT_STR;
+	result_pv_str.len = strlen(result_pv_str.s);
+
+	if(pv_parse_spec(&result_pv_str, &jsonrpc_result_pv)<0) {
+		ERR("cannot parse result_pv: %.*s\n", STR(result_pv_str));
+		return -1;
+	}
+
+	if(!(pv_is_w(&jsonrpc_result_pv))) {
+		ERR("%.*s is read only\n", STR(result_pv_str));
+		return -1;
+	}
+
+	register_procs(1);
+	register_basic_timers(1);
+
+	if (pipe(pipe_fds) < 0) {
+		ERR("pipe() failed\n");
+		return -1;
+	}
+
+	if(jsonrpc_min_srv_ttl < ABSOLUTE_MIN_SRV_TTL) {
+		jsonrpc_min_srv_ttl = JSONRPC_DEFAULT_MIN_SRV_TTL; /* 5s */
+	}
+
+	return 0;
+}
+
+static int child_init(int rank)
+{
+	int pid;
+
+	if (rank>PROC_MAIN)
+		cmd_pipe = pipe_fds[1];
+
+	if (rank!=PROC_MAIN)
+		return 0;
+
+	jsonrpc_server_group_lock = lock_alloc();
+	if(jsonrpc_server_group_lock == NULL) {
+		ERR("cannot allocate the server_group_lock\n");
+		return -1;
+	}
+
+	if(lock_init(jsonrpc_server_group_lock) == 0) {
+		ERR("failed to initialized the server_group_lock\n");
+		lock_dealloc(jsonrpc_server_group_lock);
+		return -1;
+	}
+
+	srv_cb_params_t* params = (srv_cb_params_t*)shm_malloc(sizeof(srv_cb_params_t));
+	CHECK_MALLOC(params);
+	params->cmd_pipe = pipe_fds[1];
+	params->srv_ttl = jsonrpc_min_srv_ttl;
+
+	/* start timer to check SRV ttl every second */
+	if(fork_basic_timer(PROC_TIMER, "jsonrpc SRV timer", 1 /*socks flag*/,
+				refresh_srv_cb, (void*)params, ABSOLUTE_MIN_SRV_TTL)<0) {
+		ERR("Failed to start SRV timer\n");
+		return -1;
+	}
+
+	pid=fork_process(PROC_RPC, "jsonrpc io handler", 1);
+
+	if (pid<0)
+		return -1; /* error */
+	if(pid==0){
+		/* child */
+		close(pipe_fds[1]);
+		return jsonrpc_io_child_process(pipe_fds[0]);
+	}
+
+	return 0;
+}
+
+void mod_destroy(void)
+{
+	lock_get(jsonrpc_server_group_lock); /* blocking */
+	if(jsonrpc_server_group_lock) lock_dealloc(jsonrpc_server_group_lock);
+
+	free_server_group(global_server_group);
+	CHECK_AND_FREE(global_server_group);
+}
+
+int parse_server_param(modparam_t type, void* val)
+{
+	if(global_server_group == NULL) {
+		global_server_group = shm_malloc(sizeof(void*));
+		*global_server_group = NULL;
+	}
+	return jsonrpc_parse_server((char*)val, global_server_group);
+}
+
+/* helper function for parse_retry_codes_param */
+int s2i(char* str, int* result)
+{
+	char* endptr;
+	errno = 0;
+
+	long val = strtol(str, &endptr, 10);
+
+	if ((errno == ERANGE && (val == LONG_MAX || val == LONG_MIN))
+			|| (errno != 0 && val == 0)) {
+		ERR("%s is not a number: %s\n", str, strerror(errno));
+		return -1;
+	}
+
+	if (endptr == str) {
+		ERR("failed to convert %s to integer\n", str);
+		return -1;
+	}
+
+	*result = (int)val;
+	return 0;
+}
+
+int parse_retry_codes_param(modparam_t type, void* val)
+{
+	if (val==NULL) {
+		ERR("retry_codes cannot be NULL!\n");
+		return -1;
+	}
+
+	if (PARAM_TYPE_MASK(type) != STR_PARAM) {
+		ERR("retry_codes must be a string\n");
+		return -1;
+	}
+
+	global_retry_ranges = NULL;
+
+	char* save_comma;
+	char* save_elipse;
+	char* token;
+	char* start_s;
+	int start;
+	char* end_s;
+	int end;
+	char* codes_s = (char*)val;
+
+	char* tmp;
+	retry_range_t** tmp_range;
+	tmp_range = &global_retry_ranges;
+	for (tmp = codes_s; ; tmp = NULL) {
+		token = strtok_r(tmp, ",", &save_comma);
+		if (token == NULL)
+			break;
+
+		start_s = strtok_r(token, ".", &save_elipse);
+		if (start_s == NULL) {
+			continue;
+		}
+
+		if(s2i(start_s, &start)<0) return -1;
+
+		*tmp_range = shm_malloc(sizeof(retry_range_t));
+		CHECK_MALLOC(*tmp_range);
+		memset(*tmp_range, 0, sizeof(retry_range_t));
+
+		(*tmp_range)->start = start;
+
+		end_s = strtok_r(NULL, ".", &save_elipse);
+		if (end_s == NULL) {
+			end_s = start_s;
+		}
+
+		if(s2i(end_s, &end)<0) return -1;
+		(*tmp_range)->end = end;
+
+		tmp_range = &((*tmp_range)->next);
+	}
+
+	return 0;
+}
+
+int parse_min_ttl_param(modparam_t type, void* val)
+{
+	if (val==0) {
+		ERR("min_srv_ttl cannot be NULL!\n");
+		return -1;
+	}
+
+	if (PARAM_TYPE_MASK(type) != INT_PARAM) {
+		ERR("min_srv_ttl must be of type %d, not %d!\n", INT_PARAM, type);
+		return -1;
+	}
+
+	jsonrpc_min_srv_ttl = (int)(long)val;
+	if(jsonrpc_min_srv_ttl < ABSOLUTE_MIN_SRV_TTL) {
+		ERR("Cannot set min_srv_ttl lower than %d", ABSOLUTE_MIN_SRV_TTL);
+		return -1;
+	}
+
+	INFO("min_srv_ttl set to %d\n", jsonrpc_min_srv_ttl);
+
+	return 0;
+}
+
+/* Fixup Functions */
+
+static int fixup_req(void** param, int param_no)
+{
+	if (param_no <= 4) {
+		return fixup_spve_null(param, 1);
+	}
+	ERR("function takes at most 4 parameters.\n");
+	return -1;
+}
+
+static int fixup_req_free(void** param, int param_no)
+{
+	if (param_no <= 4) {
+		return fixup_free_spve_null(param, 1);
+	}
+	ERR("function takes at most 4 parameters.\n");
+	return -1;
+}
+
+static int fixup_notify(void** param, int param_no)
+{
+	if (param_no <= 3) {
+		return fixup_spve_null(param, 1);
+	}
+	ERR("function takes at most 3 parameters.\n");
+	return -1;
+}
+
+static int fixup_notify_free(void** param, int param_no)
+{
+	if (param_no <= 3) {
+		return fixup_free_spve_null(param, 1);
+	}
+	ERR("function takes at most 3 parameters.\n");
+	return -1;
+}
diff --git a/modules/janssonrpc-c/janssonrpc_request.c b/modules/janssonrpc-c/janssonrpc_request.c
new file mode 100644
index 0000000..39c7f31
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_request.c
@@ -0,0 +1,340 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+#include "../../sr_module.h"
+#include "../../mem/mem.h"
+
+#include "janssonrpc.h"
+#include "janssonrpc_request.h"
+#include "janssonrpc_io.h"
+
+int next_id = 1;
+
+int store_request(jsonrpc_request_t* req);
+
+/* for debugging only */
+void print_request(jsonrpc_request_t* req)
+{
+	if(!req) {
+		INFO("request is (null)\n");
+		return;
+	}
+
+	INFO("------request------\n");
+	INFO("| id: %d\n", req->id);
+
+	if(req->type == RPC_NOTIFICATION) {
+		INFO("| type: notification\n");
+	} else if(req->type == RPC_REQUEST) {
+		INFO("| type: request\n");
+	} else {
+		INFO("| type: unknown (%d)\n", (int)req->type);
+	}
+
+	if(!(req->server)) {
+		INFO("| server: (null)\n");
+	} else {
+		print_server(req->server);
+	}
+
+	if(!(req->cmd)) {
+		INFO("| cmd: (null)\n");
+	} else {
+		INFO("| cmd->route: %.*s\n", STR(req->cmd->route));
+	}
+
+	INFO("| payload: %s\n", json_dumps(req->payload, 0));
+	INFO("| retry: %d\n", req->retry);
+	INFO("| ntries: %d\n", req->ntries);
+	INFO("| timeout: %d\n", req->timeout);
+	INFO("\t-------------------\n");
+}
+
+void free_request(jsonrpc_request_t* req)
+{
+	if(!req)
+		return;
+
+	pop_request(req->id);
+
+	CHECK_AND_FREE_EV(req->retry_ev);
+	CHECK_AND_FREE_EV(req->timeout_ev);
+
+	if(req->payload) json_decref(req->payload);
+	pkg_free(req);
+}
+
+jsonrpc_request_t* create_request(jsonrpc_req_cmd_t* cmd)
+{
+	if (cmd == NULL) {
+		ERR("cmd is (null). Cannot build request.\n");
+		return NULL;
+	}
+
+	if (cmd->params.s == NULL) {
+		ERR("params is (null). Cannot build request.\n");
+		return NULL;
+	}
+
+	jsonrpc_request_t* req = (jsonrpc_request_t*)pkg_malloc(sizeof(jsonrpc_request_t));
+	if (!req) {
+		ERR("Out of memory!");
+		return NULL;
+	}
+	memset(req, 0, sizeof(jsonrpc_request_t));
+
+	if (cmd->notify_only) {
+		req->type = RPC_NOTIFICATION;
+	} else {
+		req->type = RPC_REQUEST;
+	}
+
+	/* settings for both notifications and requests */
+	req->ntries = 0;
+	req->next = NULL;
+
+	req->payload = json_object();
+	if(!(req->payload)) {
+		ERR("Failed to create request payload\n");
+		goto fail;
+	}
+
+	if(req->type == RPC_REQUEST) {
+		if (next_id>JSONRPC_MAX_ID) {
+			next_id = 1;
+		} else {
+			next_id++;
+		}
+		req->id = next_id;
+		req->timeout = cmd->timeout;
+
+		json_t* id_js = json_integer(next_id);
+		if(id_js) {
+			json_object_set(req->payload, "id", id_js);
+			json_decref(id_js);
+		} else {
+			ERR("Failed to create request id\n");
+			goto fail;
+		}
+
+		req->retry = cmd->retry;
+		req->timeout = cmd->timeout;
+		if (!store_request(req)) {
+			ERR("store_request failed\n");
+			goto fail;
+		}
+	} else if (req->type == RPC_NOTIFICATION) {
+		req->id = 0;
+		req->retry = 0;
+	} else {
+		ERR("Unknown RPC type: %d\n", (int)req->type);
+		goto fail;
+	}
+
+	json_t* version_js = json_string(JSONRPC_VERSION);
+	if(version_js) {
+		json_object_set(req->payload, "jsonrpc", version_js);
+		json_decref(version_js);
+	} else {
+		ERR("Failed to create request version\n");
+		goto fail;
+	}
+
+	json_t* method_js = json_string(cmd->method.s);
+	if(method_js) {
+		json_object_set(req->payload, "method", method_js);
+		json_decref(method_js);
+	} else {
+		ERR("Failed to create request method\n");
+		goto fail;
+	}
+
+	json_t* params = NULL;
+	json_error_t error;
+	if(cmd->params.len > 0) {
+		params = json_loads(cmd->params.s, 0, &error);
+		if(!params) {
+			ERR("Failed to parse json: %.*s\n", STR(cmd->params));
+			ERR("PARSE ERROR: %s at %d,%d\n",
+					error.text, error.line, error.column);
+			goto fail;
+		}
+	}
+
+	json_object_set(req->payload, "params", params);
+	if(!(req->payload)) {
+		ERR("Failed to add request payload params\n");
+		goto fail;
+	}
+
+	if(params) json_decref(params);
+
+	req->cmd = cmd;
+	return req;
+fail:
+	ERR("Failed to create request\n");
+	free_request(req);
+	return NULL;
+}
+
+void retry_cb(int fd, short event, void* arg)
+{
+	if(!arg)
+		return;
+
+	jsonrpc_request_t* req = (jsonrpc_request_t*)arg;
+
+	if(!(req->cmd)) {
+		ERR("request has no cmd\n");
+		goto error;
+	}
+
+	DEBUG("retrying request: id=%d\n", req->id);
+
+	if(jsonrpc_send(req->cmd->conn, req, 0)<0) {
+		goto error;
+	}
+
+	CHECK_AND_FREE_EV(req->retry_ev);
+	return;
+
+error:
+	fail_request(JRPC_ERR_SEND, req, "Retry failed to send request");
+}
+
+int schedule_retry(jsonrpc_request_t* req)
+{
+	if(!req) {
+		ERR("Trying to schedule retry for a null request.\n");
+		return -1;
+	}
+
+	if(req->retry == 0) {
+		return -1;
+	}
+
+	req->ntries++;
+	if(req->retry > 0 && req->ntries > req->retry) {
+		WARN("Number of retries exceeded. Failing request.\n");
+		return -1;
+	}
+
+	/* next retry in milliseconds */
+	unsigned int time = req->ntries * req->ntries * req->timeout;
+	if(time > RETRY_MAX_TIME) {
+		time = RETRY_MAX_TIME;
+	}
+
+	jsonrpc_request_t* new_req = create_request(req->cmd);
+
+	new_req->ntries = req->ntries;
+
+	free_request(req);
+
+	const struct timeval tv = ms_to_tv(time);
+
+	new_req->retry_ev = evtimer_new(global_ev_base, retry_cb, (void*)new_req);
+	if(evtimer_add(new_req->retry_ev, &tv)<0) {
+		ERR("event_add failed while setting request retry timer (%s).",
+				strerror(errno));
+		goto error;
+	}
+
+	return 0;
+error:
+	ERR("schedule_retry failed.\n");
+	return -1;
+}
+
+int id_hash(int id) {
+	return (id % JSONRPC_DEFAULT_HTABLE_SIZE);
+}
+
+jsonrpc_request_t* pop_request(int id)
+{
+	int key = id_hash(id);
+	jsonrpc_request_t* req = request_table[key];
+	jsonrpc_request_t* prev_req = NULL;
+
+	while (req && req->id != id) {
+		prev_req = req;
+		if (!(req = req->next)) {
+			break;
+		};
+	}
+
+	if (req && req->id == id) {
+		if (prev_req != NULL) {
+			prev_req->next = req->next;
+		} else {
+			request_table[key] = NULL;
+		}
+		return req;
+	}
+	return 0;
+}
+
+int store_request(jsonrpc_request_t* req)
+{
+	int key = id_hash(req->id);
+	jsonrpc_request_t* existing;
+
+	if ((existing = request_table[key])) { /* collision */
+		jsonrpc_request_t* i;
+		for(i=existing; i; i=i->next) {
+			if (i == NULL) {
+				i = req;
+				LM_ERR("!!!!!!!");
+				return 1;
+			}
+			if (i->next == NULL) {
+				i->next = req;
+				return 1;
+			}
+		}
+	} else {
+		request_table[key] = req;
+	}
+	return 1;
+}
+
+unsigned int requests_using_server(jsonrpc_server_t* server)
+{
+	unsigned int count = 0;
+	jsonrpc_request_t* req = NULL;
+	int key = 0;
+	for (key=0; key < JSONRPC_DEFAULT_HTABLE_SIZE; key++) {
+		for (req = request_table[key]; req != NULL; req = req->next) {
+			if(req->server
+					&& req->server == server) {
+				count++;
+			}
+		}
+	}
+	return count;
+}
+
diff --git a/modules/janssonrpc-c/janssonrpc_request.h b/modules/janssonrpc-c/janssonrpc_request.h
new file mode 100644
index 0000000..e38c08e
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_request.h
@@ -0,0 +1,65 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _JANSSONRPC_REQUEST_H_
+#define _JANSSONRPC_REQUEST_H_
+
+#include "janssonrpc_io.h"
+#include "janssonrpc_server.h"
+
+#define JSONRPC_DEFAULT_HTABLE_SIZE 500
+#define JSONRPC_MAX_ID 1000000
+#define RETRY_MAX_TIME 60000 /* milliseconds */
+
+typedef enum {
+	RPC_REQUEST,
+	RPC_NOTIFICATION
+} rpc_type;
+
+typedef struct jsonrpc_request jsonrpc_request_t;
+struct jsonrpc_request {
+	rpc_type type;
+	int id;
+	jsonrpc_request_t *next; /* pkg */
+	jsonrpc_server_t* server; /* shm */
+	jsonrpc_req_cmd_t* cmd; /* shm */
+	json_t* payload;
+	struct event* timeout_ev; /* pkg */
+	struct event* retry_ev; /* pkg */
+	int retry;
+	unsigned int ntries;
+	unsigned int timeout;
+};
+
+jsonrpc_request_t* request_table[JSONRPC_DEFAULT_HTABLE_SIZE];
+
+jsonrpc_request_t* create_request(jsonrpc_req_cmd_t* cmd);
+void print_request(jsonrpc_request_t* req);
+jsonrpc_request_t* pop_request(int id);
+unsigned int requests_using_server(jsonrpc_server_t* server);
+void free_request(jsonrpc_request_t* req);
+int schedule_retry(jsonrpc_request_t* req);
+
+int jsonrpc_send(str conn, jsonrpc_request_t* req, bool notify_only);
+void fail_request(int code, jsonrpc_request_t* req, char* error_str);
+
+#endif /* _JSONRPC_H_ */
diff --git a/modules/janssonrpc-c/janssonrpc_server.c b/modules/janssonrpc-c/janssonrpc_server.c
new file mode 100644
index 0000000..09286bc
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_server.c
@@ -0,0 +1,611 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+#include <event.h>
+
+#include "../../sr_module.h"
+#include "../../route.h"
+#include "../../route_struct.h"
+#include "../../resolve.h"
+#include "../../parser/parse_param.h"
+#include "../../mem/mem.h"
+#include "../../lvalue.h"
+
+#include "netstring.h"
+#include "janssonrpc.h"
+#include "janssonrpc_request.h"
+#include "janssonrpc_io.h"
+#include "janssonrpc_srv.h"
+#include "janssonrpc_server.h"
+#include "janssonrpc_connect.h"
+
+/* used for debugging only */
+void print_server(jsonrpc_server_t* server)
+{
+	INFO("\t----- server ------\n");
+	INFO("\t|pointer: %p\n", server);
+	INFO("\t|conn: %.*s\n", STR(server->conn));
+	INFO("\t|addr: %.*s\n", STR(server->addr));
+	switch (server->status) {
+	case JSONRPC_SERVER_CONNECTED:
+		INFO("\t|status: connected\n");
+		break;
+	case JSONRPC_SERVER_DISCONNECTED:
+		INFO("\t|status: disconnected\n");
+		break;
+	case JSONRPC_SERVER_FAILURE:
+		INFO("\t|status: failure\n");
+		break;
+	case JSONRPC_SERVER_CLOSING:
+		INFO("\t|status: closing\n");
+		break;
+	case JSONRPC_SERVER_RECONNECTING:
+		INFO("\t|status: reconnecting\n");
+		break;
+	default:
+		INFO("\t|status: invalid (%d)\n", server->status);
+		break;
+	}
+	INFO("\t|srv: %.*s\n", STR(server->srv));
+	INFO("\t|ttl: %d\n", server->ttl);
+	INFO("\t|port: %d\n", server->port);
+	INFO("\t|priority: %d\n", server->priority);
+	INFO("\t|weight: %d\n", server->weight);
+	INFO("\t|hwm: %d\n", server->hwm);
+	INFO("\t|req_count: %d\n", server->req_count);
+	if(server->added) {
+		INFO("\t|added: true\n");
+	} else {
+		INFO("\t|added: false\n");
+	}
+	INFO("\t-------------------\n");
+}
+
+/* used for debugging only */
+void print_group(jsonrpc_server_group_t** group)
+{
+	jsonrpc_server_group_t* grp = NULL;
+
+	INFO("group addr is %p\n", group);
+
+	if(group == NULL)
+		return;
+
+	for (grp=*group; grp != NULL; grp=grp->next) {
+		switch(grp->type) {
+		case CONN_GROUP:
+			INFO("Connection group: %.*s\n", STR(grp->conn));
+			print_group(&(grp->sub_group));
+			break;
+		case PRIORITY_GROUP:
+			INFO("Priority group: %d\n", grp->priority);
+			print_group(&(grp->sub_group));
+			break;
+		case WEIGHT_GROUP:
+			INFO("Weight group: %d\n", grp->weight);
+			print_server(grp->server);
+			break;
+		}
+	}
+}
+
+int jsonrpc_parse_server(char* server_s, jsonrpc_server_group_t **group_ptr)
+{
+	if(group_ptr == NULL) {
+		ERR("Trying to add server to null group ptr\n");
+		return -1;
+	}
+
+	str s;
+	param_hooks_t phooks;
+	param_t* pit=NULL;
+	param_t* freeme=NULL;
+	str conn;
+	str addr;
+	addr.s = NULL;
+	str srv;
+	srv.s = NULL;
+
+	unsigned int priority = JSONRPC_DEFAULT_PRIORITY;
+	unsigned int weight = JSONRPC_DEFAULT_WEIGHT;
+	unsigned int hwm = JSONRPC_DEFAULT_HWM;
+	unsigned int port = 0;
+
+	s.s = server_s;
+	s.len = strlen(server_s);
+	if (s.s[s.len-1] == ';')
+		s.len--;
+
+	if (parse_params(&s, CLASS_ANY, &phooks, &pit)<0) {
+		ERR("Failed parsing params value\n");
+		return -1;
+	}
+
+	freeme = pit;
+
+	for (; pit;pit=pit->next)
+	{
+		if PIT_MATCHES("conn") {
+			conn = shm_strdup(pit->body);
+			CHECK_MALLOC(conn.s);
+
+		} else if PIT_MATCHES("srv") {
+			srv = shm_strdup(pit->body);
+			CHECK_MALLOC(srv.s);
+
+		} else if PIT_MATCHES("addr") {
+			addr = shm_strdup(pit->body);
+			CHECK_MALLOC(addr.s);
+
+		} else if PIT_MATCHES("port") {
+			port = atoi(pit->body.s);
+
+		} else if PIT_MATCHES("priority") {
+			priority = atoi(pit->body.s);
+
+		} else if PIT_MATCHES("weight") {
+			weight = atoi(pit->body.s);
+
+		} else if PIT_MATCHES("hwm") {
+			hwm = atoi(pit->body.s);
+
+		} else if PIT_MATCHES("proto") {
+			if(strncmp(pit->body.s, "tcp", sizeof("tcp")-1) != 0) {
+				ERR("Unsupported proto=%.*s. Only tcp is supported.\n",
+						STR(pit->body));
+				goto error;
+			}
+		} else {
+			ERR("Unrecognized parameter: %.*s\n", STR(pit->name));
+			goto error;
+		}
+
+		DEBUG("%.*s = %.*s\n", STR(pit->name), STR(pit->body));
+	}
+
+	if(conn.s == NULL) {
+		ERR("No conn defined! conn parameter is required.\n");
+		goto error;
+	}
+
+	if (srv.s != NULL) {
+		if (addr.s != NULL
+			|| port != 0
+			|| weight != JSONRPC_DEFAULT_WEIGHT
+			|| priority != JSONRPC_DEFAULT_PRIORITY) {
+			ERR("addr, port, weight, and priority are not supported when using srv\n");
+			goto error;
+		}
+
+		if (jsonrpc_server_from_srv(conn, srv, hwm, group_ptr)<0) goto error;
+
+	} else {
+
+		if (addr.s == NULL || port == 0) {
+			ERR("no address/port defined\n");
+			goto error;
+		}
+
+		jsonrpc_server_t* server = create_server();
+		CHECK_MALLOC(server);
+
+		server->conn = conn;
+		server->addr = addr;
+		server->port = port;
+		server->priority = priority;
+		server->weight = weight;
+		server->hwm = hwm;
+
+		if(jsonrpc_add_server(server, group_ptr)<0) goto error;
+	}
+
+	//print_group(group_ptr); /* debug */
+
+	CHECK_AND_FREE(srv.s);
+	if (freeme) free_params(freeme);
+	return 0;
+
+error:
+	CHECK_AND_FREE(srv.s);
+	if (freeme) free_params(freeme);
+	return -1;
+}
+
+int jsonrpc_server_from_srv(str conn, str srv,
+		unsigned int hwm, jsonrpc_server_group_t** group_ptr)
+{
+	struct rdata *l, *head;
+	struct srv_rdata *srv_record;
+	str name;
+	unsigned int ttl = jsonrpc_min_srv_ttl;
+
+	jsonrpc_server_t* server = NULL;
+
+	resolv_init();
+
+	head = get_record(srv.s, T_SRV, RES_AR);
+	if (head == NULL) {
+		ERR("No SRV record returned for %.*s\n", STR(srv));
+		goto error;
+	}
+	for (l=head; l; l=l->next) {
+		if (l->type != T_SRV)
+			continue;
+		srv_record = (struct srv_rdata*)l->rdata;
+		if (srv_record == NULL) {
+			ERR("BUG: null rdata\n");
+			goto error;
+		}
+
+		if (l->ttl < jsonrpc_min_srv_ttl) {
+			ttl = jsonrpc_min_srv_ttl;
+		} else {
+			ttl = l->ttl;
+		}
+
+		name.s = srv_record->name;
+		name.len = srv_record->name_len;
+
+		DBG("server %s\n", srv_record->name);
+
+		server = create_server();
+		CHECK_MALLOC(server);
+
+		server->conn = shm_strdup(conn);
+		CHECK_MALLOC_GOTO(server->conn.s, error);
+
+		server->addr = shm_strdup(name);
+		CHECK_MALLOC_GOTO(server->addr.s, error);
+
+		server->srv = shm_strdup(srv);
+		CHECK_MALLOC_GOTO(server->srv.s, error);
+
+		server->port = srv_record->port;
+		server->priority = srv_record->priority;
+		server->weight = srv_record->weight;
+		server->ttl = ttl;
+		server->hwm = hwm;
+
+		if(jsonrpc_add_server(server, group_ptr)<0) goto error;
+	}
+
+	jsonrpc_srv_t* new_srv = create_srv(srv, conn, ttl);
+	addto_srv_list(new_srv, &global_srv_list);
+
+	free_rdata_list(head);
+
+	return 0;
+error:
+	CHECK_AND_FREE(server);
+	if (head) free_rdata_list(head);
+
+	return -1;
+}
+
+int create_server_group(server_group_t type, jsonrpc_server_group_t** grp)
+{
+	if(grp == NULL) {
+		ERR("Trying to dereference null group pointer\n");
+		return -1;
+	}
+
+	jsonrpc_server_group_t* new_grp =
+		shm_malloc(sizeof(jsonrpc_server_group_t));
+	CHECK_MALLOC(new_grp);
+
+	switch(type) {
+	case CONN_GROUP:
+		DEBUG("Creating new connection group\n");
+		new_grp->conn.s = NULL;
+		new_grp->conn.len = 0;
+		break;
+	case PRIORITY_GROUP:
+		DEBUG("Creating new priority group\n");
+		new_grp->priority = JSONRPC_DEFAULT_PRIORITY;
+		break;
+	case WEIGHT_GROUP:
+		DEBUG("Creating new weight group\n");
+		new_grp->server = NULL;
+		new_grp->weight = JSONRPC_DEFAULT_WEIGHT;
+		break;
+	}
+
+	new_grp->next = NULL;
+	new_grp->sub_group = NULL;
+	new_grp->type = type;
+	*grp = new_grp;
+	return 0;
+}
+
+void free_server_group(jsonrpc_server_group_t** grp)
+{
+	if(grp == NULL)
+		return;
+
+	jsonrpc_server_group_t* next = NULL;
+	jsonrpc_server_group_t* cgroup = NULL;
+	jsonrpc_server_group_t* pgroup = NULL;
+	jsonrpc_server_group_t* wgroup = NULL;
+
+	cgroup=*grp;
+	while(cgroup!=NULL) {
+		pgroup=cgroup->sub_group;
+		while(pgroup!=NULL) {
+			wgroup=pgroup->sub_group;
+			while(wgroup!=NULL) {
+				next = wgroup->next;
+				CHECK_AND_FREE(wgroup);
+				wgroup = next;
+			}
+			next = pgroup->next;
+			CHECK_AND_FREE(pgroup);
+			pgroup = next;
+		}
+		next = cgroup->next;
+		CHECK_AND_FREE(cgroup->conn.s);
+		CHECK_AND_FREE(cgroup);
+		cgroup = next;
+	}
+}
+
+int insert_server_group(jsonrpc_server_group_t* new_grp,
+		jsonrpc_server_group_t** parent)
+{
+	if(parent == NULL) {
+		ERR("Trying to insert into NULL group\n");
+		return -1;
+	}
+
+	jsonrpc_server_group_t* head = *parent;
+
+	if (head == NULL) {
+		*parent = new_grp;
+	} else {
+		if (new_grp->type != head->type) {
+			ERR("Inserting group (%d) into the wrong type of list (%d)\n",
+				new_grp->type, head->type);
+			return -1;
+		}
+
+		jsonrpc_server_group_t* current = head;
+		jsonrpc_server_group_t** prev = parent;
+
+		while (1) {
+			if(new_grp->type == PRIORITY_GROUP
+					&& new_grp->priority < current->priority) {
+			 /* Priority groups are organized in ascending order.*/
+				new_grp->next = current;
+				*prev = new_grp;
+				break;
+			} else if (new_grp->type == WEIGHT_GROUP ) {
+			/* Weight groups are special in how they are organized in order
+		     * to facilitate load balancing and weighted random selection.
+			 *
+			 * The weight in the head of a weight group list represents
+			 * the total weight of the list. Subsequent nodes represent the
+			 * remaining total.
+			 *
+			 * In order to achieve this, the weight to be inserted is added
+			 * to each node that is passed before insertion.
+			 *
+			 * Weight groups are organized in descending order.
+			 *
+			 * The actual weight of a node can be found in its server.
+			 * */
+				if(new_grp->server == NULL) {
+					ERR("Trying to insert an empty weight group.\n");
+					return -1;
+				}
+				if(new_grp->server->weight != new_grp->weight) {
+					ERR("Weight of the new node (%d) doesn't match its server (%d). This is a bug. Please report this to the maintainer.\n",
+							new_grp->server->weight, new_grp->weight);
+					return -1;
+				}
+				if(new_grp->weight > current->server->weight) {
+					new_grp->weight += current->weight;
+					new_grp->next = current;
+					*prev = new_grp;
+					break;
+				} else {
+					current->weight += new_grp->weight;
+				}
+			}
+
+			if(current->next == NULL) {
+				current->next = new_grp;
+				break;
+			}
+			prev = &((*prev)->next); // This is madness. Madness? THIS IS POINTERS!
+			current = current->next;
+		}
+	}
+	return 0;
+}
+
+unsigned int server_group_size(jsonrpc_server_group_t* grp)
+{
+	unsigned int size = 0;
+	for(;grp != NULL; grp=grp->next) {
+		size++;
+	}
+	return size;
+}
+
+jsonrpc_server_t* create_server()
+{
+	jsonrpc_server_t* server = shm_malloc(sizeof(jsonrpc_server_t));
+	CHECK_MALLOC_NULL(server);
+	memset(server, 0, sizeof(jsonrpc_server_t));
+
+	server->priority = JSONRPC_DEFAULT_PRIORITY;
+	server->weight = JSONRPC_DEFAULT_WEIGHT;
+	server->status = JSONRPC_SERVER_DISCONNECTED;
+
+	return server;
+}
+
+void free_server(jsonrpc_server_t* server)
+{
+	if(!server)
+		return;
+
+	CHECK_AND_FREE(server->conn.s);
+	CHECK_AND_FREE(server->addr.s);
+	CHECK_AND_FREE(server->srv.s);
+
+	if ((server->buffer)!=NULL) free_netstring(server->buffer);
+	memset(server, 0, sizeof(jsonrpc_server_t));
+	shm_free(server);
+	server = NULL;
+}
+
+int server_eq(jsonrpc_server_t* a, jsonrpc_server_t* b)
+{
+	if(!a || !b)
+		return 0;
+
+	if(!STR_EQ(a->conn, b->conn)) return 0;
+	if(!STR_EQ(a->srv, b->srv)) return 0;
+	if(!STR_EQ(a->addr, b->addr)) return 0;
+	if(a->port != b->port) return 0;
+	if(a->priority != b->priority) return 0;
+	if(a->weight != b->weight) return 0;
+
+	return 1;
+}
+
+int jsonrpc_add_server(jsonrpc_server_t* server, jsonrpc_server_group_t** group_ptr)
+{
+	jsonrpc_server_group_t* conn_grp = NULL;
+	jsonrpc_server_group_t* priority_grp = NULL;
+	jsonrpc_server_group_t* weight_grp = NULL;
+
+	if(group_ptr == NULL) {
+		ERR("Trying to add server to null group\n");
+		return -1;
+	}
+
+	if(create_server_group(WEIGHT_GROUP, &weight_grp) < 0) goto error;
+
+	weight_grp->weight = server->weight;
+	weight_grp->server = server;
+
+	/* find conn group */
+	for (conn_grp=*group_ptr; conn_grp != NULL; conn_grp=conn_grp->next) {
+		if (strncmp(conn_grp->conn.s, server->conn.s, server->conn.len) == 0)
+			break;
+	}
+
+	if (conn_grp == NULL) {
+		if(create_server_group(CONN_GROUP, &conn_grp) < 0) goto error;
+		if(create_server_group(PRIORITY_GROUP, &priority_grp) < 0) goto error;
+
+		priority_grp->priority = server->priority;
+		priority_grp->sub_group = weight_grp;
+
+		conn_grp->conn = shm_strdup(server->conn);
+		CHECK_MALLOC_GOTO(conn_grp->conn.s, error);
+
+		conn_grp->sub_group = priority_grp;
+		if(insert_server_group(conn_grp, group_ptr) < 0) goto error;
+		goto success;
+	}
+
+	/* find priority group */
+	for (priority_grp=conn_grp->sub_group;
+			priority_grp != NULL;
+			priority_grp=priority_grp->next) {
+		if (priority_grp->priority == server->priority) break;
+	}
+
+	if (priority_grp == NULL) {
+		if(create_server_group(PRIORITY_GROUP, &priority_grp) < 0) goto error;
+
+		priority_grp->priority = server->priority;
+		priority_grp->sub_group = weight_grp;
+
+		if(insert_server_group(priority_grp, &(conn_grp->sub_group)) < 0) goto error;
+		goto success;
+	}
+
+	if(insert_server_group(weight_grp, &(priority_grp->sub_group)) < 0) goto error;
+
+success:
+	return 0;
+error:
+	ERR("Failed to add server: %s, %s, %d\n",
+			server->conn.s, server->addr.s, server->port);
+	CHECK_AND_FREE(conn_grp);
+	CHECK_AND_FREE(priority_grp);
+	CHECK_AND_FREE(weight_grp);
+	CHECK_AND_FREE(server);
+	return -1;
+}
+
+void addto_server_list(jsonrpc_server_t* server, server_list_t** list)
+{
+	server_list_t* new_node = (server_list_t*)pkg_malloc(sizeof(server_list_t));
+	CHECK_MALLOC_VOID(new_node);
+
+	new_node->server = server;
+	new_node->next = NULL;
+
+	if (*list == NULL) {
+		*list = new_node;
+		return;
+	}
+
+	server_list_t* node = *list;
+	for(; node->next!=NULL; node=node->next);
+
+	node->next = new_node;
+}
+
+void free_server_list(server_list_t* list)
+{
+	if (!list)
+		return;
+
+	server_list_t* node = NULL;
+	for(node=list; node!=NULL; node=node->next)
+	{
+		pkg_free(node);
+	}
+}
+
+void close_server(jsonrpc_server_t* server)
+{
+	if(!server)
+		return;
+
+	INFO("Closing server %.*s:%d for conn %.*s.\n",
+			STR(server->addr), server->port, STR(server->conn));
+	force_disconnect(server);
+
+	free_server(server);
+}
+
diff --git a/modules/janssonrpc-c/janssonrpc_server.h b/modules/janssonrpc-c/janssonrpc_server.h
new file mode 100644
index 0000000..0c71630
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_server.h
@@ -0,0 +1,130 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _JANSSONRPC_SERVER_H_
+#define _JANSSONRPC_SERVER_H_
+
+#include <stdbool.h>
+#include <event.h>
+#include <event2/bufferevent.h>
+#include <event2/buffer.h>
+#include "../../locking.h"
+#include "netstring.h"
+
+/* interval (in seconds) at which failed servers are retried */
+#define JSONRPC_RECONNECT_INTERVAL  3
+
+/* default values */
+#define JSONRPC_DEFAULT_PRIORITY 0
+#define JSONRPC_DEFAULT_WEIGHT 1
+#define JSONRPC_DEFAULT_HWM 0 /* unlimited */
+
+typedef struct jsonrpc_server {
+	str conn, addr, srv; /* shared mem */
+	int port;
+	unsigned int  status, ttl, hwm;
+	unsigned int  req_count;
+	unsigned int priority, weight;
+	bool added;
+	struct bufferevent* bev; /* local mem */
+	netstring_t* buffer;
+} jsonrpc_server_t;
+
+typedef enum {
+	CONN_GROUP,
+	PRIORITY_GROUP,
+	WEIGHT_GROUP
+} server_group_t;
+
+/* servers are organized in the following order:
+ * 1) conn
+ * 2) priority
+ * 3) weight
+ ***/
+typedef struct jsonrpc_server_group {
+	server_group_t type;
+	struct jsonrpc_server_group* sub_group; // NULL when type is WEIGHT_GROUP
+	union {
+		str conn; // when type is CONN_GROUP
+		unsigned int priority; // when type is PRIORITY_GROUP
+		unsigned int weight; //when type is WEIGHT_GROUP
+	};
+	jsonrpc_server_t* server; // only when type is WEIGHT_GROUP
+	struct jsonrpc_server_group* next;
+} jsonrpc_server_group_t;
+
+gen_lock_t* jsonrpc_server_group_lock;
+
+typedef struct server_list {
+	jsonrpc_server_t* server;
+	struct server_list* next;
+} server_list_t;
+
+/* where all the servers are stored */
+jsonrpc_server_group_t** global_server_group;
+
+int  jsonrpc_parse_server(char *_server, jsonrpc_server_group_t** group_ptr);
+int jsonrpc_server_from_srv(str conn, str srv,
+		unsigned int hwm, jsonrpc_server_group_t** group_ptr);
+
+void close_server(jsonrpc_server_t* server);
+/* Do not call close_server() from outside the IO process.
+ * Server's have a bufferevent that is part of local memory and free'd
+ * at disconnect */
+
+jsonrpc_server_t* create_server();
+void free_server(jsonrpc_server_t* server);
+int create_server_group(server_group_t type, jsonrpc_server_group_t** new_grp);
+int jsonrpc_add_server(jsonrpc_server_t* server, jsonrpc_server_group_t** group);
+unsigned int  server_group_size(jsonrpc_server_group_t* group);
+void free_server_group(jsonrpc_server_group_t** grp);
+int server_eq(jsonrpc_server_t* a, jsonrpc_server_t* b);
+void addto_server_list(jsonrpc_server_t* server, server_list_t** list);
+void free_server_list(server_list_t* list);
+
+#define INIT_SERVER_LOOP  \
+	jsonrpc_server_group_t* cgroup = NULL; \
+	jsonrpc_server_group_t* pgroup = NULL; \
+	jsonrpc_server_group_t* wgroup = NULL; \
+	jsonrpc_server_t* server = NULL;
+
+#define FOREACH_SERVER_IN(ii) \
+	if(ii == NULL) { \
+		cgroup = NULL; \
+	} else { \
+		cgroup = *(ii); \
+	} \
+	pgroup = NULL; \
+	wgroup = NULL; \
+	server = NULL; \
+	for(; cgroup!=NULL; cgroup=cgroup->next) { \
+		for(pgroup=cgroup->sub_group; pgroup!=NULL; pgroup=pgroup->next) { \
+			for(wgroup=pgroup->sub_group; wgroup!=NULL; wgroup=wgroup->next) { \
+				server = wgroup->server;
+
+#define ENDFOR }}}
+
+/* debugging only */
+void print_server(jsonrpc_server_t* server);
+void print_group(jsonrpc_server_group_t** group);
+
+#endif /* _JSONRPC_SERVER_H_ */
diff --git a/modules/janssonrpc-c/janssonrpc_srv.c b/modules/janssonrpc-c/janssonrpc_srv.c
new file mode 100644
index 0000000..82d8298
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_srv.c
@@ -0,0 +1,315 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdbool.h>
+#include <errno.h>
+#include <string.h>
+#include <fcntl.h>
+
+#include "../../sr_module.h"
+#include "../../route.h"
+#include "../../route_struct.h"
+#include "../../resolve.h"
+#include "../../parser/parse_param.h"
+#include "../../mem/mem.h"
+#include "../../lvalue.h"
+#include "../../str.h"
+
+#include "janssonrpc.h"
+#include "janssonrpc_srv.h"
+#include "janssonrpc_request.h"
+#include "janssonrpc_io.h"
+#include "janssonrpc_server.h"
+
+int refresh_srv(jsonrpc_srv_t* srv_obj)
+{
+	DEBUG("Refreshing SRV for %.*s\n", STR(srv_obj->srv));
+	int retval = 0;
+
+	if(!srv_obj) {
+		ERR("Trying to refresh NULL SRV\n");
+		return -1;
+	}
+
+	unsigned int ttl = ABSOLUTE_MIN_SRV_TTL;
+	str srv = srv_obj->srv;
+	jsonrpc_server_group_t* conn_group = srv_obj->cgroup;
+
+	if(!conn_group) {
+		ERR("SRV (%.*s) has no connections\n", STR(srv));
+		return -1;
+	}
+
+	struct rdata *l, *head;
+	struct srv_rdata *srv_record;
+	str name;
+
+	jsonrpc_server_group_t* new_grp = NULL;
+
+	// dns lookup
+	head = get_record(srv.s, T_SRV, RES_AR);
+	if (head == NULL) {
+		ERR("No SRV record returned for %.*s\n", STR(srv));
+		return -1;
+	}
+
+	// get all the servers from the srv record
+	server_list_t* new_servers = NULL;
+	jsonrpc_server_t* new_server = NULL;
+	server_list_t* rm_servers = NULL;
+	jsonrpc_server_t* rm_server = NULL;
+	int iter = 0;
+	for (l=head, iter=0; l; l=l->next, iter++) {
+		if (l->type != T_SRV)
+			continue;
+		srv_record = (struct srv_rdata*)l->rdata;
+		if (srv_record == NULL) {
+			ERR("BUG: null rdata\n");
+			return -1;
+		}
+
+		if (l->ttl < jsonrpc_min_srv_ttl) {
+			ttl = jsonrpc_min_srv_ttl;
+		} else {
+			ttl = l->ttl;
+		}
+
+		srv_obj->ttl = ttl;
+
+		name.s = srv_record->name;
+		name.len = srv_record->name_len;
+
+		DBG("server %s\n", srv_record->name);
+
+		jsonrpc_server_group_t* cgroup = NULL;
+		for(cgroup=conn_group; cgroup!=NULL; cgroup=cgroup->next) {
+			new_server = create_server();
+			CHECK_MALLOC(new_server);
+
+			new_server->conn = shm_strdup(cgroup->conn);
+			CHECK_MALLOC(new_server->conn.s);
+
+			new_server->addr = shm_strdup(name);
+			CHECK_MALLOC(new_server->addr.s);
+
+			new_server->srv = shm_strdup(srv);
+			CHECK_MALLOC(new_server->srv.s);
+
+			new_server->port = srv_record->port;
+			new_server->priority = srv_record->priority;
+			new_server->weight = srv_record->weight;
+			new_server->ttl = ttl;
+			new_server->added = false;
+
+			addto_server_list(new_server, &new_servers);
+		}
+	}
+
+	if(iter <= 0) goto end;
+
+	/* aquire global_server_group lock */
+	/* this lock is only released when the old global_server_group
+	 * is freed in the IO process */
+	lock_get(jsonrpc_server_group_lock); /* blocking */
+	//print_group(global_server_group); /* debug */
+
+
+	INIT_SERVER_LOOP
+
+	// copy existing servers
+	server_list_t* node;
+	FOREACH_SERVER_IN(global_server_group)
+		server->added = false;
+		if(STR_EQ(server->srv, srv)) {
+			for(node=new_servers; node!=NULL; node=node->next) {
+				new_server = node->server;
+				if(server_eq(new_server, server)) {
+					new_server->added = true;
+					server->added = true;
+					server->ttl = srv_obj->ttl;
+					jsonrpc_add_server(server, &new_grp);
+				}
+			}
+		} else {
+			server->added = true;
+			jsonrpc_add_server(server, &new_grp);
+		}
+	ENDFOR
+
+	FOREACH_SERVER_IN(global_server_group)
+		if(server->added == false) {
+			addto_server_list(server, &rm_servers);
+		}
+	ENDFOR
+
+	// add and connect new servers
+	for(node=new_servers; node!=NULL; node=node->next) {
+		new_server = node->server;
+		if(new_server->added == false) {
+
+			jsonrpc_add_server(new_server, &new_grp);
+
+			if(send_pipe_cmd(CMD_CONNECT, new_server) <0) {
+				print_server(new_server);
+			}
+
+		} else {
+			free_server(new_server);
+		}
+	}
+
+	// close old servers
+	for(node=rm_servers; node!=NULL; node=node->next) {
+
+		rm_server = node->server;
+
+		if(send_pipe_cmd(CMD_CLOSE, rm_server) <0) {
+			print_server(rm_server);
+		}
+	}
+
+	if(send_pipe_cmd(CMD_UPDATE_SERVER_GROUP, new_grp)<0) {
+		free_server_group(&new_grp);
+		lock_release(jsonrpc_server_group_lock);
+	}
+
+end:
+	// free server lists
+	free_server_list(new_servers);
+	free_server_list(rm_servers);
+
+	return retval;
+}
+
+void free_srv(jsonrpc_srv_t* srv)
+{
+	if(!srv)
+		return;
+
+	CHECK_AND_FREE(srv->srv.s);
+
+	free_server_group(&(srv->cgroup));
+}
+
+jsonrpc_srv_t* create_srv(str srv, str conn, unsigned int ttl)
+{
+	jsonrpc_srv_t* new_srv = shm_malloc(sizeof(jsonrpc_srv_t));
+	if(!new_srv) goto error;
+	new_srv->srv = shm_strdup(srv);
+
+	if (ttl < jsonrpc_min_srv_ttl) {
+		new_srv->ttl = jsonrpc_min_srv_ttl;
+	} else {
+		new_srv->ttl = ttl;
+	}
+
+	if(create_server_group(CONN_GROUP, &(new_srv->cgroup))<0) goto error;
+	new_srv->cgroup->conn = shm_strdup(conn);
+	if(!(new_srv->cgroup->conn.s)) return NULL;
+
+	return new_srv;
+error:
+	ERR("create_srv failed\n");
+	free_srv(new_srv);
+	return NULL;
+}
+
+void refresh_srv_cb(unsigned int ticks, void* params)
+{
+	if(!params) {
+		ERR("params is (null)\n");
+		return;
+	}
+
+	if(!global_srv_list) {
+		return;
+	}
+
+	srv_cb_params_t* p = (srv_cb_params_t*)params;
+
+	cmd_pipe = p->cmd_pipe;
+	jsonrpc_min_srv_ttl = p->srv_ttl;
+
+	if(cmd_pipe == 0) {
+		ERR("cmd_pipe is not set\n");
+		return;
+	}
+
+	jsonrpc_srv_t* srv;
+	for(srv=global_srv_list; srv!=NULL; srv=srv->next) {
+		if(ticks % srv->ttl == 0) {
+			refresh_srv(srv);
+		}
+	}
+
+}
+
+void addto_srv_list(jsonrpc_srv_t* srv, jsonrpc_srv_t** list)
+{
+	if (*list == NULL) {
+		*list = srv;
+		return;
+	}
+
+	jsonrpc_srv_t* node = *list;
+	jsonrpc_srv_t* prev = *list;
+	jsonrpc_server_group_t* cgroup;
+	jsonrpc_server_group_t* cprev;
+	for(node=*list; node!=NULL; prev=node, node=node->next) {
+		if(STR_EQ(srv->srv, node->srv)) {
+			for(cgroup=node->cgroup, cprev=node->cgroup;
+					cgroup!=NULL;
+					cprev=cgroup, cgroup=cgroup->next) {
+				if(STR_EQ(cgroup->conn, srv->cgroup->conn)) {
+					INFO("Trying to add identical srv\n");
+					goto clean;
+				}
+			}
+			if(create_server_group(CONN_GROUP, &(cprev->next))<0) goto clean;
+			cprev->next->conn = shm_strdup(srv->cgroup->conn);
+			CHECK_MALLOC_GOTO(cprev->next->conn.s, clean);
+			node->ttl = srv->ttl;
+			goto clean;
+		}
+	}
+
+	prev->next = srv;
+	return;
+clean:
+	free_srv(srv);
+}
+
+void print_srv(jsonrpc_srv_t* list)
+{
+	INFO("------SRV list------\n");
+	jsonrpc_srv_t* node = NULL;
+	for(node=list; node!=NULL; node=node->next) {
+		INFO("-----------------\n");
+		INFO("| srv: %.*s\n", STR(node->srv));
+		INFO("| ttl: %d\n", node->ttl);
+		print_group(&(node->cgroup));
+		INFO("-----------------\n");
+	}
+}
+
diff --git a/modules/janssonrpc-c/janssonrpc_srv.h b/modules/janssonrpc-c/janssonrpc_srv.h
new file mode 100644
index 0000000..c902183
--- /dev/null
+++ b/modules/janssonrpc-c/janssonrpc_srv.h
@@ -0,0 +1,53 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _JANSSONRPC_SRV_H_
+#define _JANSSONRPC_SRV_H_
+
+#include "janssonrpc_server.h"
+
+typedef struct jsonrpc_srv jsonrpc_srv_t;
+struct jsonrpc_srv {
+	str srv;
+	unsigned int ttl;
+	jsonrpc_server_group_t* cgroup;
+	jsonrpc_srv_t* next;
+};
+
+typedef struct srv_cb_params {
+	int cmd_pipe;
+	unsigned int srv_ttl;
+} srv_cb_params_t;
+
+jsonrpc_srv_t* global_srv_list;
+
+unsigned int jsonrpc_min_srv_ttl;
+
+jsonrpc_srv_t* create_srv(str srv, str conn, unsigned int ttl);
+void addto_srv_list(jsonrpc_srv_t* srv, jsonrpc_srv_t** list);
+void refresh_srv_cb(unsigned int ticks, void* params);
+void print_srv(jsonrpc_srv_t* list);
+
+#define JSONRPC_DEFAULT_MIN_SRV_TTL 5
+#define ABSOLUTE_MIN_SRV_TTL 1
+
+#endif /* _JSONRPC_SRV_H_ */
diff --git a/modules/janssonrpc-c/netstring.c b/modules/janssonrpc-c/netstring.c
new file mode 100644
index 0000000..a559224
--- /dev/null
+++ b/modules/janssonrpc-c/netstring.c
@@ -0,0 +1,323 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <math.h>
+#include <sys/socket.h>
+#include "netstring.h"
+#include "janssonrpc.h"
+
+#ifdef TEST
+#include "unit_tests/test.h"
+#else
+#include "../../mem/mem.h"
+#endif
+
+
+void free_netstring(netstring_t* netstring) {
+	if(!netstring) return;
+	if(netstring->buffer) pkg_free(netstring->buffer);
+	pkg_free(netstring);
+}
+
+//TODO: refactor out common code in the following two functions
+
+int netstring_read_evbuffer(struct bufferevent *bev, netstring_t **netstring)
+{
+	int bytes, offset;
+	size_t read_len;
+	char *temp_buffer;
+	temp_buffer = NULL;
+	offset = 0;
+	struct evbuffer *ib = bufferevent_get_input(bev);
+
+	if (*netstring == NULL) {
+		/* No buffer yet. Peek at first 10 bytes, to get length and colon. */
+		unsigned char *lenstr;
+		int i, len;
+		struct evbuffer_ptr *search_end = pkg_malloc(sizeof(struct evbuffer_ptr));
+		CHECK_MALLOC(search_end);
+
+		i = evbuffer_get_length(ib);
+		len = ((NETSTRING_PEEKLEN <= i) ? (NETSTRING_PEEKLEN) : (i-1));
+		evbuffer_ptr_set(ib, search_end, len, EVBUFFER_PTR_SET);
+		struct evbuffer_ptr loc = evbuffer_search_range(ib, ":", 1, NULL, search_end);
+		pkg_free(search_end);
+		if (loc.pos < 0) {
+			// no colon found
+			if (i > NETSTRING_PEEKLEN)
+				return NETSTRING_ERROR_TOO_LONG;
+			// TODO: peek at what's available and return suitable errors
+			return NETSTRING_INCOMPLETE;
+		}
+
+
+		lenstr = pkg_malloc(loc.pos+1);
+		CHECK_MALLOC(lenstr);
+		bytes = evbuffer_remove(ib, lenstr, loc.pos+1);
+
+		/* First character must be a digit */
+		if (!isdigit(lenstr[0]))
+			return NETSTRING_ERROR_NO_LENGTH;
+
+		/* No leading zeros allowed! */
+		if (lenstr[0] == '0' && isdigit(lenstr[1]))
+			return NETSTRING_ERROR_LEADING_ZERO;
+		if (lenstr[loc.pos] != ':') {
+			return NETSTRING_ERROR_NO_COLON;
+		}
+		len = i = 0;
+
+		/* Read the number of bytes */
+		for (i = 0; i < loc.pos; i++) {
+			/* Accumulate each digit, assuming ASCII. */
+			len = len*10 + (lenstr[i] - '0');
+		}
+		pkg_free(lenstr);
+		/* alloc the memory needed for the whole netstring */
+		read_len = len+1;
+		temp_buffer = pkg_malloc(read_len);
+		CHECK_MALLOC(temp_buffer);
+
+		/* initialize the netstring struct */
+		*netstring = pkg_malloc(sizeof(netstring_t));
+		CHECK_MALLOC(netstring);
+		(*netstring)->read = 0;
+		(*netstring)->length = len;
+		(*netstring)->buffer = temp_buffer;
+		(*netstring)->string = NULL;
+	} else {
+		/* Continue reading into an existing buffer. */
+		offset = (*netstring)->read;
+		read_len = (*netstring)->length-offset+1;
+		temp_buffer = (*netstring)->buffer + offset;
+	}
+
+	/* Read from the evbuffer */
+	bytes = evbuffer_remove(ib, temp_buffer, read_len);
+	int total = (*netstring)->read += bytes;
+
+	/* See if we have the whole netstring yet */
+	if (read_len > bytes) {
+		return NETSTRING_INCOMPLETE;
+	}
+
+	/* Test for the trailing comma */
+	if (((*netstring)->buffer)[total-1] != ',') {
+		return NETSTRING_ERROR_NO_COMMA;
+	}
+
+	/* Replace the comma with \0 */
+	(*netstring)->buffer[total-1] = '\0';
+
+	/* Set the string pointer to the "body" of the netstring */
+	(*netstring)->string = (*netstring)->buffer;
+	return 0;
+}
+
+int netstring_read_fd(int fd, netstring_t **netstring)
+{
+	int bytes, offset;
+	size_t read_len;
+	char *temp_buffer;
+	temp_buffer = NULL;
+	offset = 0;
+
+	if (*netstring == NULL) {
+		/* No buffer yet. Peek at first 10 bytes, to get length and colon. */
+		char peek[10]={0};
+		bytes = recv(fd,peek,10,MSG_PEEK);
+
+		if (bytes < 3) return NETSTRING_INCOMPLETE;
+
+		/* No leading zeros allowed! */
+		if (peek[0] == '0' && isdigit(peek[1]))
+			return NETSTRING_ERROR_LEADING_ZERO;
+
+		/* The netstring must start with a number */
+		if (!isdigit(peek[0])) return NETSTRING_ERROR_NO_LENGTH;
+
+		int i, len;
+		len = i = 0;
+
+		/* Read the number of bytes */
+		for (i = 0; i < bytes && isdigit(peek[i]); i++) {
+			/* Error if more than 9 digits */
+			if (i >= 9) return NETSTRING_ERROR_TOO_LONG;
+			/* Accumulate each digit, assuming ASCII. */
+			len = len*10 + (peek[i] - '0');
+		}
+
+		/* Read the colon */
+		if (peek[i++] != ':') return NETSTRING_ERROR_NO_COLON;
+
+		/* alloc the memory needed for the whole netstring */
+		read_len = len+i+1;
+		temp_buffer = pkg_malloc(read_len);
+		CHECK_MALLOC(temp_buffer);
+
+		/* initialize the netstring struct */
+		*netstring = pkg_malloc(sizeof(netstring_t));
+		CHECK_MALLOC(netstring);
+		(*netstring)->start = i;
+		(*netstring)->read = 0;
+		(*netstring)->length = len;
+		(*netstring)->buffer = temp_buffer;
+		(*netstring)->string = NULL;
+	} else {
+		/* Continue reading into an existing buffer. */
+		offset = (*netstring)->read;
+		read_len = (*netstring)->start+(*netstring)->length-offset+1;
+		temp_buffer = (*netstring)->buffer + offset;
+	}
+
+	/* Read from the socket */
+	bytes = recv(fd, temp_buffer, read_len, 0);
+	int total = (*netstring)->read += bytes;
+
+	/* See if we have the whole netstring yet */
+	if (read_len > bytes) {
+		return NETSTRING_INCOMPLETE;
+	}
+
+	/* Test for the trailing comma */
+	if (((*netstring)->buffer)[total-1] != ',') {
+		return NETSTRING_ERROR_NO_COMMA;
+	}
+
+	/* Replace the comma with \0 */
+	(*netstring)->buffer[total-1] = '\0';
+
+	/* Set the string pointer to the "body" of the netstring */
+	(*netstring)->string = (*netstring)->buffer + (*netstring)->start;
+	return 0;
+}
+
+
+/* Reads a netstring from a `buffer` of length `buffer_length`. Writes
+   to `netstring_start` a pointer to the beginning of the string in
+   the buffer, and to `netstring_length` the length of the
+   string. Does not allocate any memory. If it reads successfully,
+   then it returns 0. If there is an error, then the return value will
+   be negative. The error values are:
+
+   NETSTRING_ERROR_TOO_LONG      More than 999999999 bytes in a field
+   NETSTRING_ERROR_NO_COLON      No colon was found after the number
+   NETSTRING_ERROR_TOO_SHORT     Number of bytes greater than buffer length
+   NETSTRING_ERROR_NO_COMMA      No comma was found at the end
+   NETSTRING_ERROR_LEADING_ZERO  Leading zeros are not allowed
+   NETSTRING_ERROR_NO_LENGTH     Length not given at start of netstring
+
+   If you're sending messages with more than 999999999 bytes -- about
+   1 GB -- then you probably should not be doing so in the form of a
+   single netstring. This restriction is in place partially to protect
+   from malicious or erroneous input, and partly to be compatible with
+   D. J. Bernstein's reference implementation.
+
+   Example:
+	if (netstring_read("3:foo,", 6, &str, &len) < 0) explode_and_die();
+*/
+
+int netstring_read(char *buffer, size_t buffer_length,
+			char **netstring_start, size_t *netstring_length)
+{
+	int i;
+	size_t len = 0;
+
+	/* Write default values for outputs */
+	*netstring_start = NULL; *netstring_length = 0;
+
+	/* Make sure buffer is big enough. Minimum size is 3. */
+	if (buffer_length < 3) return NETSTRING_ERROR_TOO_SHORT;
+
+	/* No leading zeros allowed! */
+	if (buffer[0] == '0' && isdigit(buffer[1]))
+		return NETSTRING_ERROR_LEADING_ZERO;
+
+	/* The netstring must start with a number */
+	if (!isdigit(buffer[0])) return NETSTRING_ERROR_NO_LENGTH;
+
+	/* Read the number of bytes */
+	for (i = 0; i < buffer_length && isdigit(buffer[i]); i++) {
+		/* Error if more than 9 digits */
+		if (i >= 9) return NETSTRING_ERROR_TOO_LONG;
+		/* Accumulate each digit, assuming ASCII. */
+		len = len*10 + (buffer[i] - '0');
+	}
+
+	/* Check buffer length once and for all. Specifically, we make sure
+		 that the buffer is longer than the number we've read, the length
+		 of the string itself, and the colon and comma. */
+	if (i + len + 1 >= buffer_length) return NETSTRING_ERROR_TOO_SHORT;
+
+	/* Read the colon */
+	if (buffer[i++] != ':') return NETSTRING_ERROR_NO_COLON;
+
+	/* Test for the trailing comma, and set the return values */
+	if (buffer[i + len] != ',') return NETSTRING_ERROR_NO_COMMA;
+	*netstring_start = &buffer[i]; *netstring_length = len;
+
+	return 0;
+}
+
+/* Return the length, in ASCII characters, of a netstring containing
+   `data_length` bytes. */
+size_t netstring_buffer_size(size_t data_length)
+{
+	if (data_length == 0) return 3;
+	return (size_t)ceil(log10((double)data_length + 1)) + data_length + 2;
+}
+
+/* Allocate and create a netstring containing the first `len` bytes of
+   `data`. This must be manually freed by the client. If `len` is 0
+   then no data will be read from `data`, and it may be NULL. */
+size_t netstring_encode_new(char **netstring, char *data, size_t len)
+{
+	char *ns;
+	size_t num_len = 1;
+
+	*netstring = NULL;
+
+	if (len == 0) {
+		ns = pkg_malloc(3);
+		if (!ns) {
+			return JSONRPC_ERROR_NO_MEMORY;
+		}
+		ns[0] = '0';
+		ns[1] = ':';
+		ns[2] = ',';
+	} else {
+		num_len = (size_t)ceil(log10((double)len + 1));
+		ns = pkg_malloc(num_len + len + 2);
+		if (!ns) {
+			return JSONRPC_ERROR_NO_MEMORY;
+		}
+		sprintf(ns, "%lu:", (unsigned long)len);
+		memcpy(ns + num_len + 1, data, len);
+		ns[num_len + len + 1] = ',';
+	}
+
+	*netstring = ns;
+	return num_len + len + 2;
+}
diff --git a/modules/janssonrpc-c/netstring.h b/modules/janssonrpc-c/netstring.h
new file mode 100644
index 0000000..edba4cc
--- /dev/null
+++ b/modules/janssonrpc-c/netstring.h
@@ -0,0 +1,62 @@
+/**
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef __NETSTRING_STREAM_H
+#define __NETSTRING_STREAM_H
+
+#include <string.h>
+#include <event2/bufferevent.h>
+
+typedef struct {
+	char* buffer;
+	char* string;
+	unsigned int start, read, length;
+} netstring_t;
+
+void free_netstring(netstring_t* netstring);
+
+int netstring_read_evbuffer(struct bufferevent *bev, netstring_t **netstring);
+
+int netstring_read_fd(int fd, netstring_t **netstring);
+
+int netstring_read(char *buffer, size_t buffer_length,
+		   char **netstring_start, size_t *netstring_length);
+
+size_t netstring_buffer_size(size_t data_length);
+
+size_t netstring_encode_new(char **netstring, char *data, size_t len);
+
+/* Errors that can occur during netstring parsing */
+typedef enum {
+	NETSTRING_ERROR_TOO_LONG = -1000,
+	NETSTRING_ERROR_NO_COLON,
+	NETSTRING_ERROR_TOO_SHORT,
+	NETSTRING_ERROR_NO_COMMA,
+	NETSTRING_ERROR_LEADING_ZERO,
+	NETSTRING_ERROR_NO_LENGTH,
+	NETSTRING_ERROR_BAD_FD,
+	NETSTRING_INCOMPLETE
+} netstring_errors;
+
+#define NETSTRING_PEEKLEN 10
+
+#endif
diff --git a/modules/janssonrpc-c/test/mem-test.sh b/modules/janssonrpc-c/test/mem-test.sh
new file mode 100755
index 0000000..5405101
--- /dev/null
+++ b/modules/janssonrpc-c/test/mem-test.sh
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+cd ../../../
+valgrind --leak-check=full ./kamailio -w . -E -f modules/jsonrpc-c/test/test.cfg -m 256 -M 256
diff --git a/modules/janssonrpc-c/test/run-tests.sh b/modules/janssonrpc-c/test/run-tests.sh
new file mode 100755
index 0000000..302b63b
--- /dev/null
+++ b/modules/janssonrpc-c/test/run-tests.sh
@@ -0,0 +1,4 @@
+#!/bin/bash
+
+cd ../../../
+./kamailio -w . -E -f modules/jsonrpc-c/test/test.cfg -m 256 -M 256
diff --git a/modules/janssonrpc-c/test/test.cfg b/modules/janssonrpc-c/test/test.cfg
new file mode 100644
index 0000000..6dd16cc
--- /dev/null
+++ b/modules/janssonrpc-c/test/test.cfg
@@ -0,0 +1,94 @@
+#
+# $Id$
+#
+# jsonrpc module testing script
+
+debug = 2
+memlog=1   # debug level is higher or equal memlog
+mem_summary=8
+log_stderror=yes
+fork=no
+children=1
+listen = 127.0.0.1:5060
+
+check_via=no    # (cmd. line: -v)
+dns=yes          # (cmd. line: -r)
+rev_dns=no      # (cmd. line: -R)
+sip_warning=yes
+
+# ------------------ module loading ----------------------------------
+
+loadpath "modules:modules_k"
+
+loadmodule "pv"
+loadmodule "tm"
+loadmodule "json"
+loadmodule "xlog"
+loadmodule "jsonrpc-c"
+
+#modparam("jsonrpc", "min_srv_ttl", 1);
+modparam("jsonrpc", "result_pv", "$var(foobar)");
+modparam("jsonrpc", "server", "conn=pingpong;addr=foobar;port=7080;priority=10;weight=0;hwm=1");
+#modparam("jsonrpc", "server", "conn=pingpong;addr=localhost;port=7081;priority=10;weight=0;hwm=10");
+#modparam("jsonrpc", "server", "conn=pingpong;addr=localhost;port=7082;priority=10;weight=0;hwm=10");
+#modparam("jsonrpc", "server", "conn=pingpong;addr=localhost;port=7083;priority=10;weight=0;hwm=10");
+#modparam("jsonrpc", "server", "conn=pingpong;addr=localhost;port=7084;priority=10;weight=0;hwm=1");
+#modparam("jsonrpc", "server", "conn=fail;addr=localhost;port=9999;priority=10;weight=0");
+#modparam("jsonrpc", "server", "conn=test0;srv=_test0._tcp.sandbox.internal");
+#modparam("jsonrpc", "server", "conn=test0;srv=_test1._tcp.sandbox.internal");
+#modparam("jsonrpc", "server", "conn=tests;srv=_test2._tcp.sandbox.internal");
+
+
+# ------------------- unit tests ------------------------------------
+
+route {
+
+    jsonrpc_request("test0", "echo", '[{"foo":"bar"}]', "route=RESPONSE;retry=10;timeout=30");
+
+    xlog("done\n");
+}
+
+route[RESPONSE] {
+    if(json_get($var(jsrpc_result), "internal_error", "$var(internal)")) {
+        route(INTERNAL);
+    } else if(json_get($var(jsrpc_result), "error", "$var(error)")) {
+        route(ERROR);
+    } else if(json_get($var(jsrpc_result), "result", "$var(result)")) {
+        route(RESULT);
+    }
+    t_reply("200", "OK");
+}
+
+route[RESULT] {
+    xlog("result is $var(result)\n");
+    xlog("success\n");
+}
+
+route[ERROR] {
+    xlog("There was an error\n");
+    if(json_get($var(error), "code", "$var(c)")) {
+        xlog("code is $var(c)\n");
+    }
+
+    if(json_get($var(error), "message", "$var(r)")) {
+        xlog("error is $var(r)\n");
+    }
+
+    if(json_get($var(error), "data", "$var(d)")) {
+        xlog("data is $var(d)\n");
+    }
+}
+
+route[INTERNAL] {
+    xlog("There was an internal error\n");
+
+    json_get($var(internal), "code", "$var(c)");
+    xlog("code is $var(c)\n");
+
+    json_get($var(internal), "message", "$var(r)");
+    xlog("error is $var(r)\n");
+
+    if(json_get($var(internal), "data", "$var(d)")) {
+        xlog("request is $var(d)\n");
+    }
+}
diff --git a/modules/janssonrpc-c/unit_tests/Makefile b/modules/janssonrpc-c/unit_tests/Makefile
new file mode 100644
index 0000000..5e6a937
--- /dev/null
+++ b/modules/janssonrpc-c/unit_tests/Makefile
@@ -0,0 +1,11 @@
+CC = gcc
+FILES = *.c ../netstring.c ../jsonrpc_global.c seatest/seatest.c
+OUT_EXE = test
+
+build: $(FILES)
+	$(CC) -std=gnu99 -pedantic -D TEST -o $(OUT_EXE) $(FILES) -lm -levent
+
+clean:
+	rm -f *.o core
+
+rebuild: clean build
diff --git a/modules/janssonrpc-c/unit_tests/netstring.c b/modules/janssonrpc-c/unit_tests/netstring.c
new file mode 100644
index 0000000..19a4589
--- /dev/null
+++ b/modules/janssonrpc-c/unit_tests/netstring.c
@@ -0,0 +1,351 @@
+/**
+ * $Id$
+ *
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include <stdlib.h>
+#include <stdio.h> //temp
+#include <sys/socket.h>
+#include <event2/event.h>
+#include <event2/buffer.h> //temp
+#include <event2/bufferevent.h>
+#include "test.h"
+#include "../netstring.h"
+
+
+int fd[2];
+const int writer = 0;
+const int reader = 1;
+struct event_base *evbase;
+struct bufferevent *bev;
+netstring_t* ns_buffer;
+char* ns;
+char* next;
+
+
+/* ***********************************************************************
+ *                  tests for netstring_read_evbuffer                    *
+ * ***********************************************************************/
+
+//
+// Test normal operation of netstring_read_fd, with data received in three chunks.
+//
+void ev_init(void (*cb)(struct bufferevent*, void*))
+{
+	ns_buffer = NULL;
+	evbase = event_base_new();
+	socketpair(PF_LOCAL, SOCK_STREAM, 0, fd);
+	evutil_make_socket_nonblocking(fd[reader]);
+	bev = bufferevent_socket_new(evbase, fd[reader], BEV_OPT_CLOSE_ON_FREE);
+	bufferevent_setcb(bev, cb, NULL, NULL, NULL);
+    bufferevent_enable(bev, EV_READ);
+}
+
+void read_evb_cb3(struct bufferevent *bev, void *ptr)
+{
+	int r = netstring_read_evbuffer(bev, &ns_buffer);
+	assert_int_equal(0, r);
+	if (r == 0)
+		assert_string_equal("foobar-bizbaz", ns_buffer->string);
+
+	int res = event_base_loopbreak(evbase);
+	return;
+}
+
+void read_evb_cb2(struct bufferevent *bev, void *ptr)
+{
+	assert_int_equal(NETSTRING_INCOMPLETE, netstring_read_evbuffer(bev, &ns_buffer));
+	send(fd[writer], next, 10, 0);
+	bufferevent_setcb(bev, read_evb_cb3, NULL, NULL, NULL);
+	return;
+}
+
+void read_evb_cb1(struct bufferevent *bev, void *ptr)
+{
+	assert_int_equal(NETSTRING_INCOMPLETE, netstring_read_evbuffer(bev, &ns_buffer));
+	send(fd[writer], next, 5, 0);
+	next = next+5;
+	bufferevent_setcb(bev, read_evb_cb2, NULL, NULL, NULL);
+	return;
+}
+
+void test_read_evbuffer()
+{
+	ns = "13:foobar-bizbaz,";
+	ev_init(read_evb_cb1);
+	send(fd[writer], ns, 2, 0);
+	next = ns+2;
+	event_base_dispatch(evbase);
+}
+
+void test_read_evbuffer_one_chunk()
+{
+	ns = "13:foobar-bizbaz,";
+	ev_init(read_evb_cb3);
+	send(fd[writer], ns, strlen(ns), 0);
+	event_base_dispatch(evbase);
+}
+
+//
+// Abnormal test scenarios for netstring_read_evbuffer
+//
+
+void read_evb_leading_zero_cb()
+{
+	assert_int_equal(NETSTRING_ERROR_LEADING_ZERO, netstring_read_evbuffer(bev, &ns_buffer));
+	int res = event_base_loopbreak(evbase);
+}
+
+void test_read_evbuffer_leading_zero()
+{
+	ns = "0001:abbbbbbb,";
+	ev_init(read_evb_leading_zero_cb);
+	send(fd[writer], ns, strlen(ns), 0);
+	event_base_dispatch(evbase);
+}
+
+void read_evb_no_length_cb()
+{
+	assert_int_equal(NETSTRING_ERROR_NO_LENGTH, netstring_read_evbuffer(bev, &ns_buffer));
+	int res = event_base_loopbreak(evbase);
+}
+
+void test_read_evbuffer_no_length()
+{
+	ns = "a:......................b,";
+	ev_init(read_evb_no_length_cb);
+	send(fd[writer], ns, strlen(ns), 0);
+	event_base_dispatch(evbase);
+}
+
+void read_evb_too_long_cb()
+{
+	assert_int_equal(NETSTRING_ERROR_TOO_LONG, netstring_read_evbuffer(bev, &ns_buffer));
+	int res = event_base_loopbreak(evbase);
+}
+
+void test_read_evbuffer_too_long()
+{
+	ns = "999999999999999999999:...,";
+	ev_init(read_evb_too_long_cb);
+	send(fd[writer], ns, strlen(ns), 0);
+	event_base_dispatch(evbase);
+}
+
+void read_evb_no_colon_cb()
+{
+	assert_int_equal(NETSTRING_ERROR_NO_COLON, netstring_read_evbuffer(bev, &ns_buffer));
+	int res = event_base_loopbreak(evbase);
+}
+
+void test_read_evbuffer_no_colon()
+{
+	ns = "999abcc,";
+	ev_init(read_evb_no_colon_cb);
+	send(fd[writer], ns, strlen(ns), 0);
+	event_base_dispatch(evbase);
+}
+
+void read_evb_no_comma_cb()
+{
+	assert_int_equal(NETSTRING_ERROR_NO_COMMA, netstring_read_evbuffer(bev, &ns_buffer));
+	int res = event_base_loopbreak(evbase);
+}
+
+void test_read_evbuffer_no_comma()
+{
+	ns = "2:ab.";
+	ev_init(read_evb_no_comma_cb);
+	send(fd[writer], ns, strlen(ns), 0);
+	event_base_dispatch(evbase);
+}
+
+/* ***********************************************************************
+ *                    tests for netstring_read_fd                        *
+ * ***********************************************************************/
+
+//
+// Test normal operation of netstring_read_fd, with data received in three chunks.
+//
+void test_read_fd()
+{
+	char* ns = "13:foobar-bizbaz,";
+	char* temp;
+	int fd[2];
+	const int writer = 0;
+	const int reader = 1;
+	socketpair(PF_LOCAL, SOCK_STREAM, 0, fd);
+    netstring_t* buffer = NULL;
+
+	send(fd[writer], ns, 4, 0);
+	assert_int_equal(NETSTRING_INCOMPLETE, netstring_read_fd(fd[reader], &buffer));
+	temp = ns+4;
+	send(fd[writer], temp, 3, 0);
+	assert_int_equal(NETSTRING_INCOMPLETE, netstring_read_fd(fd[reader], &buffer));
+	temp = temp+3;
+	send(fd[writer], temp, 10, 0);
+	int r = netstring_read_fd(fd[reader], &buffer);
+	assert_int_equal(0, r);
+	if (r == 0)
+		assert_string_equal("foobar-bizbaz", buffer->string);
+}
+
+
+//
+// Abnormal test scenarios for netstring_read_fd
+//
+void test_read_fd_leading_zero()
+{
+	char *ns = "0001:a,";
+	int fd[2];
+	const int writer = 0;
+	const int reader = 1;
+	socketpair(PF_LOCAL, SOCK_STREAM, 0, fd);
+    netstring_t* buffer = NULL;
+
+	send(fd[writer], ns, 7, 0);
+	assert_int_equal(NETSTRING_ERROR_LEADING_ZERO, netstring_read_fd(fd[reader], &buffer));
+}
+
+void test_read_fd_no_length()
+{
+	char *ns = "ab,";
+	int fd[2];
+	const int writer = 0;
+	const int reader = 1;
+	socketpair(PF_LOCAL, SOCK_STREAM, 0, fd);
+    netstring_t* buffer = NULL;
+
+	send(fd[writer], ns, 3, 0);
+	assert_int_equal(NETSTRING_ERROR_NO_LENGTH, netstring_read_fd(fd[reader], &buffer));
+}
+
+void test_read_fd_too_long()
+{
+	char *ns = "999999999999999999999:...,";
+	int fd[2];
+	const int writer = 0;
+	const int reader = 1;
+	socketpair(PF_LOCAL, SOCK_STREAM, 0, fd);
+    netstring_t* buffer = NULL;
+
+	send(fd[writer], ns, strlen(ns), 0);
+	assert_int_equal(NETSTRING_ERROR_TOO_LONG, netstring_read_fd(fd[reader], &buffer));
+}
+
+void test_read_fd_no_colon()
+{
+	char *ns = "999ab,";
+	int fd[2];
+	const int writer = 0;
+	const int reader = 1;
+	socketpair(PF_LOCAL, SOCK_STREAM, 0, fd);
+    netstring_t* buffer = NULL;
+
+	send(fd[writer], ns, strlen(ns), 0);
+	assert_int_equal(NETSTRING_ERROR_NO_COLON, netstring_read_fd(fd[reader], &buffer));
+}
+
+void test_read_fd_no_comma()
+{
+	char *ns = "5:......";
+	int fd[2];
+	const int writer = 0;
+	const int reader = 1;
+	socketpair(PF_LOCAL, SOCK_STREAM, 0, fd);
+    netstring_t* buffer = NULL;
+
+	send(fd[writer], ns, strlen(ns), 0);
+	assert_int_equal(NETSTRING_ERROR_NO_COMMA, netstring_read_fd(fd[reader], &buffer));
+}
+
+///
+// Test for netstring_encode_new
+//
+void test_encode_new()
+{
+	char *ns;
+	char *data = "foobar-bizbaz";
+	int len = netstring_encode_new(&ns, data, strlen(data));
+	assert_int_equal(17, len);
+	char *temp = malloc(len+1);
+	memcpy(temp, ns, len);
+	temp[len] = '\0';
+	assert_string_equal("13:foobar-bizbaz,", temp);
+}
+
+// put the tests into a fixture...
+//
+void test_fixture_read_fd(void)
+{
+	printf("Running read_fd tests...\n");
+	test_fixture_start();
+	run_test(test_read_fd);
+	run_test(test_read_fd_leading_zero);
+	run_test(test_read_fd_no_length);
+	run_test(test_read_fd_too_long);
+	run_test(test_read_fd_no_colon);
+	run_test(test_read_fd_no_comma);
+	test_fixture_end();
+}
+
+void test_fixture_read_evbuffer(void)
+{
+	printf("Running read_evbuffer tests...\n");
+	test_fixture_start();
+	run_test(test_read_evbuffer);
+	run_test(test_read_evbuffer_one_chunk);
+	run_test(test_read_evbuffer_leading_zero);
+	run_test(test_read_evbuffer_no_length);
+	run_test(test_read_evbuffer_too_long);
+//	run_test(test_read_evbuffer_no_colon);
+//	...skip due to TODO in netstring.c
+	run_test(test_read_evbuffer_no_comma);
+	test_fixture_end();
+}
+
+void test_fixture_encode(void)
+{
+	printf("Running encode_new tests...\n");
+	test_fixture_start();
+	run_test(test_encode_new);
+	test_fixture_end();
+}
+
+//
+// put the fixture into a suite...
+//
+void all_tests(void)
+{
+	test_fixture_read_fd();
+	test_fixture_read_evbuffer();
+	test_fixture_encode();
+}
+
+//
+// run the suite!
+//
+int main(int argc, char** argv)
+{
+	return run_tests(all_tests);
+}
+
diff --git a/modules/janssonrpc-c/unit_tests/seatest/license.txt b/modules/janssonrpc-c/unit_tests/seatest/license.txt
new file mode 100644
index 0000000..3fbf632
--- /dev/null
+++ b/modules/janssonrpc-c/unit_tests/seatest/license.txt
@@ -0,0 +1,19 @@
+ Copyright (c) 2010 Keith Nicholas
+
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ THE SOFTWARE.
\ No newline at end of file
diff --git a/modules/janssonrpc-c/unit_tests/seatest/seatest.c b/modules/janssonrpc-c/unit_tests/seatest/seatest.c
new file mode 100644
index 0000000..cb68fb5
--- /dev/null
+++ b/modules/janssonrpc-c/unit_tests/seatest/seatest.c
@@ -0,0 +1,248 @@
+#include "seatest.h"
+#include <string.h>
+#ifdef WIN32
+#include <conio.h>
+#include "windows.h"
+#else
+unsigned int GetTickCount() { return 0;}
+void _getch( void ) { }
+#endif
+
+static int sea_tests_run = 0;
+static int sea_tests_passed = 0;
+static int sea_tests_failed = 0;
+static char* seatest_current_fixture;
+
+static void (*seatest_suite_setup_func)( void ) = 0;
+static void (*seatest_suite_teardown_func)( void ) = 0;
+static void (*seatest_fixture_setup)( void ) = 0;
+static void (*seatest_fixture_teardown)( void ) = 0;
+
+
+
+void suite_setup(void (*setup)( void ))
+{
+	seatest_suite_setup_func = setup;
+}
+void suite_teardown(void (*teardown)( void ))
+{
+	seatest_suite_teardown_func = teardown;
+}
+
+void seatest_suite_setup( void )
+{
+	if(seatest_suite_setup_func != 0) seatest_suite_setup_func();
+}
+
+void seatest_suite_teardown( void )
+{
+	if(seatest_suite_teardown_func != 0) seatest_suite_teardown_func();
+}
+
+void fixture_setup(void (*setup)( void ))
+{
+	seatest_fixture_setup = setup;
+}
+void fixture_teardown(void (*teardown)( void ))
+{
+	seatest_fixture_teardown = teardown;
+}
+
+void seatest_setup( void )
+{
+	if(seatest_fixture_setup != 0) seatest_fixture_setup();
+}
+
+void seatest_teardown( void )
+{
+	if(seatest_fixture_teardown != 0) seatest_fixture_teardown();
+}
+
+char* test_file_name(char* path)
+{
+	char* file = path + strlen(path);
+	while(file != path && *file!= '\\' ) file--;
+	if(*file == '\\') file++;
+	return file;
+}
+
+static int seatest_fixture_tests_run;
+static int seatest_fixture_tests_failed;
+
+void seatest_simple_test_result(int passed, char* reason, const char* function, unsigned int line)
+{
+	if (!passed)
+	{
+		printf("%-20s Line %-5d %s\r\n", function, line, reason );
+		sea_tests_failed++; 
+	}
+	else
+	{
+		sea_tests_passed++; 
+	}	
+}
+
+void seatest_assert_true(int test, const char* function, unsigned int line)
+{
+	seatest_simple_test_result(test, "Should of been true", function, line);
+
+}
+
+void seatest_assert_false(int test, const char* function, unsigned int line)
+{
+	seatest_simple_test_result(!test, "Should of been false", function, line);	
+}
+
+
+void seatest_assert_int_equal(int expected, int actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %d but was %d", expected, actual);
+	seatest_simple_test_result(expected==actual, s, function, line);	
+}
+
+void seatest_assert_ulong_equal(unsigned long expected, unsigned long actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %lu but was %lu", expected, actual);
+	seatest_simple_test_result(expected==actual, s, function, line);	
+}
+
+void seatest_assert_float_equal( float expected, float actual, float delta, const char* function, unsigned int line )
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	float result = expected-actual;
+	sprintf(s, "Expected %f but was %f", expected, actual);
+	if(result < 0.0) result = 0.0f - result;
+	seatest_simple_test_result( result <= delta, s, function, line);	
+}
+
+void seatest_assert_double_equal( double expected, double actual, double delta, const char* function, unsigned int line )
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	double result = expected-actual;
+	sprintf(s, "Expected %f but was %f", expected, actual);
+	if(result < 0.0) result = 0.0 - result;
+	seatest_simple_test_result( result <= delta, s, function, line);	
+}
+
+void seatest_assert_string_equal(char* expected, char* actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %s but was %s", expected, actual);
+	seatest_simple_test_result(strcmp(expected, actual)==0, s, function, line);	
+}
+
+void seatest_assert_string_ends_with(char* expected, char* actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %s to end with %s", actual, expected);
+	seatest_simple_test_result(strcmp(expected, actual+(strlen(actual)-strlen(expected)))==0, s, function, line);	
+}
+
+void seatest_assert_string_starts_with(char* expected, char* actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %s to start with %s", actual, expected);
+	seatest_simple_test_result(strncmp(expected, actual, strlen(expected))==0, s, function, line);	
+}
+
+void seatest_assert_string_contains(char* expected, char* actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %s to be in %s", expected, actual);
+	seatest_simple_test_result(strstr(actual, expected)!=0, s, function, line);	
+}
+
+void seatest_assert_string_doesnt_contain(char* expected, char* actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %s not to have %s in it", actual, expected);
+	seatest_simple_test_result(strstr(actual, expected)==0, s, function, line);	
+}
+
+void seatest_run_test(void)
+{
+	sea_tests_run++; 
+}
+
+void seatest_header_printer(char* s, int length, char f)
+{
+	int l = strlen(s);
+	int d = (length- (l + 2)) / 2;
+	int i;
+	for(i = 0; i<d; i++) printf("%c",f);
+	printf(" %s ", s);
+	for(i = (d+l+2); i<length; i++) printf("%c",f);
+	printf("\r\n");
+}
+
+
+void seatest_test_fixture_start(char* filepath)
+{
+	seatest_current_fixture = test_file_name(filepath);
+	seatest_header_printer(seatest_current_fixture, 50, '-');
+	seatest_fixture_tests_failed = sea_tests_failed;
+	seatest_fixture_tests_run = sea_tests_run;
+	seatest_fixture_teardown = 0;
+	seatest_fixture_setup = 0;
+}
+
+void seatest_test_fixture_end()
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "%d run  %d failed", sea_tests_run-seatest_fixture_tests_run, sea_tests_failed-seatest_fixture_tests_failed);
+	seatest_header_printer(s, 50, ' ');
+	printf("\r\n");
+}
+
+static char* seatest_fixture_filter = 0;
+static char* seatest_test_filter = 0;
+
+void fixture_filter(char* filter)
+{
+	seatest_fixture_filter = filter;
+}
+
+
+void test_filter(char* filter)
+{
+	seatest_test_filter = filter;
+}
+
+
+int seatest_should_run( char* fixture, char* test)
+{
+	int run = 1;
+	if(seatest_fixture_filter) 
+	{
+		if(strncmp(seatest_fixture_filter, fixture, strlen(seatest_fixture_filter)) != 0) run = 0;
+	}
+	if(seatest_test_filter) 
+	{
+		if(strncmp(seatest_test_filter, test, strlen(seatest_test_filter)) != 0) run = 0;
+	}
+	return run;
+}
+
+int run_tests(void (*tests)(void))
+{
+	unsigned long end;
+	unsigned long start = GetTickCount();
+	tests();	 
+	end = GetTickCount();
+	printf("\r\n\r\n==================SEATEST v%s====================\r\n\r\n", SEATEST_VERSION);	 
+	if (sea_tests_failed > 0) {
+		printf("                      Failed\r\n");			
+	}
+	else {
+		printf("               ALL TESTS PASSED\r\n");
+	}
+	printf("                 %d tests run\r\n", sea_tests_run);
+	printf("                    in %lu ms\r\n",end - start);
+	printf("==================================================\r\n");
+
+	_getch();
+	return sea_tests_failed == 0;
+}
+
diff --git a/modules/janssonrpc-c/unit_tests/seatest/seatest.h b/modules/janssonrpc-c/unit_tests/seatest/seatest.h
new file mode 100644
index 0000000..964eaf9
--- /dev/null
+++ b/modules/janssonrpc-c/unit_tests/seatest/seatest.h
@@ -0,0 +1,74 @@
+#ifndef SEATEST_H
+#define SEATEST_H
+#include <stdio.h>
+
+/*
+Defines
+*/
+
+#define SEATEST_VERSION "0.5"
+#define SEATEST_PROJECT_HOME "http://code.google.com/p/seatest/"
+#define SEATEST_PRINT_BUFFER_SIZE 100000
+
+/*
+Declarations
+*/
+
+void seatest_test_fixture_start(char* filepath);
+void seatest_test_fixture_end( void );
+void seatest_simple_test_result(int passed, char* reason, const char* function, unsigned int line);
+void seatest_assert_true(int test, const char* function, unsigned int line);
+void seatest_assert_false(int test, const char* function, unsigned int line);
+void seatest_assert_int_equal(int expected, int actual, const char* function, unsigned int line);
+void seatest_assert_ulong_equal(unsigned long expected, unsigned long actual, const char* function, unsigned int line);
+void seatest_assert_float_equal(float expected, float actual, float delta, const char* function, unsigned int line);
+void seatest_assert_double_equal(double expected, double actual, double delta, const char* function, unsigned int line);
+void seatest_assert_string_equal(char* expected, char* actual, const char* function, unsigned int line);
+void seatest_assert_string_ends_with(char* expected, char* actual, const char* function, unsigned int line);
+void seatest_assert_string_starts_with(char* expected, char* actual, const char* function, unsigned int line);
+void seatest_assert_string_contains(char* expected, char* actual, const char* function, unsigned int line);
+void seatest_assert_string_doesnt_contain(char* expected, char* actual, const char* function, unsigned int line);
+int seatest_should_run( char* fixture, char* test);
+void seatest_run_test(void);
+void seatest_setup( void );
+void seatest_teardown( void );
+void seatest_suite_teardown( void );
+void seatest_suite_setup( void );
+
+/*
+Assert Macros
+*/
+
+#define assert_true(test) do { seatest_assert_true(test, __FUNCTION__, __LINE__); } while (0)
+#define assert_false(test) do {  seatest_assert_false(test, __FUNCTION__, __LINE__); } while (0)
+#define assert_int_equal(expected, actual) do {  seatest_assert_int_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_ulong_equal(expected, actual) do {  seatest_assert_ulong_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_string_equal(expected, actual) do {  seatest_assert_string_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_n_array_equal(expected, actual, n) do { int seatest_count; for(seatest_count=0; seatest_count<n; seatest_count++) { char s_seatest[SEATEST_PRINT_BUFFER_SIZE]; sprintf(s_seatest,"Expected %d to be %d at position %d", actual[seatest_count], expected[seatest_count], seatest_count); seatest_simple_test_result((expected[seatest_count] == actual[seatest_count]), s_seatest, __FUNCTION__, __LINE__);} } while (0)
+#define assert_bit_set(bit_number, value) { seatest_simple_test_result(((1 << bit_number) & value), " Expected bit to be set" ,  __FUNCTION__, __LINE__); } while (0)
+#define assert_bit_not_set(bit_number, value) { seatest_simple_test_result(!((1 << bit_number) & value), " Expected bit not to to be set" ,  __FUNCTION__, __LINE__); } while (0)
+#define assert_bit_mask_matches(value, mask) { seatest_simple_test_result(((value & mask) == mask), " Expected all bits of mask to be set" ,  __FUNCTION__, __LINE__); } while (0)
+#define assert_fail(message) { seatest_simple_test_result(0, message,  __FUNCTION__, __LINE__); } while (0)
+#define assert_float_equal(expected, actual, delta) do {  seatest_assert_float_equal(expected, actual, delta, __FUNCTION__, __LINE__); } while (0)
+#define assert_double_equal(expected, actual, delta) do {  seatest_assert_double_equal(expected, actual, delta, __FUNCTION__, __LINE__); } while (0)
+#define assert_string_contains(expected, actual) do {  seatest_assert_string_contains(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_string_doesnt_contain(expected, actual) do {  seatest_assert_string_doesnt_contain(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_string_starts_with(expected, actual) do {  seatest_assert_string_starts_with(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_string_ends_with(expected, actual) do {  seatest_assert_string_ends_with(expected, actual, __FUNCTION__, __LINE__); } while (0)
+
+/*
+Fixture / Test Management
+*/
+
+void fixture_setup(void (*setup)( void ));
+void fixture_teardown(void (*teardown)( void ));
+#define run_test(test) do { if(seatest_should_run(__FILE__, #test)) {seatest_suite_setup(); seatest_setup(); test(); seatest_teardown(); seatest_suite_teardown(); seatest_run_test();  }} while (0)
+#define test_fixture_start() do { seatest_test_fixture_start(__FILE__); } while (0)
+#define test_fixture_end() do { seatest_test_fixture_end();} while (0)
+void fixture_filter(char* filter);
+void test_filter(char* filter);
+
+int run_tests(void (*tests)(void));
+void suite_teardown(void (*teardown)( void ));
+void suite_setup(void (*setup)( void ));
+#endif 
diff --git a/modules/janssonrpc-c/unit_tests/test.h b/modules/janssonrpc-c/unit_tests/test.h
new file mode 100644
index 0000000..edb0740
--- /dev/null
+++ b/modules/janssonrpc-c/unit_tests/test.h
@@ -0,0 +1,48 @@
+/**
+ * $Id$
+ *
+ * Copyright (C) 2013 Flowroute LLC (flowroute.com)
+ *
+ * This file is part of Kamailio, a free SIP server.
+ *
+ * This file is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ *
+ * This file is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _TEST_H_
+#define _TEST_H_
+
+#include <stdlib.h>
+#include <math.h>
+#include "seatest/seatest.h"
+
+struct _str{
+	char* s;
+	int len;
+};
+
+typedef struct _str str;
+
+#define pkg_malloc malloc
+#define shm_malloc malloc
+
+#define pkg_free free
+#define shm_free free
+
+#define ERR printf
+#define ALERT printf
+
+#endif /* _TEST_H_ */
