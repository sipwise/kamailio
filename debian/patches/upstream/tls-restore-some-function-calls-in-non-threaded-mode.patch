From: S-P Chan <shihping.chan@gmail.com>
Date: Tue, 13 Feb 2024 07:15:05 +0800
Subject: tls: restore some function calls in non-threaded mode

In the case that tls_threads_mode = 0 we restore the earlier
behaviour of 5.7.3.
- OpenSSL 1.1.1: restore early call to RAND_set_rand_method
- OpenSSL 3.x: restore enable locking on EVP_RAND_CTX
---
 src/modules/tls/tls_init.c | 92 +++++++++++++++++++++++-----------------------
 src/modules/tls/tls_mod.c  | 19 +++++++---
 2 files changed, 59 insertions(+), 52 deletions(-)

diff --git a/src/modules/tls/tls_init.c b/src/modules/tls/tls_init.c
index 1c6b19f..b7901af 100644
--- a/src/modules/tls/tls_init.c
+++ b/src/modules/tls/tls_init.c
@@ -737,43 +737,43 @@ int tls_pre_init(void)
  * left here in case more complex requirements arise in
  * OpenSSL >= 3.2.
  */
-long tls_h_mod_randctx(void *param)
+int tls_h_mod_randctx()
 {
-    do {
-        OSSL_LIB_CTX *osslglobal = NULL;
-        EVP_RAND_CTX *randctx = NULL;
-
-        LM_DBG("enabling locking for rand ctx\n");
-
-        osslglobal = OSSL_LIB_CTX_get0_global_default();
-        if(osslglobal == NULL) {
-            LM_ERR("failed to get lib ssl global ctx\n");
-            return -1L;
-        }
-
-        randctx = RAND_get0_primary(osslglobal);
-        if(randctx == NULL) {
-            LM_ERR("primary rand ctx is null\n");
-            return -1L;
-        }
-        EVP_RAND_enable_locking(randctx);
-
-        randctx = RAND_get0_public(osslglobal);
-        if(randctx == NULL) {
-            LM_ERR("public rand ctx is null\n");
-            return -1L;
-        }
-        EVP_RAND_enable_locking(randctx);
-
-        randctx = RAND_get0_private(osslglobal);
-        if(randctx == NULL) {
-            LM_ERR("private rand ctx is null\n");
-            return -1L;
-        }
-        EVP_RAND_enable_locking(randctx);
-    } while(0);
-
-    return 0L;
+	do {
+		OSSL_LIB_CTX *osslglobal = NULL;
+		EVP_RAND_CTX *randctx = NULL;
+
+		LM_DBG("enabling locking for rand ctx\n");
+
+		osslglobal = OSSL_LIB_CTX_get0_global_default();
+		if(osslglobal == NULL) {
+			LM_ERR("failed to get lib ssl global ctx\n");
+			return -1;
+		}
+
+		randctx = RAND_get0_primary(osslglobal);
+		if(randctx == NULL) {
+			LM_ERR("primary rand ctx is null\n");
+			return -1;
+		}
+		EVP_RAND_enable_locking(randctx);
+
+		randctx = RAND_get0_public(osslglobal);
+		if(randctx == NULL) {
+			LM_ERR("public rand ctx is null\n");
+			return -1;
+		}
+		EVP_RAND_enable_locking(randctx);
+
+		randctx = RAND_get0_private(osslglobal);
+		if(randctx == NULL) {
+			LM_ERR("private rand ctx is null\n");
+			return -1;
+		}
+		EVP_RAND_enable_locking(randctx);
+	} while(0);
+
+	return 0;
 }
 #endif /* OPENSSL_VERSION_NUMBER */
 
@@ -801,21 +801,19 @@ int tls_h_mod_pre_init_f(void)
 	SSL_load_error_strings();
 #endif
 
-#if 0
 #if OPENSSL_VERSION_NUMBER >= 0x030000000L
-        /*
+	/*
          * With deferred initialisation it is not necessary to enable threading
-         * on the EVP_RAND_CTX. We leave this block here as an example of how
-         * to do it in case of future requirements.
+         * on the EVP_RAND_CTX in tls_threads_mode = 1
          */
-        pthread_t tid;
-        long rl;
-        pthread_create(&tid, NULL, (void *(*)(void *))tls_h_mod_randctx, NULL);
-        pthread_join(tid, (void **)&rl);
-        if ((int)rl)
-            return (int)rl;
+	int ret;
+
+	if(ksr_tls_threads_mode == 0) {
+		ret = tls_h_mod_randctx();
+		if(ret)
+			return ret;
+	}
 #endif /* OPENSSL_VERSION_NUMBER */
-#endif /* 0 */
 
 	tls_mod_preinitialized = 1;
 	return 0;
diff --git a/src/modules/tls/tls_mod.c b/src/modules/tls/tls_mod.c
index 3359aaf..5d3982b 100644
--- a/src/modules/tls/tls_mod.c
+++ b/src/modules/tls/tls_mod.c
@@ -449,13 +449,14 @@ static int mod_child(int rank)
 		return 0;
 
 #if OPENSSL_VERSION_NUMBER >= 0x010101000L
-        /*
+	/*
          * OpenSSL 3.x/1.1.1: create shared SSL_CTX* in worker to avoid init of
          * libssl in rank 0(thread#1). Requires tls_threads_mode = 1 config.
          */
-        if((rank == PROC_SIPINIT && ksr_tls_threads_mode) || (rank == PROC_INIT && !ksr_tls_threads_mode)) {
+	if((rank == PROC_SIPINIT && ksr_tls_threads_mode)
+			|| (rank == PROC_INIT && !ksr_tls_threads_mode)) {
 #else
-        if(rank == PROC_INIT) {
+	if(rank == PROC_INIT) {
 #endif
 		if(cfg_get(tls, tls_cfg, config_file).s) {
 			if(tls_fix_domains_cfg(
@@ -678,10 +679,18 @@ int mod_register(char *path, int *dlflags, void *p1, void *p2)
 
 	register_tls_hooks(&tls_h);
 
-        /*
+	/*
          * GH #3695: OpenSSL 1.1.1 historical note: it is no longer
-         * needed to replace RAND with cryptorand
+         * needed to replace RAND with cryptorand in tls_threads_mode = 1
          */
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L \
+		&& OPENSSL_VERSION_NUMBER < 0x030000000L
+	if(ksr_tls_threads_mode == 0) {
+		LM_DBG("setting cryptorand random engine\n");
+		RAND_set_rand_method(RAND_ksr_cryptorand_method());
+	}
+#endif
+
 	sr_kemi_modules_add(sr_kemi_tls_exports);
 
 	return 0;
