--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,664 @@
+===================== 2019-08-14 Version 5.2.4 Released =====================
+
+===================== Changes Since Version 5.2.3 ===========================
+
+commit 0c23deeaad6b54236966807172388f4073e54dde
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Wed Aug 14 11:17:03 2019 +0200
+
+    Makefile.defs: version set to 5.2.4
+
+commit 7218d1fdad903fabaff224cf2be8212013e35221
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Wed Aug 14 11:13:54 2019 +0200
+
+    pkg/kamailio: updated version to 5.2.4 in spec files
+
+commit f4f08a901bd798acd237851c7299c6d07083974e
+Author: Victor Seva <linuxmaniac@torreviejawireless.org>
+Date:   Wed Aug 14 08:32:33 2019 +0200
+
+    pkg/kamailio/deb: version set to 5.2.4 [skip ci]
+
+commit db0ae1e3dde3331810ba8b154d7e111bf3322583
+Author: Kamailio Dev <kamailio.dev@kamailio.org>
+Date:   Mon Aug 12 21:01:32 2019 +0200
+
+    modules: readme files regenerated - modules ... [skip ci]
+
+commit 6e5cb772817a8275c89869c868ce20a2ddb47df9
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Mon Aug 12 20:52:50 2019 +0200
+
+    topos: docs for dialog_expire param limitation for in-dialog requests (GH #2024)
+    
+    (cherry picked from commit 3ccf5ee691440e806d441f0e58562ddc4137a488)
+
+commit c1eaf3353f43d34f164f28a871399ca785c40b4f
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Aug 12 20:15:17 2019 +0200
+
+    dispatcher: skip inactive destinations for pointing next to be used record
+    
+    (cherry picked from commit 18eeda012a711584239b03d5cfef8b7720f0ef31)
+
+commit 7069cbaf28beb35036eeb2ab9bde19844144eb00
+Author: Kamailio Dev <kamailio.dev@kamailio.org>
+Date:   Mon Aug 12 10:32:22 2019 +0200
+
+    modules: readme files regenerated - modules ... [skip ci]
+
+commit 1d436e38cbadd47a36a5293b88713566e2454eb0
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Tue Aug 6 21:37:56 2019 +0200
+
+    misc_radius: increase MAX_EXTRA from 4 to 8
+    
+    - GH #2025
+    
+    (cherry picked from commit 4c537a618949eb48ffed9297f3abc8cdc879b70d)
+
+commit 5d7784a5e35e3060549e5e12a05d1dfc34fbff19
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Tue Aug 6 21:37:04 2019 +0200
+
+    auth_radius: increase MAX_EXTRA from 4 to 8
+    
+    - GH #2025
+    
+    (cherry picked from commit df93a638040f4c1aa4d6ed3799d6f990b0593f94)
+
+commit 91ffb3e9d2ff60d0e31a33cc00c966afbadadcd2
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Tue Aug 6 17:33:15 2019 +0200
+
+    app_python3: Makefile - get all ldflags for linking
+    
+    (cherry picked from commit d762848d4f71014a6c6b6693b44403324a8edd15)
+
+commit 7368859780f258945f2077a9ea0e1c7e603a75eb
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Aug 5 18:29:42 2019 +0200
+
+    app_ruby: docs - fix rpc command name for listing the api
+    
+    (cherry picked from commit 5773fba2765c8a08be7016e82a6ec02579b49215)
+
+commit 2eafd02697f5f6c6885389e5ef25785d153b3026
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Aug 5 18:11:00 2019 +0200
+
+    app_ruby: print pointers in error log message
+    
+    (cherry picked from commit ea526a8de9c961a57858ecc4c47ce4ba24e03908)
+
+commit 887c49e597572a58f6400736f8dcd753fa4543cd
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Aug 5 18:03:47 2019 +0200
+
+    uac: debug messages when restoring from/to headers
+    
+    (cherry picked from commit 7a4c490a63cd3fa924b6921fcd20ba77a6d661fb)
+
+commit 21fa3d2c130d85a925d2db658dfbd291d21a6baa
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Fri Aug 2 13:43:36 2019 +0200
+
+    tm: removed unused error label in prepare_new_uac()
+    
+    (cherry picked from commit c7ceb08b31fdb3f6560d02fff6b6ee71602c19ec)
+
+commit 5c042d6e1023828f49d7ac75f2b761ad3433ab31
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Thu Aug 1 13:54:21 2019 +0200
+
+    tm: proper resoring of backup lumps in case of cloning failure
+    
+    (cherry picked from commit cd379886fa7a8ff01b9618491199f8e5b3ce897f)
+
+commit 164702ddbc2e88c818f9293d0c31fef163ea45b7
+Author: Guillem Jover <gjover@sipwise.com>
+Date:   Mon Jul 29 20:15:47 2019 +0200
+
+    build: Call make via $(MAKE)
+    
+    When we need to call make from within a Makefile, we should do so by
+    using the MAKE variable, which has special meaning for make itself.
+    This makes sure, it will get marked as recursive command, and will
+    make it possible to use the make jobserver.
+    
+    Change-Id: I6829f3ee0a830fc8273e1dffe696382fccc6a093
+    (cherry picked from commit 2306dd47b308f99e5c22c2d6f4d2bc1200ed8453)
+
+commit f88580226306bdc02120e8a0d0042c640192fd53
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Wed Jul 31 11:04:21 2019 +0200
+
+    db_redis: note about defining key when updating table content
+    
+    (cherry picked from commit f2df5df815f8dfca87324ca70e6fe9a51fc417e9)
+
+commit 1c406f1e8ff2c02f1d739082c39835d7bee077ba
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Tue Jul 30 16:58:45 2019 +0200
+
+    usrloc: use static record for expires callback in db-only mode
+    
+    (cherry picked from commit 12dbf48d421680764f9e9621de9485616ca0c055)
+
+commit 112529b9e9396c12ec5471ca651f580a02d1b172
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Jul 29 12:25:17 2019 +0200
+
+    kamctl: option to enable kamctl test from shell variable
+    
+    - set KAMCTL_TEST variable in shell
+    
+    (cherry picked from commit 4968e8994157f1152bf7461b16049d67e5c9cc59)
+
+commit 5bbf4aeca8063da6f7f911260a95c7475f6184a0
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Jul 29 10:54:41 2019 +0200
+
+    usrloc: delete contact attributes in db-only mode
+    
+    (cherry picked from commit b642263a08313e86cc4936a9c489e8afb4a2cb5f)
+
+commit efaeb98c3a251e468573d6ebdb3d92c6065c7bdc
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Jul 29 10:40:56 2019 +0200
+
+    usrloc: coherent indentation and whitespacing
+    
+    (cherry picked from commit 12bf3cb574e2ead2da46e7e237a33415ae12df61)
+
+commit e2a0873df1e18640e1bfe7bc0adee725202afa2b
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Fri Jul 19 10:03:53 2019 +0200
+
+    evapi: adjust log message when no client connected for dispatching
+    
+    (cherry picked from commit a6a2416e59c1e1a5cbadd3ecceecff52201be10d)
+
+commit 1bba5826292f0dbd6703f8df941f886a2a71c9e9
+Author: Surendra Tiwari <surendratiwari3@gmail.com>
+Date:   Fri Jul 19 13:07:32 2019 +0530
+
+    evapi:return code and log fixed for no evapi client while sending
+    
+    (cherry picked from commit 08cf17288861bcaa8f3b23166059ead517d1b4fe)
+
+commit 77abc5d6923930649bb2fc76dd3b4f5d702684d9
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Fri Jul 19 09:50:21 2019 +0200
+
+    core: pv - increased the size for vars and transformations tables
+    
+    (cherry picked from commit e6b183a1ec3b267cc25040a9b67a1c151ee85555)
+
+commit ae766571c230ef9b1e8edd0faade674061488897
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Thu Jul 18 08:46:27 2019 +0200
+
+    corex: debug message for set rcv/snd sock functions
+    
+    (cherry picked from commit 5e961873401fd0a93ff03ba8d75dbcefbf2fbcf0)
+
+commit 2a864f3580fb97c9e920f8fa7cd9361ad3b88aae
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Thu Jul 18 08:41:29 2019 +0200
+
+    core: debug message for forcing send socket action
+    
+    (cherry picked from commit abe060b417c5270082aa46660fdc2f78098a5888)
+
+commit 681dd5d519c24e8e0574eafccb62e9c0b6cf8732
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Thu Jul 18 08:34:31 2019 +0200
+
+    pv: debug message when seting $fs (send socket)
+    
+    (cherry picked from commit ac95f0c29390e1dbc0779b56936ee68a424595e0)
+
+commit 2fc5178d6557e2c1e8351330456cdcd8a55bebee
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Jul 15 17:24:14 2019 +0200
+
+    siputils: log method ids on mismatch for options_reply()
+    
+    (cherry picked from commit 9dab8303a96614fd74efff6add359a23713642a5)
+
+commit 787ebf8cef9972292a38c5d3335703a0407c547a
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Jul 15 16:41:22 2019 +0200
+
+    siputils: exported options_reply() to kemi framework
+    
+    (cherry picked from commit 183ff04e00e592cc2c7db54732c6a3bb8fb75bb8)
+
+commit a77c4a9268e416abdae5ec74374451d4172cc8e7
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Tue Jul 9 09:35:08 2019 +0200
+
+    kamctl: relaxed regex check on aor and sip uri
+    
+    - it required a dot (.), not valid for ipv6 and single word domains
+    (e.g., localhost)
+    - now just match on USERNAME_RE@.+
+    
+    (cherry picked from commit 94e9d47d2d2da82be23f1bae8cd6491c758a384c)
+
+commit 59d29bc35138939a14beed501e7d8ae47b35b6e8
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Sat Jul 6 09:00:06 2019 +0200
+
+    usrloc: coherence for int type of parameters
+    
+    - it was combination of int and integer, now all int
+    - fix examples for int params, related to GH #1999
+    
+    (cherry picked from commit 91fa799e436de252e9f5aa5d8f09609f46db6e58)
+
+commit 21af99321bbcc14ffeced749eafe003caff26b36
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Jul 1 17:30:07 2019 +0200
+
+    uac: docs - examples with rpc commands having params numbers converted to string
+    
+    - GH #1988
+    
+    (cherry picked from commit ec42a0b36a10dec0852bd1ef2bf3ad7ab9ad8dbc)
+
+commit 942b0ab096a7981ddad19a74974eef3d23d44cd6
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Fri Jun 28 16:01:43 2019 +0200
+
+    pv: relax uri and params transfromation parsing when separator is last char
+    
+    - more flexible in parsing custom values, detection done in
+    transformations code
+    
+    (cherry picked from commit 1c4af823c39d28b694c1dec607d8d72c5b726456)
+
+commit 1f7519fa002e7cfff0edd2180aeab2b5306881e2
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Fri Jun 28 14:53:02 2019 +0200
+
+    htable: docs - rephrased info for db_expires to clarify its purpose
+    
+    (cherry picked from commit f87adf6aba3fcebfe162341bc45d130365d34f5e)
+
+commit 4d3bc9dbd2d4da88e6f04f0cdaa52944430fd364
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Fri Jun 28 08:07:02 2019 +0200
+
+    uac: debug messages when initializing the remote uac registration
+    
+    (cherry picked from commit 0fcb2607d2d63a0e10fce189b6881ac15b985bb4)
+
+commit 4761c2708a6b315d4cc0b1d8c88fd9d90e1400ee
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Thu Jun 27 16:25:27 2019 +0200
+
+    sdpops: exported to kemi the functions to detect sdp with codecs
+    
+    - sdp_with_codecs_by_id() and sdp_with_codecs_by_name()
+    
+    (cherry picked from commit 3716541db01c09bd00998bdbd0c35b3a842cdaf5)
+
+commit a5f51d169ab3cd890d005eac1ea5d91102acbda7
+Author: Vicente Hernando <vhernando@systemonenoc.com>
+Date:   Tue Jun 25 15:37:43 2019 +0200
+
+    call_obj: b/f acept optional limit parameter.
+    
+    (cherry picked from commit 8266f0ee05b1f2faf2d4148efca257f7322da4ce)
+
+commit 203b027357259564aaef1db2f004bfaaa30c9fd7
+Author: Vicente Hernando <vhernando@systemonenoc.com>
+Date:   Mon Jun 24 15:06:25 2019 +0200
+
+    call_obj_mod: no need to use a free function for call_obj_get.
+    
+    (cherry picked from commit a58b4c2afbffdd2584f553f8d7d36a84d40e2aee)
+
+commit 8848bce61107c98a4b8e6fd2afe3670ec90baf70
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Thu Jun 27 09:36:21 2019 +0200
+
+    lib/srdb1: support for username@domain in user id part of db url
+    
+    - used by some cloud database services
+    - reworked patch from GH #1992
+    
+    (cherry picked from commit d419f427d2acf890e5e45c4f3e8e7a2b2fe4cead)
+
+commit bf5e1698e543bce6cbf424773322a06ae09d2c19
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Tue Jun 25 23:03:17 2019 +0200
+
+    sanity: free parsed proxy-required header in case of failure
+    
+    - reported by GH #1990
+    
+    (cherry picked from commit ffa2aa438e2a13e6e8bdbe70dd90827ae18279ce)
+
+commit 2b58dee39ea92e2fd2038b70cb0c0436c109d6a2
+Author: Julien Arlt <julien-arlt@gmx.de>
+Date:   Fri Jun 21 14:52:11 2019 +0200
+
+    userblacklist: fix double "check_user_blacklist" in module documentation
+    
+    (cherry picked from commit b7f7efe4f952894aa847165cc038cd5af4c3141a)
+
+commit 9d4f48b20216b688006fb68e9878a2ce339d19a4
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Sat Jun 22 10:58:18 2019 +0200
+
+    rls: Makefile - link agaist libicu on macos/darwin
+    
+    - libxml2 needs it but its pkg-config doesn't list it
+    
+    (cherry picked from commit 46084c898d0598e94c7f22ab03d321e037fd7f55)
+
+commit df7a3c2b1c9dec3655f175728a5771262fd6a747
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Fri Jun 21 11:08:12 2019 +0200
+
+    presence: docs - aligned examples to avoid large whitespacing
+    
+    (cherry picked from commit 8a909021ccccc321b06b3437d124978bd901ab18)
+
+commit 0bcfc63dd365e50e8a6394e005972e2bf5d0e86a
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Thu Jun 20 20:35:04 2019 +0200
+
+    presence: docs - fixed name for event route presence:notify-reply
+    
+    (cherry picked from commit f005e2edca8fef350546cb743bf1cb51ee4ddd8d)
+
+commit 59402a71c5c7d8fc4ffd3dbb5643fb6605982e51
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Thu Jun 20 11:01:09 2019 +0200
+
+    rls: docs - added section ids
+    
+    (cherry picked from commit 50dfec2f2b7a467afe7c935524d0d385e9018f02)
+
+commit 29114b86e4360f2de53310070db872cd09aaef6e
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Tue Jun 18 16:25:25 2019 +0200
+
+    pdb: safety check for header length in pdb_msg_dbg()
+    
+    (cherry picked from commit 3c07e2351a94e4ff2cf3c6b9b9df4d7462cd5760)
+
+commit db0cabd8673e5ad7468eebae1781dd176bac1788
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Fri Jun 7 09:55:04 2019 +0200
+
+    exec: debug message with number of results for exec_avp()
+    
+    (cherry picked from commit 01c50c84aed717f9de689ab4eec3faec59a498e4)
+
+commit 1789377bdb6180b8979a84502ba439366f7f8d45
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Fri Jun 7 08:48:34 2019 +0200
+
+    tm: detect local uac transaction not inserted in the hash table
+    
+    (cherry picked from commit cf0008d843009acc8e40fcad3eceda063b1a358c)
+
+commit 2f07bb77623c556b440d040203ade01726a59fde
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Tue May 28 08:44:32 2019 +0200
+
+    usrloc: clone xavp list in contact struct in memory mode
+    
+    (cherry picked from commit 76f0fa8a0330de3885f5f3830eb90061c59045d4)
+
+commit 009f62895e835606c1a6c378aeded6c7068f3902
+Author: Kamailio Dev <kamailio.dev@kamailio.org>
+Date:   Sun Aug 11 11:02:02 2019 +0200
+
+    modules: readme files regenerated - modules ... [skip ci]
+
+commit 822820827c55adb02efae9703cfda9b936686f3f
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Sun Aug 11 10:56:56 2019 +0200
+
+    acc: remove diameter specific doc content, code was moved in 2017 to acc_diameter
+    
+    (cherry picked from commit d8cede175ddeada5ca5654a74e765f154dcfa86d)
+
+commit 71e384ab77faf7d09c7cb27996a16f588e9dd22e
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Sun Aug 11 10:51:37 2019 +0200
+
+    acc: doc improvement regarding radius and diameter modules
+    
+    (cherry picked from commit 59a58e8a01e91def4634b551cb69ebe1f1c953e0)
+
+commit 82bbbd443977ee45c87958265ef064c94689c17c
+Author: Kamailio Dev <kamailio.dev@kamailio.org>
+Date:   Fri Aug 9 16:46:36 2019 +0200
+
+    modules: readme files regenerated - modules ... [skip ci]
+
+commit 06d6009624ec5f537838e23afc491043e6edae75
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Fri Aug 9 16:35:30 2019 +0200
+
+    uac: fix another copy and paste error in docs
+    
+    (cherry picked from commit 85994cda0a9413836386d595aab1657d1412ec8b)
+
+commit 1681a5b22270e1dfcbad8edea2881c24d49e847d
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Fri Aug 9 16:25:02 2019 +0200
+
+    uac: fix references in docs for AVPs
+    
+    (cherry picked from commit a5360fa28d8394bf420915645ecd0658dcd1c7b8)
+
+commit 643faf56274d6432b9884a062a669d0920d04bd4
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Sun Aug 4 21:12:48 2019 +0200
+
+    domain: fix memory leak on domain reload (related to domain_attr table, struct domain_list)
+    
+    - fix memory leak on domain reload, reported by Mack Hendricks
+    - related to domain_attr table, structure domain_list
+    
+    (cherry picked from commit f50177003c21f53564be6349c0bb4935be184e2d)
+
+commit 24e327280b1790ed15e16f6fd251c5596728abd8
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Thu Aug 8 18:29:40 2019 +0200
+
+    sipt: reset the static buffer for returning the number
+    
+    - GH #2030
+    
+    (cherry picked from commit 2c052974263c0785eb5280a935162673ac82dc6b)
+
+commit b88e04ee3d873a1d9c09b504e62174c0e1aaa02b
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Tue Aug 6 09:44:38 2019 +0200
+
+    corex: fix parser for alias_subdomain modparam, extend debugging output
+    
+    - fix parser for alias_subdomain modparam, it was not working correctly for
+      all proto:hostname:port combinations (e.g. hostname/proto mixed up)
+    - extend debugging output for alias adding and also alias matching
+    
+    (cherry picked from commit 36ef1bf77f9df7bc5022c1dc350e54df2d168cf3)
+
+commit 9db6d9cc7751684981c2b602b3bd6021edc3a7fb
+Author: Victor Seva <linuxmaniac@torreviejawireless.org>
+Date:   Thu Dec 27 22:36:20 2018 +0100
+
+    db_mysql: remove build warning, unneeded include (#1777)
+    
+    db_mysql: mysql_version.h is already included at mysql.h (GH #1777)
+    
+    > In file included from km_dbase.c:38:
+    > /usr/include/mariadb/mysql_version.h:3:2: warning: This file should not be included by clients, include only <mysql.h> [-W#warnings]
+    > #warning This file should not be included by clients, include only <mysql.h>
+    
+    (cherry picked from commit 57263490bd1dedbb4b7fdad6046880980feea040)
+
+commit 82635674517b6c96678289ca4e807ae73020eefc
+Author: Daniel-Constantin Mierla <miconda@gmail.com>
+Date:   Mon Jul 29 13:51:57 2019 +0200
+
+    core: skip to-tag when computing via branch for invite, ack and cancel
+    
+    - proper functionality for stateless proxy in case of negative ACK (in
+    this case the INVITE has no To-tag, but ACK has it and resulted in
+    different via branch, making downstream proxy to not match transaction)
+    
+    (cherry picked from commit b4e11cb25d848651406e0ad355d54f10db971761)
+
+commit c93c7eb77692f213e68be7992f031e4cfd377605
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Tue Jul 30 16:37:20 2019 +0200
+
+    utils/kamcmd: default port is 2049, adapt help and README
+    
+    (cherry picked from commit 74375eae8f447952d17a1d89e5a62f029a15a81c)
+
+commit dd21d3eab5024e351c06ea3ae7b0e427dbd38701
+Author: Kamailio Dev <kamailio.dev@kamailio.org>
+Date:   Sun Jul 28 22:01:44 2019 +0200
+
+    modules: readme files regenerated - modules ... [skip ci]
+
+commit 228154df82bbc2ebfa4edaf5e1bb91453bfb53e5
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Sun Jul 28 21:44:50 2019 +0200
+
+    db_text: small fix in docs
+    
+    (cherry picked from commit 6b946807dfa77eeead83b5a4650bd3e59f75ba57)
+
+commit 77c60ca41c1789cbc3b7872d0f66fc8323ac260f
+Author: Kamailio Dev <kamailio.dev@kamailio.org>
+Date:   Tue Jul 23 10:46:47 2019 +0200
+
+    modules: readme files regenerated - modules ... [skip ci]
+
+commit 4d8dac06ad4fe9bcdf9a2fbc2d79a56918ca4e8e
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Mon Jul 22 21:13:54 2019 +0200
+
+    tm: add missing docs about event_route[tm:local-request], GH #980
+    
+    (cherry picked from commit 8d613cb532fadecddde799a982bd9acf96df1eaf)
+
+commit 99e78ce404da0d7d0e98464916eef794d0f889a1
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Sun Jul 21 11:51:01 2019 +0200
+
+    uac: minor spelling fix in docs
+    
+    (cherry picked from commit e7061ee85ddcd203fb58fa023eeddd90bc97848e)
+
+commit 4a50d6c091e0c8b38a582d4b07263c5c97e64d7d
+Author: Kamailio Dev <kamailio.dev@kamailio.org>
+Date:   Tue Jul 16 11:22:31 2019 +0200
+
+    modules: readme files regenerated - modules ... [skip ci]
+
+commit e0f95f60ae08b583f52f1aa3aee72ef57c85e139
+Author: Niall McAndrew <34754073+niallmcandrew@users.noreply.github.com>
+Date:   Tue Jul 16 10:53:47 2019 +1200
+
+    tcpops: Fix the example documentation for tcp_get_conid
+    
+    (cherry picked from commit e094407297e89e574f10347ce720bd8475537970)
+
+commit 7c8ee7a32a712cddc4d6080f9d9f48a588113eb0
+Author: Victor Seva <linuxmaniac@torreviejawireless.org>
+Date:   Mon Jul 15 12:09:00 2019 +0200
+
+    rtpengine: fix error output on send_rtpp_command()
+    
+    * rename out variable to cmd due to We already have an out goto label
+    
+    (cherry picked from commit 262068940ba8dbd1b9fd93847f83f40c038d988c)
+
+commit 13e6e5ab591297237027a966b01cef5cb59f9f10
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Sun Jul 14 12:25:28 2019 +0200
+
+    dispatcher: small spelling fix in docs
+    
+    (cherry picked from commit 93d18c0e4a805c86e82e2271d2d496b4b125fdfd)
+
+commit c23ea82a80c3e66a11b3c1f0bb0ea22e0e7985bb
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Wed Jul 3 22:09:40 2019 +0200
+
+    acc: extend description in docs for log_missed_calls flag
+    
+    (cherry picked from commit f7f3222ec03b2a1e9260a79e737cc55c7dac169f)
+
+commit 01786b79e449506d0ccdf7528343e996be4e7cad
+Author: Kamailio Dev <kamailio.dev@kamailio.org>
+Date:   Wed Jul 3 16:57:48 2019 +0200
+
+    modules: readme files regenerated - modules ... [skip ci]
+
+commit f9caee5851bfafe195ebf009bd6a51051394c7d5
+Author: Victor Seva <linuxmaniac@torreviejawireless.org>
+Date:   Fri Jun 28 17:06:54 2019 +0200
+
+    usrloc: fix memory leak on DB_ONLY mode on RPC commands
+    
+    (cherry picked from commit b97bb77265e7bfc5562a664e8a510692ed68b2f8)
+
+commit baf9e9fbfcf3be043085a649eec3f396213bcb5c
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Sun Jun 30 11:51:57 2019 +0200
+
+    call_control: add a note that the callcontrol application expect the MI interface
+    
+    (cherry picked from commit 62d607f29593bcd645c7d068327e0bd4a0db0a8f)
+
+commit 4a458861b4377f53218a6c836f18adca6b17a9ff
+Author: Victor Seva <linuxmaniac@torreviejawireless.org>
+Date:   Wed Jun 26 12:29:22 2019 +0200
+
+    registrar: clean avp/xavp created at 'usrloc:contact-expired' route_event
+    
+    (cherry picked from commit c671e78142b51515d64392fd9a9db8f07e904167)
+
+commit dcce685ab41097dc77fad50c414a66e634db72b9
+Author: Sergey Safarov <s.safarov@gmail.com>
+Date:   Fri Jun 14 02:00:09 2019 +0300
+
+    pkg/kamailio/obs: Updated libevent2 deps for CentOS 6 dist [skip ci]
+    
+    (cherry picked from commit a54b36e2533a71d8e38c03b497b470110a1e33fb)
+
+commit bda9d6a23a2c2e5f5548f0a57444aeb4137a0bb0
+Author: Sergey Safarov <s.safarov@gmail.com>
+Date:   Thu Jun 13 11:51:17 2019 +0300
+
+    pkg/kamailio/obs: Updated jansson module dependences
+    
+    (cherry picked from commit 602eacf713a092eb0b4758f243ddd2342d2ee16f)
+
+commit 2d2b993673d0296e6d9c08ff78b73341e407a37a
+Author: Henning Westerholt <hw@skalatan.de>
+Date:   Fri May 31 12:42:21 2019 +0200
+
+    htable: fix a possible null pointer dereference in dmq startup error case
+    
+    (cherry picked from commit 6f0b67b675dd18dce60fa3e5a4ece063216bbab5)
+
+
 ===================== 2019-05-22 Version 5.2.3 Released =====================
 
 ===================== Changes Since Version 5.2.2 ===========================
--- a/doc/tutorials/rpc_list/Makefile
+++ b/doc/tutorials/rpc_list/Makefile
@@ -148,7 +148,7 @@ c_defsX=-DNAME='\"kamailio\"' -DVERSION=
 	   -DHAVE_SCHED_SETSCHEDULER -DHAVE_IP_MREQN -DHAVE_EPOLL -DHAVE_SIGIO_RT \
 	   -DSIGINFO64_WORKARROUND -DUSE_FUTEX -DHAVE_SELECT
 
-c_defs=$(subst ^^,='\",$(subst ",\"',$(subst =",^^,$(shell make -s -C ../../../src printcdefs))))
+c_defs=$(subst ^^,='\",$(subst ",\"',$(subst =",^^,$(shell $(MAKE) -s -C ../../../src printcdefs))))
 
 c_defs+= -DMOD_NAME='\"rpcgen\"'
 c_defs+= -I$(COREPATH)/modules/app_sqlang/squirrel/include
@@ -176,7 +176,7 @@ get_listed_grp=$(word 2, $(subst :, ,$(1
 # get module interface define
 get_modiface=$(word 3, $(subst :, ,$(1)))
 
-find_modiface=$(if $(findstring modules,$(1)),$(shell make -s -C $(dir $(1)) printmiface),-DNONE)
+find_modiface=$(if $(findstring modules,$(1)),$(shell $(MAKE) -s -C $(dir $(1)) printmiface),-DNONE)
 
 # get base file name from file:grp: get_bname(file:grp)
 # => basename(file) without extension (e.g. get_bname(foo/bar.c:x) => bar)
--- a/misc/examples/ims/scscf/CxDataType_Rel7.xsd
+++ b/misc/examples/ims/scscf/CxDataType_Rel7.xsd
@@ -1,301 +1,301 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
-	<xs:simpleType name="tPriority" final="list restriction">
-		<xs:restriction base="xs:int">
-			<xs:minInclusive value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tProfilePartIndicator" final="list restriction">
-		<xs:restriction base="xs:unsignedByte">
-			<xs:maxInclusive value="1"/>
-			<xs:enumeration value="0">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">REGISTERED</label>
-						<definition xml:lang="en">iFC is part of the registered profile</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="1">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">UNREGISTERED</label>
-						<definition xml:lang="en">iFC is part of the unregistered profile</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tSharedIFCSetID" final="list restriction">
-		<xs:restriction base="xs:int">
-			<xs:minInclusive value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tGroupID" final="list restriction">
-		<xs:restriction base="xs:int">
-			<xs:minInclusive value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tRegistrationType" final="list restriction">
-		<xs:restriction base="xs:unsignedByte">
-			<xs:maxInclusive value="2"/>
-			<xs:enumeration value="0">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">INITIAL_REGISTRATION</label>
-						<definition xml:lang="en">Matches to REGISTER messages that are related to initial registration</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="1">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">RE-REGISTRATION</label>
-						<definition xml:lang="en">Matches to REGISTER messages that are related to re-registration</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="2">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">DE-REGISTRATION</label>
-						<definition xml:lang="en">Matches to REGISTER messages that are related to de-registration</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tDefaultHandling" final="list restriction">
-		<xs:restriction base="xs:unsignedByte">
-			<xs:maxInclusive value="1"/>
-			<xs:enumeration value="0">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">SESSION_CONTINUED</label>
-						<definition xml:lang="en">Session Continued</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="1">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">SESSION_TERMINATED</label>
-						<definition xml:lang="en">Session Terminated</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tDirectionOfRequest" final="list restriction">
-		<xs:restriction base="xs:unsignedByte">
-			<xs:maxInclusive value="3"/>
-			<xs:enumeration value="0">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">ORIGINATING_SESSION</label>
-						<definition xml:lang="en">Originating Session</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="1">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">TERMINATING_REGISTERED</label>
-						<definition xml:lang="en">Terminating Session for registered user</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="2">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">TERMINATING_UNREGISTERED</label>
-						<definition xml:lang="en">Terminating Session for unregistered user</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="3">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">ORIGINATING_UNREGISTERED</label>
-						<definition xml:lang="en">Originating Session for an unregistered user</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tPrivateID" final="list restriction">
-		<xs:restriction base="xs:anyURI"/>
-	</xs:simpleType>
-	<xs:simpleType name="tSIP_URL" final="list restriction">
-		<xs:restriction base="xs:anyURI"/>
-	</xs:simpleType>
-	<xs:simpleType name="tTEL_URL" final="list restriction">
-		<xs:restriction base="xs:anyURI"/>
-	</xs:simpleType>
-	<xs:simpleType name="tIdentity" final="list restriction">
-		<xs:union memberTypes="tSIP_URL tTEL_URL"/>
-	</xs:simpleType>
-	<xs:simpleType name="tIdentityType" final="list restriction">
-		<xs:restriction base="xs:unsignedByte">
-			<xs:minInclusive value="0"/>
-			<xs:maxInclusive value="2"/>
-			<xs:enumeration value="0">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">PUBLIC_USER_IDENTITY</label>
-						<definition xml:lang="en">Identity is a Public User Identity.</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="1">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">DISTINCT_PSI</label>
-						<definition xml:lang="en">Identity is a distinct Public Service Identity.</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="2">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">WILDCARDED_PSI</label>
-						<definition xml:lang="en">Identity matches a wildcarded Public Service Identity.</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:complexType name="tPublicIdentityExtension">
-		<xs:sequence>
-			<xs:element name="IdentityType" type="tIdentityType" minOccurs="0"/>
-			<xs:element name="WildcardedPSI" type="xs:anyURI" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:simpleType name="tServiceInfo" final="list restriction">
-		<xs:restriction base="xs:string">
-			<xs:minLength value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tString" final="list restriction">
-		<xs:restriction base="xs:string">
-			<xs:minLength value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tBool">
-		<xs:restriction base="xs:boolean"/>
-	</xs:simpleType>
-	<xs:simpleType name="tSubscribedMediaProfileId" final="list restriction">
-		<xs:restriction base="xs:int">
-			<xs:minInclusive value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:complexType name="tExtension">
-		<xs:sequence>
-			<xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tServiceProfileExtension">
-		<xs:sequence>
-			<xs:element name="SharedIFCSetID" type="tSharedIFCSetID" minOccurs="0" maxOccurs="unbounded"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tSePoTriExtension">
-		<xs:sequence>
-			<xs:element name="RegistrationType" type="tRegistrationType" minOccurs="0" maxOccurs="2"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tIMSSubscription">
-		<xs:sequence>
-			<xs:element name="PrivateID" type="tPrivateID"/>
-			<xs:element name="ServiceProfile" type="tServiceProfile" maxOccurs="unbounded"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tServiceProfile">
-		<xs:sequence>
-			<xs:element name="PublicIdentity" type="tPublicIdentity" maxOccurs="unbounded"/>
-			<xs:element name="CoreNetworkServicesAuthorization" type="tCoreNetworkServicesAuthorization" minOccurs="0"/>
-			<xs:element name="InitialFilterCriteria" type="tInitialFilterCriteria" minOccurs="0" maxOccurs="unbounded"/>
-			<xs:element name="Extension" type="tServiceProfileExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tCoreNetworkServicesAuthorization">
-		<xs:sequence>
-			<xs:element name="SubscribedMediaProfileId" type="tSubscribedMediaProfileId" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tInitialFilterCriteria">
-		<xs:sequence>
-			<xs:element name="Priority" type="tPriority"/>
-			<xs:element name="TriggerPoint" type="tTrigger" minOccurs="0"/>
-			<xs:element name="ApplicationServer" type="tApplicationServer"/>
-			<xs:element name="ProfilePartIndicator" type="tProfilePartIndicator" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tTrigger">
-		<xs:sequence>
-			<xs:element name="ConditionTypeCNF" type="tBool"/>
-			<xs:element name="SPT" type="tSePoTri" maxOccurs="unbounded"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tSePoTri">
-		<xs:sequence>
-			<xs:element name="ConditionNegated" type="tBool" default="0" minOccurs="0"/>
-			<xs:element name="Group" type="tGroupID" maxOccurs="unbounded"/>
-			<xs:choice>
-				<xs:element name="RequestURI" type="tString"/>
-				<xs:element name="Method" type="tString"/>
-				<xs:element name="SIPHeader" type="tHeader"/>
-				<xs:element name="SessionCase" type="tDirectionOfRequest"/>
-				<xs:element name="SessionDescription" type="tSessionDescription"/>
-			</xs:choice>
-			<xs:element name="Extension" type="tSePoTriExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tHeader">
-		<xs:sequence>
-			<xs:element name="Header" type="tString"/>
-			<xs:element name="Content" type="tString" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tSessionDescription">
-		<xs:sequence>
-			<xs:element name="Line" type="tString"/>
-			<xs:element name="Content" type="tString" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tApplicationServer">
-		<xs:sequence>
-			<xs:element name="ServerName" type="tSIP_URL"/>
-			<xs:element name="DefaultHandling" type="tDefaultHandling" minOccurs="0"/>
-			<xs:element name="ServiceInfo" type="tServiceInfo" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tPublicIdentity">
-		<xs:sequence>
-			<xs:element name="BarringIndication" type="tBool" default="0" minOccurs="0"/>
-			<xs:element name="Identity" type="tIdentity"/>
-			<xs:element name="Extension" type="tPublicIdentityExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:element name="IMSSubscription" type="tIMSSubscription"/>
-</xs:schema>
+<?xml version="1.0" encoding="UTF-8"?>
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
+	<xs:simpleType name="tPriority" final="list restriction">
+		<xs:restriction base="xs:int">
+			<xs:minInclusive value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tProfilePartIndicator" final="list restriction">
+		<xs:restriction base="xs:unsignedByte">
+			<xs:maxInclusive value="1"/>
+			<xs:enumeration value="0">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">REGISTERED</label>
+						<definition xml:lang="en">iFC is part of the registered profile</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="1">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">UNREGISTERED</label>
+						<definition xml:lang="en">iFC is part of the unregistered profile</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tSharedIFCSetID" final="list restriction">
+		<xs:restriction base="xs:int">
+			<xs:minInclusive value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tGroupID" final="list restriction">
+		<xs:restriction base="xs:int">
+			<xs:minInclusive value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tRegistrationType" final="list restriction">
+		<xs:restriction base="xs:unsignedByte">
+			<xs:maxInclusive value="2"/>
+			<xs:enumeration value="0">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">INITIAL_REGISTRATION</label>
+						<definition xml:lang="en">Matches to REGISTER messages that are related to initial registration</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="1">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">RE-REGISTRATION</label>
+						<definition xml:lang="en">Matches to REGISTER messages that are related to re-registration</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="2">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">DE-REGISTRATION</label>
+						<definition xml:lang="en">Matches to REGISTER messages that are related to de-registration</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tDefaultHandling" final="list restriction">
+		<xs:restriction base="xs:unsignedByte">
+			<xs:maxInclusive value="1"/>
+			<xs:enumeration value="0">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">SESSION_CONTINUED</label>
+						<definition xml:lang="en">Session Continued</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="1">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">SESSION_TERMINATED</label>
+						<definition xml:lang="en">Session Terminated</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tDirectionOfRequest" final="list restriction">
+		<xs:restriction base="xs:unsignedByte">
+			<xs:maxInclusive value="3"/>
+			<xs:enumeration value="0">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">ORIGINATING_SESSION</label>
+						<definition xml:lang="en">Originating Session</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="1">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">TERMINATING_REGISTERED</label>
+						<definition xml:lang="en">Terminating Session for registered user</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="2">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">TERMINATING_UNREGISTERED</label>
+						<definition xml:lang="en">Terminating Session for unregistered user</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="3">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">ORIGINATING_UNREGISTERED</label>
+						<definition xml:lang="en">Originating Session for an unregistered user</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tPrivateID" final="list restriction">
+		<xs:restriction base="xs:anyURI"/>
+	</xs:simpleType>
+	<xs:simpleType name="tSIP_URL" final="list restriction">
+		<xs:restriction base="xs:anyURI"/>
+	</xs:simpleType>
+	<xs:simpleType name="tTEL_URL" final="list restriction">
+		<xs:restriction base="xs:anyURI"/>
+	</xs:simpleType>
+	<xs:simpleType name="tIdentity" final="list restriction">
+		<xs:union memberTypes="tSIP_URL tTEL_URL"/>
+	</xs:simpleType>
+	<xs:simpleType name="tIdentityType" final="list restriction">
+		<xs:restriction base="xs:unsignedByte">
+			<xs:minInclusive value="0"/>
+			<xs:maxInclusive value="2"/>
+			<xs:enumeration value="0">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">PUBLIC_USER_IDENTITY</label>
+						<definition xml:lang="en">Identity is a Public User Identity.</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="1">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">DISTINCT_PSI</label>
+						<definition xml:lang="en">Identity is a distinct Public Service Identity.</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="2">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">WILDCARDED_PSI</label>
+						<definition xml:lang="en">Identity matches a wildcarded Public Service Identity.</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="tPublicIdentityExtension">
+		<xs:sequence>
+			<xs:element name="IdentityType" type="tIdentityType" minOccurs="0"/>
+			<xs:element name="WildcardedPSI" type="xs:anyURI" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="tServiceInfo" final="list restriction">
+		<xs:restriction base="xs:string">
+			<xs:minLength value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tString" final="list restriction">
+		<xs:restriction base="xs:string">
+			<xs:minLength value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tBool">
+		<xs:restriction base="xs:boolean"/>
+	</xs:simpleType>
+	<xs:simpleType name="tSubscribedMediaProfileId" final="list restriction">
+		<xs:restriction base="xs:int">
+			<xs:minInclusive value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="tExtension">
+		<xs:sequence>
+			<xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tServiceProfileExtension">
+		<xs:sequence>
+			<xs:element name="SharedIFCSetID" type="tSharedIFCSetID" minOccurs="0" maxOccurs="unbounded"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tSePoTriExtension">
+		<xs:sequence>
+			<xs:element name="RegistrationType" type="tRegistrationType" minOccurs="0" maxOccurs="2"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tIMSSubscription">
+		<xs:sequence>
+			<xs:element name="PrivateID" type="tPrivateID"/>
+			<xs:element name="ServiceProfile" type="tServiceProfile" maxOccurs="unbounded"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tServiceProfile">
+		<xs:sequence>
+			<xs:element name="PublicIdentity" type="tPublicIdentity" maxOccurs="unbounded"/>
+			<xs:element name="CoreNetworkServicesAuthorization" type="tCoreNetworkServicesAuthorization" minOccurs="0"/>
+			<xs:element name="InitialFilterCriteria" type="tInitialFilterCriteria" minOccurs="0" maxOccurs="unbounded"/>
+			<xs:element name="Extension" type="tServiceProfileExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tCoreNetworkServicesAuthorization">
+		<xs:sequence>
+			<xs:element name="SubscribedMediaProfileId" type="tSubscribedMediaProfileId" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tInitialFilterCriteria">
+		<xs:sequence>
+			<xs:element name="Priority" type="tPriority"/>
+			<xs:element name="TriggerPoint" type="tTrigger" minOccurs="0"/>
+			<xs:element name="ApplicationServer" type="tApplicationServer"/>
+			<xs:element name="ProfilePartIndicator" type="tProfilePartIndicator" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tTrigger">
+		<xs:sequence>
+			<xs:element name="ConditionTypeCNF" type="tBool"/>
+			<xs:element name="SPT" type="tSePoTri" maxOccurs="unbounded"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tSePoTri">
+		<xs:sequence>
+			<xs:element name="ConditionNegated" type="tBool" default="0" minOccurs="0"/>
+			<xs:element name="Group" type="tGroupID" maxOccurs="unbounded"/>
+			<xs:choice>
+				<xs:element name="RequestURI" type="tString"/>
+				<xs:element name="Method" type="tString"/>
+				<xs:element name="SIPHeader" type="tHeader"/>
+				<xs:element name="SessionCase" type="tDirectionOfRequest"/>
+				<xs:element name="SessionDescription" type="tSessionDescription"/>
+			</xs:choice>
+			<xs:element name="Extension" type="tSePoTriExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tHeader">
+		<xs:sequence>
+			<xs:element name="Header" type="tString"/>
+			<xs:element name="Content" type="tString" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tSessionDescription">
+		<xs:sequence>
+			<xs:element name="Line" type="tString"/>
+			<xs:element name="Content" type="tString" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tApplicationServer">
+		<xs:sequence>
+			<xs:element name="ServerName" type="tSIP_URL"/>
+			<xs:element name="DefaultHandling" type="tDefaultHandling" minOccurs="0"/>
+			<xs:element name="ServiceInfo" type="tServiceInfo" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tPublicIdentity">
+		<xs:sequence>
+			<xs:element name="BarringIndication" type="tBool" default="0" minOccurs="0"/>
+			<xs:element name="Identity" type="tIdentity"/>
+			<xs:element name="Extension" type="tPublicIdentityExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:element name="IMSSubscription" type="tIMSSubscription"/>
+</xs:schema>
--- a/misc/tools/route_graph/route_graph.py
+++ b/misc/tools/route_graph/route_graph.py
@@ -75,12 +75,12 @@ def traverse_routes(_level, _name):
 
 
 if len(sys.argv) < 2:
-	raise "usage: %s configuration-file [max_depth]" % sys.argv[0]
+	raise Exception('wrong number of arguments\nusage: ' + sys.argv[0] + ' configuration-file [max_depth]')
 if len(sys.argv) == 3:
 	max_depth = int(sys.argv[2])
 cfg = file(sys.argv[1], "r")
-if cfg == None:
-	raise "Missing config file"
+if cfg is None:
+	raise Exception ('Missing config file')
 line = cfg.readline()
 rt = routes
 while line:
@@ -90,40 +90,40 @@ while line:
 		main_match = re_main_route.search(line)
 		def_match = re_def_route.search(line)
 		call_match = re_call_route.search(line)
-		if not call_match == None:
+		if not call_match is None:
 			log("CALL: " + line)
 			name = call_match.group(2)
 			log(rname +":"+name)
 			rt[rname].append(name)
-		elif not def_match == None:
+		elif not def_match is None:
 			log("DEF: " + line)
 			rtype = def_match.group(1)
 			rname = def_match.group(3)
 			if rtype == "failure_":
 				rt = f_routes
-				if rname == None:
+				if rname is None:
 					rname = "failure"
 			elif rtype == "onreply_":
 				rt = r_routes
-				if rname == None:
+				if rname is None:
 					rname = "onreply"
 			elif rtype == "onsend_":
 				rt = s_routes
-				if rname == None:
+				if rname is None:
 					rname = "onsend"
 			elif rtype == "branch_":
 				rt = b_routes
-				if rname == None:
+				if rname is None:
 					rname = "branch"
 			elif rtype == "event_":
 				rt = e_routes
-				if rname == None:
+				if rname is None:
 					rname = "event"
 			else:
 				rt = routes
 			log(rname)
 			rt[rname] = []
-		elif not main_match == None:
+		elif not main_match is None:
 			log("MAIN: " + line)
 			rtype = main_match.group(1)
 			if rtype == "failure_":
--- a/pkg/kamailio/alpine/APKBUILD
+++ b/pkg/kamailio/alpine/APKBUILD
@@ -4,7 +4,7 @@
 # Maintainer: Nathan Angelacos <nangel@alpinelinux.org>
 
 pkgname=kamailio
-pkgver=5.2.3
+pkgver=5.2.4
 pkgrel=0
 
 # If building from a git snapshot, specify the gitcommit
--- a/pkg/kamailio/deb/bionic/changelog
+++ b/pkg/kamailio/deb/bionic/changelog
@@ -1,3 +1,9 @@
+kamailio (5.2.4) unstable; urgency=medium
+
+  * version set 5.2.4
+
+ -- Victor Seva <vseva@debian.org>  Wed, 14 Aug 2019 08:32:02 +0200
+
 kamailio (5.2.3) unstable; urgency=medium
 
   * version set 5.2.3
--- a/pkg/kamailio/deb/buster/changelog
+++ b/pkg/kamailio/deb/buster/changelog
@@ -1,3 +1,9 @@
+kamailio (5.2.4) unstable; urgency=medium
+
+  * version set 5.2.4
+
+ -- Victor Seva <vseva@debian.org>  Wed, 14 Aug 2019 08:32:02 +0200
+
 kamailio (5.2.3) unstable; urgency=medium
 
   * version set 5.2.3
--- a/pkg/kamailio/deb/debian/changelog
+++ b/pkg/kamailio/deb/debian/changelog
@@ -1,3 +1,9 @@
+kamailio (5.2.4) unstable; urgency=medium
+
+  * version set 5.2.4
+
+ -- Victor Seva <vseva@debian.org>  Wed, 14 Aug 2019 08:32:02 +0200
+
 kamailio (5.2.3) unstable; urgency=medium
 
   * version set 5.2.3
--- a/pkg/kamailio/deb/jessie/changelog
+++ b/pkg/kamailio/deb/jessie/changelog
@@ -1,3 +1,9 @@
+kamailio (5.2.4) unstable; urgency=medium
+
+  * version set 5.2.4
+
+ -- Victor Seva <vseva@debian.org>  Wed, 14 Aug 2019 08:32:02 +0200
+
 kamailio (5.2.3) unstable; urgency=medium
 
   * version set 5.2.3
--- a/pkg/kamailio/deb/precise/changelog
+++ b/pkg/kamailio/deb/precise/changelog
@@ -1,3 +1,9 @@
+kamailio (5.2.4) unstable; urgency=medium
+
+  * version set 5.2.4
+
+ -- Victor Seva <vseva@debian.org>  Wed, 14 Aug 2019 08:32:02 +0200
+
 kamailio (5.2.3) unstable; urgency=medium
 
   * version set 5.2.3
--- a/pkg/kamailio/deb/sid/changelog
+++ b/pkg/kamailio/deb/sid/changelog
@@ -1,3 +1,9 @@
+kamailio (5.2.4) unstable; urgency=medium
+
+  * version set 5.2.4
+
+ -- Victor Seva <vseva@debian.org>  Wed, 14 Aug 2019 08:32:02 +0200
+
 kamailio (5.2.3) unstable; urgency=medium
 
   * version set 5.2.3
--- a/pkg/kamailio/deb/stretch/changelog
+++ b/pkg/kamailio/deb/stretch/changelog
@@ -1,3 +1,9 @@
+kamailio (5.2.4) unstable; urgency=medium
+
+  * version set 5.2.4
+
+ -- Victor Seva <vseva@debian.org>  Wed, 14 Aug 2019 08:32:02 +0200
+
 kamailio (5.2.3) unstable; urgency=medium
 
   * version set 5.2.3
--- a/pkg/kamailio/deb/trusty/changelog
+++ b/pkg/kamailio/deb/trusty/changelog
@@ -1,3 +1,9 @@
+kamailio (5.2.4) unstable; urgency=medium
+
+  * version set 5.2.4
+
+ -- Victor Seva <vseva@debian.org>  Wed, 14 Aug 2019 08:32:02 +0200
+
 kamailio (5.2.3) unstable; urgency=medium
 
   * version set 5.2.3
--- a/pkg/kamailio/deb/wheezy/changelog
+++ b/pkg/kamailio/deb/wheezy/changelog
@@ -1,3 +1,9 @@
+kamailio (5.2.4) unstable; urgency=medium
+
+  * version set 5.2.4
+
+ -- Victor Seva <vseva@debian.org>  Wed, 14 Aug 2019 08:32:02 +0200
+
 kamailio (5.2.3) unstable; urgency=medium
 
   * version set 5.2.3
--- a/pkg/kamailio/deb/xenial/changelog
+++ b/pkg/kamailio/deb/xenial/changelog
@@ -1,3 +1,9 @@
+kamailio (5.2.4) unstable; urgency=medium
+
+  * version set 5.2.4
+
+ -- Victor Seva <vseva@debian.org>  Wed, 14 Aug 2019 08:32:02 +0200
+
 kamailio (5.2.3) unstable; urgency=medium
 
   * version set 5.2.3
--- a/pkg/kamailio/obs/kamailio.spec
+++ b/pkg/kamailio/obs/kamailio.spec
@@ -1,5 +1,5 @@
 %define name    kamailio
-%define ver 5.2.3
+%define ver 5.2.4
 %define rel dev1.0%{dist}
 
 %if 0%{?fedora} == 27
@@ -102,18 +102,68 @@
 %bcond_without xmlrpc
 %endif
 
+%if 0%{?fedora} == 31
+%define dist_name fedora
+%define dist_version %{?fedora}
+%bcond_without cnxcc
+%bcond_with dnssec
+%bcond_without geoip
+%bcond_without http_async_client
+%bcond_without ims
+%bcond_without jansson
+%bcond_without json
+%bcond_without lua
+%bcond_without kazoo
+%bcond_without memcached
+%bcond_without mongodb
+%bcond_without perl
+%bcond_without phonenum
+%bcond_without python3
+%bcond_without rabbitmq
+%bcond_without redis
+%bcond_without ruby
+%bcond_without sctp
+%bcond_without websocket
+%bcond_without xmlrpc
+%endif
+
+%if 0%{?fedora} == 99
+%define dist_name fedora
+%define dist_version %{?fedora}
+%bcond_without cnxcc
+%bcond_with dnssec
+%bcond_without geoip
+%bcond_without http_async_client
+%bcond_without ims
+%bcond_without jansson
+%bcond_without json
+%bcond_without lua
+%bcond_without kazoo
+%bcond_without memcached
+%bcond_without mongodb
+%bcond_without perl
+%bcond_without phonenum
+%bcond_without python3
+%bcond_without rabbitmq
+%bcond_without redis
+%bcond_without ruby
+%bcond_without sctp
+%bcond_without websocket
+%bcond_without xmlrpc
+%endif
+
 %if 0%{?centos_ver} == 6
 %define dist_name centos
 %define dist_version %{?centos}
 %bcond_with cnxcc
 %bcond_without dnssec
 %bcond_without geoip
-%bcond_with http_async_client
+%bcond_without http_async_client
 %bcond_without ims
-%bcond_with jansson
-%bcond_with json
+%bcond_without jansson
+%bcond_without json
 %bcond_without lua
-%bcond_with kazoo
+%bcond_without kazoo
 %bcond_without memcached
 %bcond_with mongodb
 %bcond_without perl
@@ -311,6 +361,14 @@ like Asterisk™, FreeSWITCH™ or SEMS.
 %package    acc_json
 Summary:    Account transaction information in a JSON dictionary
 Group:      %{PKGGROUP}
+Requires:   kamailio = %ver
+%if 0%{?rhel} == 6
+Requires:   libevent2
+BuildRequires:  libevent2-devel
+%else
+Requires:   libevent
+BuildRequires:  libevent-devel
+%endif
 %if 0%{?suse_version}
 Requires:   libjansson
 BuildRequires:  libjansson-devel
@@ -486,8 +544,14 @@ Compressed body (SIP and HTTP) handling
 %package    http_async_client
 Summary:    Async HTTP client module for Kamailio
 Group:      %{PKGGROUP}
-Requires:   libevent, kamailio = %ver
-BuildRequires: libevent-devel
+Requires:   kamailio = %ver
+%if 0%{?rhel} == 6
+Requires:   libevent2
+BuildRequires:  libevent2-devel
+%else
+Requires:   libevent
+BuildRequires:  libevent-devel
+%endif
 %if 0%{?suse_version}
 Requires:   libcurl4
 BuildRequires:  libcurl-devel
@@ -532,7 +596,14 @@ IMS modules and extensions module for Ka
 %package    jansson
 Summary:    JSON string handling and RPC modules for Kamailio using JANSSON library
 Group:      %{PKGGROUP}
-Requires:   libevent, kamailio = %ver
+Requires:   kamailio = %ver
+%if 0%{?rhel} == 6
+Requires:   libevent2
+BuildRequires:  libevent2-devel
+%else
+Requires:   libevent
+BuildRequires:  libevent-devel
+%endif
 %if 0%{?suse_version}
 Requires:   libjson-c2
 BuildRequires:  libjansson-devel
@@ -550,8 +621,14 @@ JSON string handling and RPC modules for
 %package    json
 Summary:    JSON string handling and RPC modules for Kamailio
 Group:      %{PKGGROUP}
-Requires:   libevent, kamailio = %ver
+Requires:   kamailio = %ver
+%if 0%{?rhel} == 6
+Requires:   libevent2
+BuildRequires:  libevent2-devel
+%else
+Requires:   libevent
 BuildRequires:  libevent-devel
+%endif
 %if 0%{?suse_version}
 Requires:   libjson-c2
 BuildRequires:  libjson-c-devel
@@ -569,8 +646,15 @@ JSON string handling and RPC modules for
 %package    kazoo
 Summary:    Kazoo middle layer connector support for Kamailio
 Group:      %{PKGGROUP}
-Requires:   libuuid, librabbitmq, json-c, libevent, kamailio = %ver
-BuildRequires:  libuuid-devel, librabbitmq-devel, json-c-devel, libevent-devel
+Requires:   libuuid, librabbitmq, json-c, kamailio = %ver
+BuildRequires:  libuuid-devel, librabbitmq-devel, json-c-devel
+%if 0%{?rhel} == 6
+Requires:   libevent2
+BuildRequires:  libevent2-devel
+%else
+Requires:   libevent
+BuildRequires:  libevent-devel
+%endif
 
 %description    kazoo
 Kazoo module for Kamailio.
@@ -746,6 +830,9 @@ Requires:   python3, kamailio = %ver
 BuildRequires:  python3, python3-devel
 %endif
 %endif
+%if 0%{?fedora}
+BuildRequires:  python2-devel
+%endif
 
 %description    python
 Python extensions for Kamailio.
@@ -1064,21 +1151,9 @@ UUID module for Kamailio.
     sed -i -e 's:#!/usr/bin/python:#!%{__python2}:' utils/kamctl/dbtextdb/dbtextdb.py
 %endif
 
-ln -s ../obs pkg/kamailio/fedora/27
-ln -s ../obs pkg/kamailio/fedora/28
-ln -s ../obs pkg/kamailio/fedora/29
-ln -s ../obs pkg/kamailio/fedora/30
-ln -s ../obs pkg/kamailio/rhel/6
-ln -s ../obs pkg/kamailio/rhel/7
-ln -s ../obs pkg/kamailio/opensuse/1315
-ln -s ../obs pkg/kamailio/opensuse/1330
-ln -s ../obs pkg/kamailio/opensuse/1500
-ln -s ../obs pkg/kamailio/opensuse/1550
-ln -s ../obs pkg/kamailio/centos/6
-ln -s ../obs pkg/kamailio/centos/7
-
 
 %build
+ln -s ../obs pkg/kamailio/%{dist_name}/%{dist_version}
 %if 0%{?fedora} || 0%{?suse_version}
 export FREERADIUS=1
 %endif
--- a/pkg/kamailio/obs/meta
+++ b/pkg/kamailio/obs/meta
@@ -32,27 +32,32 @@
     <path project="Fedora:EPEL:6" repository="RHEL"/>
     <arch>x86_64</arch>
   </repository>
-  <repository name="Fedora_29">
-    <path project="Fedora:29" repository="update"/>
-    <path project="Fedora:29" repository="standard"/>
+  <repository name="Fedora_Rawhide">
+    <path project="Fedora:Rawhide" repository="standard"/>
     <arch>x86_64</arch>
   </repository>
-  <repository name="Fedora_28">
-    <path project="Fedora:28" repository="update"/>
-    <path project="Fedora:28" repository="standard"/>
-    <arch>x86_64</arch>
+  <repository name="Fedora_30">
+    <path project="Fedora:30" repository="update"/>
+    <path project="Fedora:30" repository="standard"/>
+    <arch>x86_64</arch>
+    <arch>i586</arch>
+    <arch>armv7l</arch>
+    <arch>aarch64</arch>
+    <arch>ppc64le</arch>
   </repository>
-  <repository name="Fedora_27">
-    <path project="Fedora:27" repository="update"/>
-    <path project="Fedora:27" repository="standard"/>
+  <repository name="Fedora_29">
+    <path project="Fedora:29" repository="update"/>
+    <path project="Fedora:29" repository="standard"/>
     <arch>x86_64</arch>
   </repository>
   <repository name="CentOS_7">
+    <path project="CentOS:CentOS-7" repository="standard"/>
     <path project="CentOS:CentOS-7" repository="update"/>
     <path project="Fedora:EPEL:7" repository="CentOS"/>
     <arch>x86_64</arch>
   </repository>
   <repository name="CentOS_6">
+    <path project="CentOS:CentOS-6" repository="standard"/>
     <path project="CentOS:CentOS-6" repository="update"/>
     <path project="Fedora:EPEL:6" repository="CentOS"/>
     <arch>x86_64</arch>
--- a/pkg/kamailio/obs/sipcapture.service
+++ b/pkg/kamailio/obs/sipcapture.service
@@ -8,6 +8,8 @@ After=mysqld.service
 
 [Service]
 Type=simple
+User=kamailio
+Group=kamailio
 WorkingDirectory=/run/sipcapture
 Environment='CFGFILE=/etc/kamailio/kamailio-sipcapture.cfg'
 Environment='SHM_MEMORY=32'
@@ -18,8 +20,6 @@ PIDFile=/run/sipcapture/sipcapture.pid
 # ExecStart requires a full absolute path
 ExecStart=/usr/sbin/kamailio -DD -P /run/sipcapture/sipcapture.pid -f $CFGFILE -m $SHM_MEMORY -M $PKG_MEMORY
 Restart=on-failure
-User=kamailio
-Group=daemon
 
 
 [Install]
--- a/pkg/kamailio/obs/sipcapture.tmpfiles
+++ b/pkg/kamailio/obs/sipcapture.tmpfiles
@@ -1 +1 @@
-D /run/sipcapture 0700 kamailio daemon -
+D /run/sipcapture 0700 kamailio kamailio -
--- a/pkg/kamailio/oracle/el6/kamailio.spec
+++ b/pkg/kamailio/oracle/el6/kamailio.spec
@@ -1,5 +1,5 @@
 %define name    kamailio
-%define ver     5.2.3
+%define ver     5.2.4
 %define rel     0
 %define _sharedir %{_prefix}/share
 
--- a/pkg/kamailio/oracle/el7/kamailio.spec
+++ b/pkg/kamailio/oracle/el7/kamailio.spec
@@ -1,5 +1,5 @@
 %define name    kamailio
-%define ver     5.2.3
+%define ver     5.2.4
 %define rel     0
 %define _sharedir %{_prefix}/share
 
--- a/pkg/kamailio/solaris/kamailio-manifest.xml
+++ b/pkg/kamailio/solaris/kamailio-manifest.xml
@@ -1,43 +1,43 @@
-<?xml version="1.0"?>
-<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
-
-<!-- This is a manifest file to start, stop or restart the server automatically at
-     the Solaris 10 bootup. Setup and usage:
-     cp kamailio-manifest.xml to /var/svc/manifest/network/kamailio.xml
-     chmod 444 kamailio.xml
-     svccg -v import kamailio.xml
-     and finally enable the server to be a SMF service:
-     svcadm enable kamailio -->
-
-<service_bundle type='manifest' name='kamailio'>	
-	<service name='network/kamailio' type='service' version='1'>
-		<create_default_instance enabled='false' />
-		<single_instance/>
-
-		<dependency name='multi-user' grouping='require_all' restart_on='none' type='service'>
-			<service_fmri value='svc:/milestone/multi-user' />
-		</dependency>
-
-		<dependency name='multi-user-server' grouping='require_all' restart_on='none' type='service'>
-			<service_fmri value='svc:/milestone/multi-user-server' />
-		</dependency>
-
-		<dependency name='cswmysql5' grouping='require_all' restart_on='none' type='service'>
-			<!-- adapt if you use another mysql version -->
-			<service_fmri value='svc:/network/cswmysql5:default' />
-		</dependency>
-
-		<exec_method type='method' name='start' exec='/sbin/kamctl start' timeout_seconds='30' />
-
-		<exec_method type='method' name='stop' exec='/sbin/kamctl stop' timeout_seconds='60' /> 
-
-		<exec_method type='method' name='restart' exec='/sbin/kamctl restart' timeout_seconds='-1' />
-
-		<stability value='Unstable' />
-		<template>
-			<common_name>
-				<loctext xml:lang='C'> Kamailio </loctext> 
-			</common_name>
-		</template>
-	</service>
-</service_bundle>
+<?xml version="1.0"?>
+<!DOCTYPE service_bundle SYSTEM "/usr/share/lib/xml/dtd/service_bundle.dtd.1">
+
+<!-- This is a manifest file to start, stop or restart the server automatically at
+     the Solaris 10 bootup. Setup and usage:
+     cp kamailio-manifest.xml to /var/svc/manifest/network/kamailio.xml
+     chmod 444 kamailio.xml
+     svccg -v import kamailio.xml
+     and finally enable the server to be a SMF service:
+     svcadm enable kamailio -->
+
+<service_bundle type='manifest' name='kamailio'>	
+	<service name='network/kamailio' type='service' version='1'>
+		<create_default_instance enabled='false' />
+		<single_instance/>
+
+		<dependency name='multi-user' grouping='require_all' restart_on='none' type='service'>
+			<service_fmri value='svc:/milestone/multi-user' />
+		</dependency>
+
+		<dependency name='multi-user-server' grouping='require_all' restart_on='none' type='service'>
+			<service_fmri value='svc:/milestone/multi-user-server' />
+		</dependency>
+
+		<dependency name='cswmysql5' grouping='require_all' restart_on='none' type='service'>
+			<!-- adapt if you use another mysql version -->
+			<service_fmri value='svc:/network/cswmysql5:default' />
+		</dependency>
+
+		<exec_method type='method' name='start' exec='/sbin/kamctl start' timeout_seconds='30' />
+
+		<exec_method type='method' name='stop' exec='/sbin/kamctl stop' timeout_seconds='60' /> 
+
+		<exec_method type='method' name='restart' exec='/sbin/kamctl restart' timeout_seconds='-1' />
+
+		<stability value='Unstable' />
+		<template>
+			<common_name>
+				<loctext xml:lang='C'> Kamailio </loctext> 
+			</common_name>
+		</template>
+	</service>
+</service_bundle>
--- a/src/Makefile.defs
+++ b/src/Makefile.defs
@@ -106,7 +106,7 @@ INSTALL_FLAVOUR=$(FLAVOUR)
 # version number
 VERSION = 5
 PATCHLEVEL = 2
-SUBLEVEL = 3
+SUBLEVEL = 4
 EXTRAVERSION = 
 
 # memory manager switcher
@@ -178,6 +178,42 @@ CC_EXTRA_OPTS ?=
 # extra LD command line options
 LD_EXTRA_OPTS ?=
 
+
+# enable workaround for libssl 1.1+ to set shared mutex attribute
+LIBSSL_SET_MUTEX_SHARED ?=
+ifneq ($(LIBSSL_SET_MUTEX_SHARED), 1)
+
+ifeq ($(CROSS_COMPILE),)
+LIBSSL_PKGCONFIG=$(shell \
+	if pkg-config --exists libssl; then \
+		echo 'pkg-config libssl'; \
+	fi)
+endif
+
+ifneq ($(LIBSSL_PKGCONFIG),)
+
+# numerical version (good for comparisons: A.B.C => A*1000000+B*1000+C)
+LIBSSL_VERNUM:= $(shell $(LIBSSL_PKGCONFIG) --modversion | sed -e 's/^[^0-9]*//' \
+		-e 's/^\([0-9][0-9]*\(\.[0-9][0-9]*\)*\).*$$/\1/g' | \
+		(IFS=. read A B C D; R=0; \
+		[ -n "$$A" ] && R=`expr $$R \* 1000 + $$A` && \
+		[ -n "$$B" ] && R=`expr $$R \* 1000 + $$B` && \
+		[ -n "$$C" ] && R=`expr $$R \* 1000 + $$C`; echo $$R ) )
+
+# libssl version greater or equal than 1.1
+ifeq ($(shell [ $(LIBSSL_VERNUM) -ge 1001000 ] && echo libssl11plus), libssl11plus)
+LIBSSL_SET_MUTEX_SHARED := 1
+endif
+
+endif
+
+endif
+
+ifeq ($(LIBSSL_SET_MUTEX_SHARED), 1)
+CC_EXTRA_OPTS+= -pthread -DKSR_PTHREAD_MUTEX_SHARED
+LD_EXTRA_OPTS+= -pthread -rdynamic -ldl -Wl,-Bsymbolic-functions
+endif
+
 ifeq ($(OS), solaris)
 #use GNU versions
 INSTALL ?= ginstall
--- a/src/core/action.c
+++ b/src/core/action.c
@@ -1434,6 +1434,9 @@ match_cleanup:
 				ret=E_BUG;
 				goto error;
 			}
+			LM_DBG("setting send-socket to [%.*s]\n",
+					((struct socket_info*)a->val[0].u.data)->sock_str.len,
+					((struct socket_info*)a->val[0].u.data)->sock_str.s);
 			set_force_socket(msg, (struct socket_info*)a->val[0].u.data);
 			ret=1; /* continue processing */
 			break;
--- a/src/core/cfg.lex
+++ b/src/core/cfg.lex
@@ -1922,14 +1922,24 @@ static void pp_ifdef()
 
 static void pp_else()
 {
+	if(pp_sptr==0) {
+		LM_WARN("invalid position for preprocessor directive 'else'"
+				" - at %s line %d\n", (finame)?finame:"cfg", line);
+		return;
+	}
 	pp_ifdef_stack[pp_sptr-1] ^= 1;
 	pp_update_state();
 }
 
 static void pp_endif()
 {
-	pp_sptr--;
 	pp_ifdef_level_update(-1);
+	if(pp_sptr==0) {
+		LM_WARN("invalid position for preprocessor directive 'else'"
+				" - at %s line %d\n", (finame)?finame:"cfg", line);
+		return;
+	}
+	pp_sptr--;
 	pp_update_state();
 }
 
--- a/src/core/cfg/cfg_struct.c
+++ b/src/core/cfg/cfg_struct.c
@@ -682,7 +682,7 @@ cfg_group_inst_t *cfg_extend_array(cfg_g
 	if (i > 0)
 		memcpy(	new_array,
 				old_array,
-				inst_size * i);
+				(size_t) inst_size * i);
 
 	memset((char*)new_array + inst_size * i, 0, inst_size);
 	*new_group = (cfg_group_inst_t *)((char*)new_array + inst_size * i);
@@ -691,7 +691,7 @@ cfg_group_inst_t *cfg_extend_array(cfg_g
 	if (i < meta->num)
 		memcpy(	(char*)new_array + inst_size * (i + 1),
 				(char*)old_array + inst_size * i,
-				inst_size * (meta->num - i));
+				(size_t) inst_size * (meta->num - i));
 
 	return new_array;
 }
--- a/src/core/char_msg_val.h
+++ b/src/core/char_msg_val.h
@@ -38,6 +38,7 @@
 inline static int char_msg_val( struct sip_msg *msg, char *cv )
 {
 	str src[8];
+	str sempty = str_init("");
 
 	if (unlikely(!check_transaction_quadruple(msg))) {
 		LM_ERR("can't calculate char_value due to a parsing error\n");
@@ -55,7 +56,12 @@ inline static int char_msg_val( struct s
 	}
 	/* use only the from & to tags */
 	src[0]=get_from(msg)->tag_value;
-	src[1]=get_to(msg)->tag_value;
+	if(msg->first_line.u.request.method_value
+			& (METHOD_INVITE|METHOD_ACK|METHOD_CANCEL)) {
+		src[1]=sempty;
+	} else {
+		src[1]=get_to(msg)->tag_value;
+	}
 	src[2]= msg->callid->body;
 	src[3]= msg->first_line.u.request.uri;
 	src[4]= get_cseq( msg )->number;
--- a/src/core/daemonize.c
+++ b/src/core/daemonize.c
@@ -357,7 +357,7 @@ int daemonize(char*  name,  int status_w
 			fprintf(pid_stream, "%i\n", (int)pid);
 			fclose(pid_stream);
 			if(chown(pid_file, pid_uid, pid_gid)<0) {
-				LM_ERR("failed to chwon PID file: %s\n", strerror(errno));
+				LM_ERR("failed to chown PID file: %s\n", strerror(errno));
 				goto error;
 			}
 		}
@@ -385,7 +385,7 @@ int daemonize(char*  name,  int status_w
 				fprintf(pid_stream, "%i\n", (int)pid);
 				fclose(pid_stream);
 				if(chown(pgid_file, pid_uid, pid_gid)<0) {
-					LM_ERR("failed to chwon PGID file: %s\n", strerror(errno));
+					LM_ERR("failed to chown PGID file: %s\n", strerror(errno));
 					goto error;
 				}
 			}
--- a/src/core/fmsg.c
+++ b/src/core/fmsg.c
@@ -30,48 +30,69 @@
 
 #define FAKED_SIP_MSG "OPTIONS sip:you@kamailio.org SIP/2.0\r\nVia: SIP/2.0/UDP 127.0.0.1\r\nFrom: <sip:you@kamailio.org>;tag=123\r\nTo: <sip:you@kamailio.org>\r\nCall-ID: 123\r\nCSeq: 1 OPTIONS\r\nContent-Length: 0\r\n\r\n"
 #define FAKED_SIP_MSG_LEN (sizeof(FAKED_SIP_MSG)-1)
-static char _faked_sip_buf[FAKED_SIP_MSG_LEN+1];
-static struct sip_msg _faked_msg;
+static char _faked_sip_buf[BUF_SIZE];
+static int _faked_sip_buf_init = 0;
+static sip_msg_t _faked_msg;
 static unsigned int _faked_msg_no = 0;
 
-int faked_msg_init(void)
+static unsigned int faked_msg_get_next_id(void)
 {
-	if(_faked_msg_no>0)
-		return 0;
-	/* init faked sip msg */
+	_faked_msg_no += ((_faked_msg_no+1)==0)?2:1;
+	return _faked_msg_no;
+}
+
+static void faked_msg_buf_init(void)
+{
+	if(_faked_sip_buf_init!=0) {
+		return;
+	}
 	memcpy(_faked_sip_buf, FAKED_SIP_MSG, FAKED_SIP_MSG_LEN);
 	_faked_sip_buf[FAKED_SIP_MSG_LEN] = '\0';
+	_faked_sip_buf_init = 1;
+}
+
+static int faked_msg_init_new(sip_msg_t *fmsg)
+{
+	faked_msg_buf_init();
 
-	memset(&_faked_msg, 0, sizeof(struct sip_msg));
+	/* init faked sip msg */
+	memset(fmsg, 0, sizeof(sip_msg_t));
 
-	_faked_msg.buf=_faked_sip_buf;
-	_faked_msg.len=FAKED_SIP_MSG_LEN;
+	fmsg->buf=_faked_sip_buf;
+	fmsg->len=FAKED_SIP_MSG_LEN;
 
-	_faked_msg.set_global_address=default_global_address;
-	_faked_msg.set_global_port=default_global_port;
+	fmsg->set_global_address=default_global_address;
+	fmsg->set_global_port=default_global_port;
 
-	if (parse_msg(_faked_msg.buf, _faked_msg.len, &_faked_msg)!=0)
-	{
-		LM_ERR("parse_msg failed\n");
+	if (parse_msg(fmsg->buf, fmsg->len, fmsg)!=0) {
+		LM_ERR("parse faked msg failed\n");
 		return -1;
 	}
 
-	_faked_msg.rcv.proto = PROTO_UDP;
-	_faked_msg.rcv.src_port = 5060;
-	_faked_msg.rcv.src_ip.u.addr32[0] = 0x7f000001;
-	_faked_msg.rcv.src_ip.af = AF_INET;
-	_faked_msg.rcv.src_ip.len = 4;
-	_faked_msg.rcv.dst_port = 5060;
-	_faked_msg.rcv.dst_ip.u.addr32[0] = 0x7f000001;
-	_faked_msg.rcv.dst_ip.af = AF_INET;
-	_faked_msg.rcv.dst_ip.len = 4;
+	fmsg->rcv.proto = PROTO_UDP;
+	fmsg->rcv.src_port = 5060;
+	fmsg->rcv.src_ip.u.addr32[0] = 0x7f000001;
+	fmsg->rcv.src_ip.af = AF_INET;
+	fmsg->rcv.src_ip.len = 4;
+	fmsg->rcv.dst_port = 5060;
+	fmsg->rcv.dst_ip.u.addr32[0] = 0x7f000001;
+	fmsg->rcv.dst_ip.af = AF_INET;
+	fmsg->rcv.dst_ip.len = 4;
 
 	return 0;
 }
 
-static inline sip_msg_t* faked_msg_next_id(int mode)
+int faked_msg_init(void)
+{
+	if(_faked_msg_no>0) {
+		return 0;
+	}
+	return faked_msg_init_new(&_faked_msg);
+}
+
+static inline sip_msg_t* faked_msg_build_next(int mode)
 {
-	_faked_msg.id = 1 + _faked_msg_no++;
+	_faked_msg.id = faked_msg_get_next_id();
 	_faked_msg.pid = my_pid();
 	memset(&_faked_msg.tval, 0, sizeof(struct timeval));
 	if(mode) clear_branches();
@@ -80,12 +101,12 @@ static inline sip_msg_t* faked_msg_next_
 
 sip_msg_t* faked_msg_next(void)
 {
-	return faked_msg_next_id(0);
+	return faked_msg_build_next(0);
 }
 
 sip_msg_t* faked_msg_next_clear(void)
 {
-	return faked_msg_next_id(1);
+	return faked_msg_build_next(1);
 }
 
 sip_msg_t* faked_msg_get_next(void)
@@ -104,6 +125,19 @@ sip_msg_t* faked_msg_get_next_clear(void
 	return faked_msg_next_clear();
 }
 
+int faked_msg_get_new(sip_msg_t *fmsg)
+{
+	clear_branches();
+	if(faked_msg_init_new(fmsg)<0) {
+		return -1;
+	}
+	fmsg->id = faked_msg_get_next_id();
+	fmsg->pid = my_pid();
+	memset(&fmsg->tval, 0, sizeof(struct timeval));
+
+	return 0;
+}
+
 int faked_msg_match(sip_msg_t *tmsg)
 {
 	return ( tmsg == &_faked_msg ) ? 1 : 0;
--- a/src/core/fmsg.h
+++ b/src/core/fmsg.h
@@ -29,6 +29,7 @@ sip_msg_t* faked_msg_next(void);
 sip_msg_t* faked_msg_get_next(void);
 sip_msg_t* faked_msg_next_clear(void);
 sip_msg_t* faked_msg_get_next_clear(void);
+int faked_msg_get_new(sip_msg_t *fmsg);
 int faked_msg_match(sip_msg_t *tmsg);
 
 #endif
--- a/src/core/forward.h
+++ b/src/core/forward.h
@@ -136,9 +136,18 @@ static inline int msg_send_buffer(struct
 	outb.s = buf;
 	outb.len = len;
 	if(!(flags&1)) {
-		evp.data = (void*)&outb;
-		evp.dst = dst;
-		sr_event_exec(SREV_NET_DATA_OUT, &evp);
+		if(sr_event_enabled(SREV_NET_DATA_OUT)) {
+			outb.s = (char*)pkg_malloc(len + 1);
+			if(outb.s==NULL) {
+				LM_ERR("failed to clone outgoing buffer\n");
+				return -1;
+			}
+			memcpy(outb.s, buf, len);
+			outb.s[len] = '\0';
+			evp.data = (void*)&outb;
+			evp.dst = dst;
+			sr_event_exec(SREV_NET_DATA_OUT, &evp);
+		}
 	}
 
 	if(outb.s==NULL) {
--- a/src/core/kemi.c
+++ b/src/core/kemi.c
@@ -839,6 +839,12 @@ static int sr_kemi_core_is_method_in(sip
 					return SR_KEMI_TRUE;
 				}
 			break;
+			case 'U':
+			case 'u':
+				if(imethod==METHOD_UPDATE) {
+					return SR_KEMI_TRUE;
+				}
+			break;
 			case 'K':
 			case 'k':
 				if(imethod==METHOD_KDMQ) {
@@ -863,6 +869,8 @@ static int sr_kemi_core_is_method_in(sip
 					return SR_KEMI_TRUE;
 				}
 			break;
+			default:
+				LM_WARN("unsupported method flag: %c\n", vmethod->s[i]);
 		}
 	}
 	return SR_KEMI_FALSE;
--- a/src/core/pvapi.c
+++ b/src/core/pvapi.c
@@ -40,8 +40,8 @@
 #include "pvapi.h"
 #include "pvar.h"
 
-#define PV_TABLE_SIZE	64  /*!< pseudo-variables table size */
-#define TR_TABLE_SIZE	32  /*!< transformations table size */
+#define PV_TABLE_SIZE	512  /*!< pseudo-variables table size */
+#define TR_TABLE_SIZE	256  /*!< transformations table size */
 
 
 void tr_destroy(trans_t *t);
--- a/src/core/pvar.h
+++ b/src/core/pvar.h
@@ -241,7 +241,7 @@ typedef struct _pv_cache
 	struct _pv_cache *next;
 } pv_cache_t;
 
-#define PV_CACHE_SIZE	64  /*!< pseudo-variables cache table size */
+#define PV_CACHE_SIZE	512  /*!< pseudo-variables cache table size */
 
 pv_cache_t **pv_cache_get_table(void);
 
--- a/src/core/socket_info.c
+++ b/src/core/socket_info.c
@@ -992,7 +992,6 @@ static int build_iface_list(void)
 		struct rtgenmsg g;
 	} req;
 
-	int seq = 0;
 	int rtn = 0;
 	struct nlmsghdr*  nlp;
 	struct ifaddrmsg *ifi;
--- a/src/core/tcp_main.c
+++ b/src/core/tcp_main.c
@@ -1136,18 +1136,31 @@ again:
 	su2ip_addr(&ip, &my_name);
 find_socket:
 #ifdef USE_TLS
-	if (unlikely(type==PROTO_TLS))
+	if (unlikely(type==PROTO_TLS)) {
 		*res_si=find_si(&ip, 0, PROTO_TLS);
-	else
-#endif
+	} else {
 		*res_si=find_si(&ip, 0, PROTO_TCP);
-	
+	}
+#else
+	*res_si=find_si(&ip, 0, PROTO_TCP);
+#endif
+
 	if (unlikely(*res_si==0)){
 		LM_WARN("%s: could not find corresponding"
 				" listening socket for %s, using default...\n",
 					su2a(server, sizeof(*server)), ip_addr2a(&ip));
+#ifdef USE_TLS
+		if (unlikely(type==PROTO_TLS)) {
+			if (server->s.sa_family==AF_INET) *res_si=sendipv4_tls;
+			else *res_si=sendipv6_tls;
+		} else {
+			if (server->s.sa_family==AF_INET) *res_si=sendipv4_tcp;
+			else *res_si=sendipv6_tcp;
+		}
+#else
 		if (server->s.sa_family==AF_INET) *res_si=sendipv4_tcp;
 		else *res_si=sendipv6_tcp;
+#endif
 	}
 	*res_local_addr=*from;
 	return s;
--- a/src/core/ver_defs.h
+++ b/src/core/ver_defs.h
@@ -336,6 +336,12 @@
 #define USE_DST_BLACKLIST_STATS_STR ""
 #endif
 
+#ifdef KSR_PTHREAD_MUTEX_SHARED
+#define KSR_PTHREAD_MUTEX_SHARED_STR ", TLS_PTHREAD_MUTEX_SHARED"
+#else
+#define KSR_PTHREAD_MUTEX_SHARED_STR ""
+#endif
+
 #define SER_COMPILE_FLAGS \
 	STATS_STR EXTRA_DEBUG_STR USE_TCP_STR USE_TLS_STR \
 	USE_SCTP_STR CORE_TLS_STR TLS_HOOKS_STR USE_RAW_SOCKS_STR \
@@ -350,7 +356,8 @@
 	USE_SYSV_SEM_STR USE_COMP_STR USE_DNS_CACHE_STR USE_DNS_FAILOVER_STR \
 	DNS_WATCHDOG_SUPPORT_STR USE_NAPTR_STR USE_DST_BLACKLIST_STR \
 	HAVE_RESOLV_RES_STR SYSLOG_CALLBACK_SUPPORT_STR MYSQL_FAKE_NULL_STR \
-	USE_DST_BLACKLIST_STATS_STR USE_DNS_CACHE_STATS_STR
+	USE_DST_BLACKLIST_STATS_STR USE_DNS_CACHE_STATS_STR \
+	KSR_PTHREAD_MUTEX_SHARED_STR
 
 
 #endif
--- a/src/lib/srdb1/db_id.c
+++ b/src/lib/srdb1/db_id.c
@@ -100,26 +100,28 @@ static int parse_db_url(struct db_id* id
 		ST_USER_HOST,  /* Username or hostname */
 		ST_PASS_PORT,  /* Password or port part */
 		ST_HOST,       /* Hostname part */
+		ST_HOST6,      /* Hostname part IPv6 */
 		ST_PORT,       /* Port part */
 		ST_DB          /* Database part */
 	};
 
 	enum state st;
-	unsigned int len, i, j, a;
+	unsigned int len, i, j, a, foundanother, ipv6_flag=0;
 	const char* begin;
 	char* prev_token;
 
+	foundanother = 0;
 	prev_token = 0;
 
 	if (!id || !url || !url->s) {
 		goto err;
 	}
-	
+
 	len = url->len;
 	if (len < SHORTEST_DB_URL_LEN) {
 		goto err;
 	}
-	
+
 	/* Initialize all attributes to 0 */
 	memset(id, 0, sizeof(struct db_id));
 	st = ST_SCHEME;
@@ -153,7 +155,7 @@ static int parse_db_url(struct db_id* id
 				st = ST_USER_HOST;
 				begin = url->s + i + 1;
 				break;
-				
+
 			default:
 				goto err;
 			}
@@ -162,6 +164,20 @@ static int parse_db_url(struct db_id* id
 		case ST_USER_HOST:
 			switch(url->s[i]) {
 			case '@':
+				/* look for another @ to cope with username@domain user id */
+				if (foundanother == 0) {
+					for (j = i + 1; j < url->len; j++) {
+						if (url->s[j] == '@') {
+							foundanother = 1;
+							break;
+						}
+					}
+					if (foundanother == 1) {
+						/* keep the current @ in the username */
+						st = ST_USER_HOST;
+						break;
+					}
+				}
 				st = ST_HOST;
 				if (dupl_string(&id->username, begin, url->s + i) < 0) goto err;
 				begin = url->s + i + 1;
@@ -173,6 +189,11 @@ static int parse_db_url(struct db_id* id
 				begin = url->s + i + 1;
 				break;
 
+			case '[':
+				st = ST_HOST6;
+				begin = url->s + i + 1;
+				break;
+
 			case '/':
 				if (dupl_string(&id->host, begin, url->s + i) < 0) goto err;
 				if (dupl_string_name(&id->database, url->s + i + 1, url->s + len) < 0) goto err;
@@ -209,19 +230,33 @@ static int parse_db_url(struct db_id* id
 
 		case ST_HOST:
 			switch(url->s[i]) {
+			case '[':
+				st = ST_HOST6;
+				begin = url->s + i + 1;
+				break;
+
 			case ':':
 				st = ST_PORT;
-				if (dupl_string(&id->host, begin, url->s + i) < 0) goto err;
+				if (dupl_string(&id->host, begin, url->s + i - ipv6_flag) < 0) goto err;
 				begin = url->s + i + 1;
 				break;
 
 			case '/':
-				if (dupl_string(&id->host, begin, url->s + i) < 0) goto err;
+				if (dupl_string(&id->host, begin, url->s + i - ipv6_flag) < 0) goto err;
 				if (dupl_string_name(&id->database, url->s + i + 1, url->s + len) < 0) goto err;
 				return 0;
 			}
 			break;
 
+		case ST_HOST6:
+			switch(url->s[i]) {
+			case ']':
+				ipv6_flag = 1;
+				st = ST_HOST;
+				break;
+			}
+			break;
+
 		case ST_PORT:
 			switch(url->s[i]) {
 			case '/':
@@ -230,7 +265,7 @@ static int parse_db_url(struct db_id* id
 				return 0;
 			}
 			break;
-			
+
 		case ST_DB:
 			break;
 		}
--- a/src/main.c
+++ b/src/main.c
@@ -30,6 +30,12 @@
  * sip router core part.
  */
 
+#ifdef KSR_PTHREAD_MUTEX_SHARED
+#define _GNU_SOURCE
+#include <pthread.h>
+#include <dlfcn.h>
+#endif
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
@@ -1563,12 +1569,20 @@ int main_loop(void)
 				/* get first ipv4/ipv6 socket*/
 				if ((si->address.af==AF_INET)&&
 						((sendipv4_tls==0) ||
-							(sendipv4_tls->flags&(SI_IS_LO|SI_IS_MCAST))))
+						 (sendipv4_tls->flags&(SI_IS_LO|SI_IS_MCAST)))) {
 					sendipv4_tls=si;
+					if(sendipv4_tcp==0) {
+						sendipv4_tcp=si;
+					}
+				}
 				if( ((sendipv6_tls==0) ||
 							(sendipv6_tls->flags&(SI_IS_LO|SI_IS_MCAST))) &&
-						(si->address.af==AF_INET6))
+						(si->address.af==AF_INET6)) {
 					sendipv6_tls=si;
+					if(sendipv6_tcp==0) {
+						sendipv6_tcp=si;
+					}
+				}
 			}
 		}
 #endif /* USE_TLS */
@@ -2716,3 +2730,72 @@ error:
 	}
 	return -1;
 }
+
+
+#ifdef KSR_PTHREAD_MUTEX_SHARED
+
+/**
+ * code to set PTHREAD_PROCESS_SHARED attribute for phtread mutex to cope
+ * with libssl 1.1+ thread-only mutex initialization
+ */
+
+#define SYMBOL_EXPORT __attribute__((visibility("default")))
+
+int SYMBOL_EXPORT pthread_mutex_init (pthread_mutex_t *__mutex,
+		const pthread_mutexattr_t *__mutexattr)
+{
+	static int (*real_pthread_mutex_init)(pthread_mutex_t *__mutex,
+			const pthread_mutexattr_t *__mutexattr) = 0;
+	pthread_mutexattr_t attr;
+	int ret;
+
+	if (!real_pthread_mutex_init) {
+		real_pthread_mutex_init = dlsym(RTLD_NEXT, "pthread_mutex_init");
+		if (!real_pthread_mutex_init) {
+			return -1;
+		}
+	}
+
+	if (__mutexattr) {
+		pthread_mutexattr_t attr = *__mutexattr;
+		pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
+		return real_pthread_mutex_init(__mutex, &attr);
+	}
+
+	pthread_mutexattr_init(&attr);
+	pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
+	ret = real_pthread_mutex_init(__mutex, &attr);
+	pthread_mutexattr_destroy(&attr);
+
+	return ret;
+}
+
+int SYMBOL_EXPORT pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
+				const pthread_rwlockattr_t *__restrict __attr)
+{
+	static int (*real_pthread_rwlock_init)(pthread_rwlock_t *__restrict __rwlock,
+				const pthread_rwlockattr_t *__restrict __attr) = 0;
+	pthread_rwlockattr_t attr;
+	int ret;
+
+	if (!real_pthread_rwlock_init) {
+		real_pthread_rwlock_init = dlsym(RTLD_NEXT, "pthread_rwlock_init");
+		if (!real_pthread_rwlock_init) {
+			return -1;
+		}
+	}
+
+	if (__attr) {
+		pthread_rwlockattr_t attr = *__attr;
+		pthread_rwlockattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
+		return real_pthread_rwlock_init(__rwlock, &attr);
+	}
+
+	pthread_rwlockattr_init(&attr);
+	pthread_rwlockattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
+	ret = real_pthread_rwlock_init(__rwlock, &attr);
+	pthread_rwlockattr_destroy(&attr);
+
+	return ret;
+}
+#endif
--- a/src/modules/acc/README
+++ b/src/modules/acc/README
@@ -22,8 +22,6 @@ Bogdan-Andrei Iancu
    Voice Sistem SRL
    <bogdan@voice-system.ro>
 
-Edited by
-
 Sven Knoblich
 
    1&1 Internet AG
@@ -107,29 +105,24 @@ Sven Knoblich
               6.26. acc_time_column (string)
               6.27. db_extra (string)
               6.28. db_insert_mode (integer)
-              6.29. diameter_flag (integer)
-              6.30. diameter_missed_flag (integer)
-              6.31. diameter_client_host (string)
-              6.32. diameter_client_port (int)
-              6.33. diameter_extra (string)
-              6.34. cdr_enable (integer)
-              6.35. cdr_expired_dlg_enable (integer)
-              6.36. cdr_start_on_confirmed (integer)
-              6.37. cdr_facility (integer)
-              6.38. cdr_extra (string)
-              6.39. cdr_extra_nullable (integer)
-              6.40. cdr_start_id (string)
-              6.41. cdr_end_id (string)
-              6.42. cdr_duration_id (string)
-              6.43. cdr_log_enable (int)
-              6.44. cdrs_table (str)
-              6.45. time_mode (int)
-              6.46. time_attr (str)
-              6.47. time_exten (str)
-              6.48. time_format (str)
-              6.49. reason_from_hf (int)
-              6.50. clone_msg (int)
-              6.51. cdr_on_failed (int)
+              6.29. cdr_enable (integer)
+              6.30. cdr_expired_dlg_enable (integer)
+              6.31. cdr_start_on_confirmed (integer)
+              6.32. cdr_facility (integer)
+              6.33. cdr_extra (string)
+              6.34. cdr_extra_nullable (integer)
+              6.35. cdr_start_id (string)
+              6.36. cdr_end_id (string)
+              6.37. cdr_duration_id (string)
+              6.38. cdr_log_enable (int)
+              6.39. cdrs_table (str)
+              6.40. time_mode (int)
+              6.41. time_attr (str)
+              6.42. time_exten (str)
+              6.43. time_format (str)
+              6.44. reason_from_hf (int)
+              6.45. clone_msg (int)
+              6.46. cdr_on_failed (int)
 
         7. Functions
 
@@ -170,33 +163,28 @@ Sven Knoblich
    1.26. acc_time_column example
    1.27. db_extra example
    1.28. db_insert_mode example
-   1.29. diameter_flag example
-   1.30. diameter_missed_flag example
-   1.31. diameter_client_host example
-   1.32. diameter_client_host example
-   1.33. diameter_extra example
-   1.34. cdr_enable example
-   1.35. cdr_expired_dlg_enable example
-   1.36. cdr_start_on_confirmed example
-   1.37. cdr_facility example
-   1.38. cdr_extra example
-   1.39. cdr_extra_nullable example
-   1.40. cdr_start_id example
-   1.41. cdr_end_id example
-   1.42. cdr_duration_id example
-   1.43. cdr_log_enable example
-   1.44. cdrs_table example
-   1.45. time_mode example
-   1.46. time_attr example
-   1.47. time_exten example
-   1.48. time_format example
-   1.49. reason_from_hf
-   1.50. clone_msg
-   1.51. cdr_on_failed
-   1.52. acc_log_request usage
-   1.53. acc_db_request usage
-   1.54. acc_db_request usage
-   1.55. acc_diam_request usage
+   1.29. cdr_enable example
+   1.30. cdr_expired_dlg_enable example
+   1.31. cdr_start_on_confirmed example
+   1.32. cdr_facility example
+   1.33. cdr_extra example
+   1.34. cdr_extra_nullable example
+   1.35. cdr_start_id example
+   1.36. cdr_end_id example
+   1.37. cdr_duration_id example
+   1.38. cdr_log_enable example
+   1.39. cdrs_table example
+   1.40. time_mode example
+   1.41. time_attr example
+   1.42. time_exten example
+   1.43. time_format example
+   1.44. reason_from_hf
+   1.45. clone_msg
+   1.46. cdr_on_failed
+   1.47. acc_log_request usage
+   1.48. acc_db_request usage
+   1.49. acc_db_request usage
+   1.50. acc_diam_request usage
 
 Chapter 1. Admin Guide
 
@@ -269,29 +257,24 @@ Chapter 1. Admin Guide
         6.26. acc_time_column (string)
         6.27. db_extra (string)
         6.28. db_insert_mode (integer)
-        6.29. diameter_flag (integer)
-        6.30. diameter_missed_flag (integer)
-        6.31. diameter_client_host (string)
-        6.32. diameter_client_port (int)
-        6.33. diameter_extra (string)
-        6.34. cdr_enable (integer)
-        6.35. cdr_expired_dlg_enable (integer)
-        6.36. cdr_start_on_confirmed (integer)
-        6.37. cdr_facility (integer)
-        6.38. cdr_extra (string)
-        6.39. cdr_extra_nullable (integer)
-        6.40. cdr_start_id (string)
-        6.41. cdr_end_id (string)
-        6.42. cdr_duration_id (string)
-        6.43. cdr_log_enable (int)
-        6.44. cdrs_table (str)
-        6.45. time_mode (int)
-        6.46. time_attr (str)
-        6.47. time_exten (str)
-        6.48. time_format (str)
-        6.49. reason_from_hf (int)
-        6.50. clone_msg (int)
-        6.51. cdr_on_failed (int)
+        6.29. cdr_enable (integer)
+        6.30. cdr_expired_dlg_enable (integer)
+        6.31. cdr_start_on_confirmed (integer)
+        6.32. cdr_facility (integer)
+        6.33. cdr_extra (string)
+        6.34. cdr_extra_nullable (integer)
+        6.35. cdr_start_id (string)
+        6.36. cdr_end_id (string)
+        6.37. cdr_duration_id (string)
+        6.38. cdr_log_enable (int)
+        6.39. cdrs_table (str)
+        6.40. time_mode (int)
+        6.41. time_attr (str)
+        6.42. time_exten (str)
+        6.43. time_format (str)
+        6.44. reason_from_hf (int)
+        6.45. clone_msg (int)
+        6.46. cdr_on_failed (int)
 
    7. Functions
 
@@ -305,14 +288,13 @@ Chapter 1. Admin Guide
    1.1. General Example
 
    ACC module is used to account transactions information to different
-   backends like syslog and SQL. With the separate module, radius support
-   is enabled.
+   backends like syslog and SQL. With the separate module “acc_radius”
+   support for radius is enabled.
 
-   There is some very early support of the Diameter protocol in the code
-   which is no longer included by default and will be deleted in coming
-   releases. This support is not up to date with the current Diameter
-   protocols and is disabled. If you need Diameter support, please use the
-   ims_charging module.
+   There is some very early support of the Diameter protocol in the
+   “acc_diameter” module which will be deleted in coming releases. This
+   support is not up to date with the current Diameter protocols. If you
+   need Diameter support, please use the ims_charging module.
 
    To account a transaction and to choose which set of backends to be
    used, the script writer just has to set some flags (see the module
@@ -354,19 +336,10 @@ Chapter 1. Admin Guide
        status (including media status and PSTN status in case of the
        gateway). However, CDR-base logging has the option to log existing
        information from expired dialogs (the dlg_vars in cdr_extra) Please
-       see cdr_expired_dlg_enable parameter - Section 6.35,
+       see cdr_expired_dlg_enable parameter - Section 6.30,
        “cdr_expired_dlg_enable (integer)”.
 
-   The SQL backend support is compiled in the module. For DIAMETER you
-   need to enable it by recompiling the module with properly set defines:
-   uncomment the DDIAM_ACC lines in modules/acc/Makefile.
-
-   NOTE: diameter support was developed for DISC (DIameter Server Client
-   project at http://developer.berlios.de/projects/disc/). This project
-   seems to be no longer maintained and DIAMETER specifications were
-   updated in the meantime. Thus, the DIAMETER part in the module is
-   obsolete and needs rework to be usable with opendiameter or other
-   DIAMETER servers.
+   The SQL backend support is compiled in the module.
 
 1.1. General Example
 
@@ -550,7 +523,7 @@ Note
    Sometimes, dialogs expire because the UA has a problem and a final
    message is never transmitted. You can toggle on/off the generation of
    CDR-based logging in such cases with only the dlg_vars showing by using
-   the cdr_expired_dlg_enable parameter - Section 6.35,
+   the cdr_expired_dlg_enable parameter - Section 6.30,
    “cdr_expired_dlg_enable (integer)”. Default behavior is not logging.
 
 4.2. CDR Extra
@@ -565,7 +538,7 @@ Note
      * cdr_extra = cdr_extra_definition (';'cdr_extra_definition)*
      * cdr_extra_definition = cdr_log_name '=' pseudo_variable
 
-   See also Section 6.38, “cdr_extra (string)”.
+   See also Section 6.33, “cdr_extra (string)”.
 
    The full list of supported pseudo-variables in Sip-Router is available
    at: http://sip-router.org/wiki/cookbooks/pseudo-variables/devel
@@ -678,29 +651,24 @@ $dlg_var(callee) = $avp(callee); #callee
    6.26. acc_time_column (string)
    6.27. db_extra (string)
    6.28. db_insert_mode (integer)
-   6.29. diameter_flag (integer)
-   6.30. diameter_missed_flag (integer)
-   6.31. diameter_client_host (string)
-   6.32. diameter_client_port (int)
-   6.33. diameter_extra (string)
-   6.34. cdr_enable (integer)
-   6.35. cdr_expired_dlg_enable (integer)
-   6.36. cdr_start_on_confirmed (integer)
-   6.37. cdr_facility (integer)
-   6.38. cdr_extra (string)
-   6.39. cdr_extra_nullable (integer)
-   6.40. cdr_start_id (string)
-   6.41. cdr_end_id (string)
-   6.42. cdr_duration_id (string)
-   6.43. cdr_log_enable (int)
-   6.44. cdrs_table (str)
-   6.45. time_mode (int)
-   6.46. time_attr (str)
-   6.47. time_exten (str)
-   6.48. time_format (str)
-   6.49. reason_from_hf (int)
-   6.50. clone_msg (int)
-   6.51. cdr_on_failed (int)
+   6.29. cdr_enable (integer)
+   6.30. cdr_expired_dlg_enable (integer)
+   6.31. cdr_start_on_confirmed (integer)
+   6.32. cdr_facility (integer)
+   6.33. cdr_extra (string)
+   6.34. cdr_extra_nullable (integer)
+   6.35. cdr_start_id (string)
+   6.36. cdr_end_id (string)
+   6.37. cdr_duration_id (string)
+   6.38. cdr_log_enable (int)
+   6.39. cdrs_table (str)
+   6.40. time_mode (int)
+   6.41. time_attr (str)
+   6.42. time_exten (str)
+   6.43. time_format (str)
+   6.44. reason_from_hf (int)
+   6.45. clone_msg (int)
+   6.46. cdr_on_failed (int)
 
 6.1. early_media (integer)
 
@@ -716,7 +684,8 @@ modparam("acc", "early_media", 1)
 6.2. failed_transaction_flag (integer)
 
    Per transaction flag which says if the transaction should be accounted
-   also in case of failure (status>=300).
+   also in case of failure (SIP status code >= 300). This flag triggers
+   accouting when the whole transaction fails (on the server side).
 
    Default value is not-set (no flag).
 
@@ -849,6 +818,13 @@ modparam("acc", "log_flag", 2)
 6.11. log_missed_flag (integer)
 
    Request flag which needs to be set to account missed calls via syslog.
+   This can be used to e.g. account failures during the call setup phase
+   from the callee (client) side, for example if you do forking to several
+   destinations.
+
+   Keep in mind that this flag is reset after branch completion. Therefore
+   it is necessary to set it again e.g. in a failure_route if you do
+   serial forking and want to log all attempts.
 
    Default value is not-set (no flag).
 
@@ -907,8 +883,14 @@ modparam("acc", "db_flag", 2)
 
 6.16. db_missed_flag (integer)
 
-   Request flag which needs to be set to account missed calls -- database
-   specific.
+   Request flag which needs to be set to account missed calls via
+   database. This can be used to e.g. account failures during the call
+   setup phase from the callee (client) side, for example if you do
+   forking to several destinations.
+
+   Keep in mind that this flag is reset after branch completion. Therefore
+   it is necessary to set it again e.g. in a failure_route if you do
+   serial forking and want to log all attempts.
 
    Default value is not-set (no flag).
 
@@ -1066,89 +1048,29 @@ modparam("acc", "db_extra", "ct=$hdr(Con
 modparam("acc", "db_insert_mode", 1)
 ...
 
-6.29. diameter_flag (integer)
-
-   Request flag which needs to be set to account a transaction -- DIAMETER
-   specific.
-
-   Default value is not-set (no flag).
-
-   Example 1.29. diameter_flag example
-...
-modparam("acc", "diameter_flag", 2)
-...
-
-6.30. diameter_missed_flag (integer)
-
-   Request flag which needs to be set to account missed calls -- DIAMETER
-   specific.
-
-   Default value is not-set (no flag).
-
-   Example 1.30. diameter_missed_flag example
-...
-modparam("acc", "diameter_missed_flag", 3)
-...
-
-6.31. diameter_client_host (string)
-
-   Hostname of the machine where the DIAMETER Client is running --
-   DIAMETER specific.
-
-   Default value is “localhost”.
-
-   Example 1.31. diameter_client_host example
-...
-modparam("acc", "diameter_client_host", "3a_server.net")
-...
-
-6.32. diameter_client_port (int)
-
-   Port number where the Diameter Client is listening -- DIAMETER
-   specific.
-
-   Default value is 3000.
-
-   Example 1.32. diameter_client_host example
-...
-modparam("acc", "diameter_client_port", 3000)
-...
-
-6.33. diameter_extra (string)
-
-   Extra values to be logged via DIAMETER - DIAMETER specific. See section
-   Section 2, “Extra accounting” for more details.
-
-   Default value is NULL.
-
-   Example 1.33. diameter_extra example
-...
-modparam("acc", "diameter_extra", "7846=$hdr(Content-type);7847=$avp(s:email)")
-...
-
-6.34. cdr_enable (integer)
+6.29. cdr_enable (integer)
 
    Should CDR-based logging be enabled?
 
    0 - off (default). 1 - on.
 
-   Example 1.34. cdr_enable example
+   Example 1.29. cdr_enable example
 ...
 modparam("acc", "cdr_enable", 1)
 ...
 
-6.35. cdr_expired_dlg_enable (integer)
+6.30. cdr_expired_dlg_enable (integer)
 
    Should CDR-based logging be enabled in case of expired dialogs?
 
    0 - off (default). 1 - on.
 
-   Example 1.35. cdr_expired_dlg_enable example
+   Example 1.30. cdr_expired_dlg_enable example
 ...
 modparam("acc", "cdr_expired_dlg_enable", 1)
 ...
 
-6.36. cdr_start_on_confirmed (integer)
+6.31. cdr_start_on_confirmed (integer)
 
    Should the start time be taken from the time when the dialog is
    created, or when the dialog is confirmed?
@@ -1156,36 +1078,36 @@ modparam("acc", "cdr_expired_dlg_enable"
    0 - use time of dialog creation (default). 1 - use time of dialog
    confirmation.
 
-   Example 1.36. cdr_start_on_confirmed example
+   Example 1.31. cdr_start_on_confirmed example
 ...
 modparam("acc", "cdr_start_on_confirmed", 1)
 ...
 
-6.37. cdr_facility (integer)
+6.32. cdr_facility (integer)
 
    Log facility to which CDR messages are issued to syslog. This allows to
    easily seperate CDR-specific logging from the other log messages.
 
    Default value is LOG_DAEMON.
 
-   Example 1.37. cdr_facility example
+   Example 1.32. cdr_facility example
 ...
 modparam("acc", "cdr_facility", "LOG_DAEMON")
 ...
 
-6.38. cdr_extra (string)
+6.33. cdr_extra (string)
 
    Set of pseudo-variables defining custom CDR fields. See Section 4.2,
    “CDR Extra” for more details.
 
    Default value is NULL.
 
-   Example 1.38. cdr_extra example
+   Example 1.33. cdr_extra example
 ...
 modparam("acc", "cdr_extra", "c1=$dlg_var(caller);c2=$dlg_var(callee)"
 ...
 
-6.39. cdr_extra_nullable (integer)
+6.34. cdr_extra_nullable (integer)
 
    Should custom CDR fields be saved as NULL?
 
@@ -1196,67 +1118,67 @@ modparam("acc", "cdr_extra", "c1=$dlg_va
 
    Default value is 0.
 
-   Example 1.39. cdr_extra_nullable example
+   Example 1.34. cdr_extra_nullable example
 ...
 modparam("acc", "cdr_extra_nullable", 1)
 ...
 
-6.40. cdr_start_id (string)
+6.35. cdr_start_id (string)
 
    Modifying the id which is used to store the start time.
 
    Default value is 'start_time'
 
-   Example 1.40. cdr_start_id example
+   Example 1.35. cdr_start_id example
 ...
 modparam("acc", "cdr_start_id", "start")
 ...
 
-6.41. cdr_end_id (string)
+6.36. cdr_end_id (string)
 
    Modifying the id which is used to store the end time.
 
    Default value is 'end_time'
 
-   Example 1.41. cdr_end_id example
+   Example 1.36. cdr_end_id example
 ...
 modparam("acc", "cdr_end_id", "end")
 ...
 
-6.42. cdr_duration_id (string)
+6.37. cdr_duration_id (string)
 
    Modify the id which is used to store the duration.
 
    Default value is 'duration'
 
-   Example 1.42. cdr_duration_id example
+   Example 1.37. cdr_duration_id example
 ...
 modparam("acc", "cdr_duration_id", "d")
 ...
 
-6.43. cdr_log_enable (int)
+6.38. cdr_log_enable (int)
 
    Control if CDR-based accounting should be written to syslog.
 
    0 - off. 1 - on (default).
 
-   Example 1.43. cdr_log_enable example
+   Example 1.38. cdr_log_enable example
 ...
 modparam("acc", "cdr_log_enable", 0)
 ...
 
-6.44. cdrs_table (str)
+6.39. cdrs_table (str)
 
    Name of db table to store dialog-based CDRs.
 
    Default value is "" (no db storage for dialog-based CDRs).
 
-   Example 1.44. cdrs_table example
+   Example 1.39. cdrs_table example
 ...
 modparam("acc", "cdrs_table", "acc_cdrs")
 ...
 
-6.45. time_mode (int)
+6.40. time_mode (int)
 
    Store additional value related to the time of event.
 
@@ -1270,12 +1192,12 @@ modparam("acc", "cdrs_table", "acc_cdrs"
      * 4 - save formatted time according to time_format parameter, using
        the output of gmtime(). Used for cdr entries too.
 
-   Example 1.45. time_mode example
+   Example 1.40. time_mode example
 ...
 modparam("acc", "time_mode", 1)
 ...
 
-6.46. time_attr (str)
+6.41. time_attr (str)
 
    Name of the syslog attribute or database column where to store
    additional value related to the time of event.
@@ -1291,35 +1213,35 @@ modparam("acc", "time_mode", 1)
    value is already unix timestamp, but in db accounting time value is
    datetime and requires a function to get the timestamp.
 
-   Example 1.46. time_attr example
+   Example 1.41. time_attr example
 ...
 modparam("acc", "time_attr", "seconds")
 ...
 
-6.47. time_exten (str)
+6.42. time_exten (str)
 
    Name of the syslog attribute or database column where to store extended
    value related to the time of event.
 
    It is used now only for time_mode=1 and database column has to be int:
 
-   Example 1.47. time_exten example
+   Example 1.42. time_exten example
 ...
 modparam("acc", "time_exten", "microsecs")
 ...
 
-6.48. time_format (str)
+6.43. time_format (str)
 
    Specify the format to print the time for time_mode 3 or 4.
 
    Default value is %Y-%m-%d %H:%M:%S".
 
-   Example 1.48. time_format example
+   Example 1.43. time_format example
 ...
 modparam("acc", "time_format", "%Y/%m/%d %H:%M:%S")
 ...
 
-6.49. reason_from_hf (int)
+6.44. reason_from_hf (int)
 
    Tells where to take sip_reason from. If value is 0, sip_reason is taken
    from status line. Otherwise, sip_reason is taken from Reason header
@@ -1327,12 +1249,12 @@ modparam("acc", "time_format", "%Y/%m/%d
 
    Default value is 0.
 
-   Example 1.49. reason_from_hf
+   Example 1.44. reason_from_hf
 ...
 modparam("acc", "reason_from_hf", 1)
 ...
 
-6.50. clone_msg (int)
+6.45. clone_msg (int)
 
    If set to 1, request structure from transaction is cloned temporarily
    in the callback to get acc attributes. It is required if you account
@@ -1343,12 +1265,12 @@ modparam("acc", "reason_from_hf", 1)
 
    Default value is 1.
 
-   Example 1.50. clone_msg
+   Example 1.45. clone_msg
 ...
 modparam("acc", "clone_msg", 0)
 ...
 
-6.51. cdr_on_failed (int)
+6.46. cdr_on_failed (int)
 
    If set to 1, the module stores the CDR for a failed dialog (calls not
    answered). If set to 0, those records are not stored, only those for
@@ -1356,7 +1278,7 @@ modparam("acc", "clone_msg", 0)
 
    Default value is 1.
 
-   Example 1.51. cdr_on_failed
+   Example 1.46. cdr_on_failed
 ...
 modparam("acc", "cdr_on_failed", 0)
 ...
@@ -1381,7 +1303,7 @@ modparam("acc", "cdr_on_failed", 0)
 
    This function can be used from ANY_ROUTE.
 
-   Example 1.52. acc_log_request usage
+   Example 1.47. acc_log_request usage
 ...
 acc_log_request("Some comment");
 $var(code) = 404;
@@ -1403,7 +1325,7 @@ acc_log_request("$var(code) Error: $avp(
 
    This function can be used from ANY_ROUTE.
 
-   Example 1.53. acc_db_request usage
+   Example 1.48. acc_db_request usage
 ...
 acc_db_request("Some comment", "SomeTable");
 acc_db_request("Some comment", "acc_$time(year)_$time(mon)");
@@ -1427,7 +1349,7 @@ acc_db_request("$var(code) Error: $avp(r
 
    This function can be used from ANY_ROUTE.
 
-   Example 1.54. acc_db_request usage
+   Example 1.49. acc_db_request usage
 ...
 acc_request("100 Received", "acc");
 acc_request("100 Received", "acc_$time(year)_$time(mon)");
@@ -1445,7 +1367,7 @@ acc_db_request("$var(code) $avp(reason)"
 
    This function can be used from ANY_ROUTE.
 
-   Example 1.55. acc_diam_request usage
+   Example 1.50. acc_diam_request usage
 ...
 acc_diam_request("Some comment");
 acc_diam_request("$var(code) Error: $avp(reason)");
@@ -1464,52 +1386,52 @@ Chapter 2. Frequently Asked Questions
 
    2.1.
 
-       What happened with old log_fmt parameter
+   What happened with old log_fmt parameter
 
-       The parameter became obsolete with the restructure of the data logged
-       by ACC module (refer to the Overview chapter). For similar behaviour
-       you can use the extra accounting (see the corresponding chapter).
+   The parameter became obsolete with the restructure of the data logged
+   by ACC module (refer to the Overview chapter). For similar behaviour
+   you can use the extra accounting (see the corresponding chapter).
 
    2.2.
 
-       What happened with old multi_leg_enabled parameter
+   What happened with old multi_leg_enabled parameter
 
-       The parameter became obsolete by the addition of the new multi_leg_info
-       parameter. The multi-leg accounting is automatically enabled when
-       multi_leg_info is defined.
+   The parameter became obsolete by the addition of the new multi_leg_info
+   parameter. The multi-leg accounting is automatically enabled when
+   multi_leg_info is defined.
 
    2.3.
 
-       What happened with old src_leg_avp_id and dst_leg_avp_id parameters
+   What happened with old src_leg_avp_id and dst_leg_avp_id parameters
 
-       The parameter was replaced by the more generic new parameter
-       multi_leg_info. This allows logging (per-leg) of more information than
-       just dst and src.
+   The parameter was replaced by the more generic new parameter
+   multi_leg_info. This allows logging (per-leg) of more information than
+   just dst and src.
 
    2.4.
 
-       Where can I find more about Kamailio?
+   Where can I find more about Kamailio?
 
-       Take a look at https://www.kamailio.org/.
+   Take a look at https://www.kamailio.org/.
 
    2.5.
 
-       Where can I post a question about this module?
+   Where can I post a question about this module?
 
-       First at all check if your question was already answered on one of our
-       mailing lists:
-         * User Mailing List -
-           https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-users
-         * Developer Mailing List -
-           https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-dev
-
-       E-mails regarding any stable Kamailio release should be sent to
-       <sr-users@lists.kamailio.org> and e-mails regarding development
-       versions should be sent to <sr-dev@lists.kamailio.org>.
+   First at all check if your question was already answered on one of our
+   mailing lists:
+     * User Mailing List -
+       https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-users
+     * Developer Mailing List -
+       https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-dev
+
+   E-mails regarding any stable Kamailio release should be sent to
+   <sr-users@lists.kamailio.org> and e-mails regarding development
+   versions should be sent to <sr-dev@lists.kamailio.org>.
 
    2.6.
 
-       How can I report a bug?
+   How can I report a bug?
 
-       Please follow the guidelines provided at:
-       https://github.com/kamailio/kamailio/issues.
+   Please follow the guidelines provided at:
+   https://github.com/kamailio/kamailio/issues.
--- a/src/modules/acc/doc/acc_admin.xml
+++ b/src/modules/acc/doc/acc_admin.xml
@@ -18,15 +18,15 @@
 	<title>Overview</title>
 	<para>
 		ACC module is used to account transactions information to different
-		backends like syslog and <abbrev>SQL</abbrev>. With the separate module,
-		<acronym>radius</acronym> support is enabled.
+		backends like syslog and <abbrev>SQL</abbrev>. With the separate module
+		<quote>acc_radius</quote> support for <acronym>radius</acronym> is enabled.
 	</para>
 	<para>
-		There is some very early support of
-		the <acronym>Diameter</acronym> protocol in the code which is no longer included
-		by default and will be deleted in coming releases.
-		This support is not up to date with the current Diameter protocols and
-		is disabled. If you need Diameter support, please use the <acronym>ims_charging</acronym> module.
+		There is some very early support of the <acronym>Diameter</acronym>
+		protocol in the <quote>acc_diameter</quote> module which will be deleted
+		in coming releases. This support is not up to date with the current
+		Diameter protocols. If you need Diameter support, please use the
+		<acronym>ims_charging</acronym> module.
 	</para>
 	<para>
 		To account a transaction and to choose which set of backends to be
@@ -104,18 +104,8 @@
 		</itemizedlist>
 	</para>
 	<para>
-		The SQL backend support is compiled in the module. For
-		DIAMETER you need to enable it by recompiling the module with properly
-		set defines: uncomment the DDIAM_ACC lines in
-		modules/acc/Makefile.
+		The SQL backend support is compiled in the module.
         </para>
-	<para>
-		NOTE: diameter support was developed for DISC (DIameter Server Client
-		project at http://developer.berlios.de/projects/disc/). This project
-		seems to be no longer maintained and DIAMETER specifications were updated
-		in the meantime. Thus, the DIAMETER part in the module is obsolete and
-		needs rework to be usable with opendiameter or other DIAMETER servers.
-	</para>
 	<section>
 		<title>General Example</title>
 		<programlisting format="linespecific">
@@ -499,7 +489,9 @@ modparam("acc", "early_media", 1)
 		<title><varname>failed_transaction_flag</varname> (integer)</title>
 		<para>
 		Per transaction flag which says if the transaction should be
-		accounted also in case of failure (status>=300).
+		accounted also in case of failure (SIP status code >= 300).
+		This flag triggers accouting when the whole transaction fails
+		(on the server side).
 		</para>
 		<para>
 		Default value is not-set (no flag).
@@ -688,6 +680,14 @@ modparam("acc", "log_flag", 2)
 		<title><varname>log_missed_flag</varname> (integer)</title>
 		<para>
 		Request flag which needs to be set to account missed calls via syslog.
+		This can be used to e.g. account failures during the call setup phase
+		from the callee (client) side, for example if you do forking to several
+		destinations.
+		</para>
+		<para>
+		Keep in mind that this flag is reset after branch completion. Therefore
+		it is necessary to set it again e.g. in a failure_route if you do serial
+		forking and want to log all attempts.
 		</para>
 		<para>
 		Default value is not-set (no flag).
@@ -777,8 +777,15 @@ modparam("acc", "db_flag", 2)
 	<section id="acc.p.db_missed_flag">
 		<title><varname>db_missed_flag</varname> (integer)</title>
 		<para>
-		Request flag which needs to be set to account missed
-		calls -- database specific.
+		Request flag which needs to be set to account missed calls via database.
+		This can be used to e.g. account failures during the call setup phase
+		from the callee (client) side, for example if you do forking to several
+		destinations.
+		</para>
+		<para>
+		Keep in mind that this flag is reset after branch completion. Therefore
+		it is necessary to set it again e.g. in a failure_route if you do serial
+		forking and want to log all attempts.
 		</para>
 		<para>
 		Default value is not-set (no flag).
@@ -1013,97 +1020,6 @@ modparam("acc", "db_insert_mode", 1)
 ...
 </programlisting>
 		</example>
-	</section>
-	<!-- DIAMETER specific ACC parameters -->
-	<section id="acc.p.diameter_flag">
-		<title><varname>diameter_flag</varname> (integer)</title>
-		<para>
-		Request flag which needs to be set to account a
-		transaction -- DIAMETER specific.
-		</para>
-		<para>
-		Default value is not-set (no flag).
-		</para>
-		<example>
-		<title>diameter_flag example</title>
-		<programlisting format="linespecific">
-...
-modparam("acc", "diameter_flag", 2)
-...
-</programlisting>
-		</example>
-	</section>
-	<section id="acc.p.diameter_missed_flag">
-		<title><varname>diameter_missed_flag</varname> (integer)</title>
-		<para>
-		Request flag which needs to be set to account missed
-		calls -- DIAMETER specific.
-		</para>
-		<para>
-		Default value is not-set (no flag).
-		</para>
-		<example>
-		<title>diameter_missed_flag example</title>
-		<programlisting format="linespecific">
-...
-modparam("acc", "diameter_missed_flag", 3)
-...
-</programlisting>
-		</example>
-	</section>
-	<section id="acc.p.diameter_client_host">
-		<title><varname>diameter_client_host</varname> (string)</title>
-		<para>
-		Hostname of the machine where the DIAMETER Client is
-		running -- DIAMETER specific.
-		</para>
-		<para>
-		Default value is <quote>localhost</quote>.
-		</para>
-		<example>
-		<title>diameter_client_host example</title>
-		<programlisting format="linespecific">
-...
-modparam("acc", "diameter_client_host", "3a_server.net")
-...
-</programlisting>
-		</example>
-	</section>
-	<section id="acc.p.diameter_client_port">
-		<title><varname>diameter_client_port</varname> (int)</title>
-		<para>
-		Port number where the Diameter Client is
-		listening -- DIAMETER specific.
-		</para>
-		<para>
-		Default value is 3000.
-		</para>
-		<example>
-		<title>diameter_client_host example</title>
-		<programlisting format="linespecific">
-...
-modparam("acc", "diameter_client_port", 3000)
-...
-</programlisting>
-		</example>
-	</section>
-	<section id="acc.p.diameter_extra">
-		<title><varname>diameter_extra</varname> (string)</title>
-		<para>
-		Extra values to be logged via DIAMETER - DIAMETER specific.
-		See section <xref linkend="acc.i.extra-accounting"/> for more details.
-		</para>
-		<para>
-		Default value is NULL.
-		</para>
-		<example>
-		<title>diameter_extra example</title>
-		<programlisting format="linespecific">
-...
-modparam("acc", "diameter_extra", "7846=$hdr(Content-type);7847=$avp(s:email)")
-...
-</programlisting>
-		</example>
 	</section>
 	<section id="acc.p.cdr_enable">
 		<title><varname>cdr_enable</varname> (integer)</title>
--- a/src/modules/app_python/apy_kemi.c
+++ b/src/modules/app_python/apy_kemi.c
@@ -269,16 +269,16 @@ PyObject *sr_apy_kemi_exec_func_ex(sr_ke
 			}
 			LM_DBG("params[%d] for: %.*s are int-int-int: [%d] [%d] [%d]\n",
 					i, fname.len, fname.s, vps[0].n, vps[1].n, vps[2].n);
-               } else if(ket->ptypes[0]==SR_KEMIP_INT && ket->ptypes[1]==SR_KEMIP_INT
-                               && ket->ptypes[2]==SR_KEMIP_STR) {
-                       if(!PyArg_ParseTuple(args, "iis:kemi-param-nns", &vps[0].n,
-                                            &vps[1].n, &vps[2].s.s)) {
-                               LM_ERR("unable to retrieve int-int-str params %d\n", i);
-                               return sr_kemi_apy_return_false();
-                       }
-                       vps[2].s.len = strlen(vps[2].s.s);
-                       LM_DBG("params[%d] for: %.*s are int-int-str: [%d] [%d] [%.*s]\n", i,
-                               fname.len, fname.s, vps[0].n, vps[1].n, vps[2].s.len, vps[2].s.s);
+		} else if(ket->ptypes[0]==SR_KEMIP_INT && ket->ptypes[1]==SR_KEMIP_INT
+					&& ket->ptypes[2]==SR_KEMIP_STR) {
+			if(!PyArg_ParseTuple(args, "iis:kemi-param-nns", &vps[0].n,
+						&vps[1].n, &vps[2].s.s)) {
+				LM_ERR("unable to retrieve int-int-str params %d\n", i);
+				return sr_kemi_apy_return_false();
+			}
+			vps[2].s.len = strlen(vps[2].s.s);
+			LM_DBG("params[%d] for: %.*s are int-int-str: [%d] [%d] [%.*s]\n", i,
+					fname.len, fname.s, vps[0].n, vps[1].n, vps[2].s.len, vps[2].s.s);
 		} else if(ket->ptypes[0]==SR_KEMIP_INT && ket->ptypes[1]==SR_KEMIP_STR
 				&& ket->ptypes[2]==SR_KEMIP_INT) {
 			if(!PyArg_ParseTuple(args, "isi:kemi-param-nsn", &vps[0].n,
@@ -289,6 +289,18 @@ PyObject *sr_apy_kemi_exec_func_ex(sr_ke
 			vps[1].s.len = strlen(vps[1].s.s);
 			LM_DBG("params[%d] for: %.*s are int-str-int: [%d] [%.*s] [%d]\n", i,
 				fname.len, fname.s, vps[0].n, vps[1].s.len, vps[1].s.s, vps[2].n);
+		} else if(ket->ptypes[0]==SR_KEMIP_INT && ket->ptypes[1]==SR_KEMIP_STR
+				&& ket->ptypes[2]==SR_KEMIP_STR) {
+			if(!PyArg_ParseTuple(args, "iss:kemi-param-nss", &vps[0].n,
+						&vps[1].s.s, &vps[2].s.s)) {
+				LM_ERR("unable to retrieve int-str-str param %d\n", i);
+				return sr_kemi_apy_return_false();
+			}
+			vps[1].s.len = strlen(vps[1].s.s);
+			vps[2].s.len = strlen(vps[2].s.s);
+			LM_DBG("params[%d] for: %.*s are int-str-str: [%d] [%.*s]"
+					" [%.*s]\n", i, fname.len, fname.s,
+					vps[0].n, vps[1].s.len, vps[1].s.s, vps[2].s.len, vps[2].s.s);
 		} else if(ket->ptypes[0]==SR_KEMIP_STR && ket->ptypes[1]==SR_KEMIP_INT
 				&& ket->ptypes[2]==SR_KEMIP_INT) {
 			if(!PyArg_ParseTuple(args, "sii:kemi-param-snn", &vps[0].s.s,
@@ -300,6 +312,19 @@ PyObject *sr_apy_kemi_exec_func_ex(sr_ke
 			LM_DBG("params[%d] for: %.*s are str-int: [%.*s] [%d] [%d]\n", i,
 					fname.len, fname.s, vps[0].s.len, vps[0].s.s, vps[1].n,
 					vps[2].n);
+		} else if(ket->ptypes[0]==SR_KEMIP_STR && ket->ptypes[1]==SR_KEMIP_INT
+				&& ket->ptypes[2]==SR_KEMIP_STR) {
+			if(!PyArg_ParseTuple(args, "sis:kemi-param-ssn", &vps[0].s.s,
+						&vps[1].n, &vps[2].s.s)) {
+				LM_ERR("unable to retrieve str-int-str param %d\n", i);
+				return sr_kemi_apy_return_false();
+			}
+			vps[0].s.len = strlen(vps[0].s.s);
+			vps[2].s.len = strlen(vps[2].s.s);
+			LM_DBG("params[%d] for: %.*s are str-str-int: [%.*s] [%d] [%.*s]\n",
+					i, fname.len, fname.s,
+					vps[0].s.len, vps[0].s.s,
+					vps[1].n, vps[2].s.len, vps[2].s.s);
 		} else if(ket->ptypes[0]==SR_KEMIP_STR && ket->ptypes[1]==SR_KEMIP_STR
 				&& ket->ptypes[2]==SR_KEMIP_INT) {
 			if(!PyArg_ParseTuple(args, "ssi:kemi-param-ssn", &vps[0].s.s,
@@ -323,7 +348,7 @@ PyObject *sr_apy_kemi_exec_func_ex(sr_ke
 			vps[0].s.len = strlen(vps[0].s.s);
 			vps[1].s.len = strlen(vps[1].s.s);
 			vps[2].s.len = strlen(vps[2].s.s);
-			LM_DBG("params[%d] for: %.*s are str-str-int: [%.*s] [%.*s]"
+			LM_DBG("params[%d] for: %.*s are str-str-str: [%.*s] [%.*s]"
 					" [%.*s]\n", i, fname.len, fname.s,
 					vps[0].s.len, vps[0].s.s,
 					vps[1].s.len, vps[1].s.s, vps[2].s.len, vps[2].s.s);
--- a/src/modules/app_python3/Makefile
+++ b/src/modules/app_python3/Makefile
@@ -16,7 +16,7 @@ PYTHON3_LIBDIR=${shell ${PYTHON3} -c "im
 PYTHON3_LDFLAGS=${shell ${PYTHON3} -c "import distutils.sysconfig;print(distutils.sysconfig.get_config_var('LINKFORSHARED'))"}
 PYTHON3_INCDIR=${shell ${PYTHON3} -c "import distutils.sysconfig;print(distutils.sysconfig.get_python_inc())"}
 
-LIBS=${shell ${PYTHON3}-config --libs}
+LIBS=${shell ${PYTHON3}-config --ldflags}
 
 ifeq ($(OS), freebsd)
 LIBS+=-pthread
--- a/src/modules/app_python3/apy_kemi.c
+++ b/src/modules/app_python3/apy_kemi.c
@@ -277,15 +277,15 @@ PyObject *sr_apy_kemi_exec_func_ex(sr_ke
 			LM_DBG("params[%d] for: %.*s are int-int-int: [%d] [%d] [%d]\n",
 					i, fname.len, fname.s, vps[0].n, vps[1].n, vps[2].n);
 		} else if(ket->ptypes[0]==SR_KEMIP_INT && ket->ptypes[1]==SR_KEMIP_INT
-				&& ket->ptypes[2]==SR_KEMIP_STR) {
+					&& ket->ptypes[2]==SR_KEMIP_STR) {
 			if(!PyArg_ParseTuple(args, "iis:kemi-param-nns", &vps[0].n,
-					     &vps[1].n, &vps[2].s.s)) {
+						&vps[1].n, &vps[2].s.s)) {
 				LM_ERR("unable to retrieve int-int-str params %d\n", i);
 				return sr_kemi_apy_return_false();
 			}
 			vps[2].s.len = strlen(vps[2].s.s);
 			LM_DBG("params[%d] for: %.*s are int-int-str: [%d] [%d] [%.*s]\n", i,
-				fname.len, fname.s, vps[0].n, vps[1].n, vps[2].s.len, vps[2].s.s);
+					fname.len, fname.s, vps[0].n, vps[1].n, vps[2].s.len, vps[2].s.s);
 		} else if(ket->ptypes[0]==SR_KEMIP_INT && ket->ptypes[1]==SR_KEMIP_STR
 				&& ket->ptypes[2]==SR_KEMIP_INT) {
 			if(!PyArg_ParseTuple(args, "isi:kemi-param-nsn", &vps[0].n,
@@ -296,6 +296,18 @@ PyObject *sr_apy_kemi_exec_func_ex(sr_ke
 			vps[1].s.len = strlen(vps[1].s.s);
 			LM_DBG("params[%d] for: %.*s are int-str-int: [%d] [%.*s] [%d]\n", i,
 				fname.len, fname.s, vps[0].n, vps[1].s.len, vps[1].s.s, vps[2].n);
+		} else if(ket->ptypes[0]==SR_KEMIP_INT && ket->ptypes[1]==SR_KEMIP_STR
+				&& ket->ptypes[2]==SR_KEMIP_STR) {
+			if(!PyArg_ParseTuple(args, "iss:kemi-param-nss", &vps[0].n,
+						&vps[1].s.s, &vps[2].s.s)) {
+				LM_ERR("unable to retrieve int-str-str param %d\n", i);
+				return sr_kemi_apy_return_false();
+			}
+			vps[1].s.len = strlen(vps[1].s.s);
+			vps[2].s.len = strlen(vps[2].s.s);
+			LM_DBG("params[%d] for: %.*s are int-str-str: [%d] [%.*s]"
+					" [%.*s]\n", i, fname.len, fname.s,
+					vps[0].n, vps[1].s.len, vps[1].s.s, vps[2].s.len, vps[2].s.s);
 		} else if(ket->ptypes[0]==SR_KEMIP_STR && ket->ptypes[1]==SR_KEMIP_INT
 				&& ket->ptypes[2]==SR_KEMIP_INT) {
 			if(!PyArg_ParseTuple(args, "sii:kemi-param-snn", &vps[0].s.s,
@@ -307,6 +319,19 @@ PyObject *sr_apy_kemi_exec_func_ex(sr_ke
 			LM_DBG("params[%d] for: %.*s are str-int: [%.*s] [%d] [%d]\n", i,
 					fname.len, fname.s, vps[0].s.len, vps[0].s.s, vps[1].n,
 					vps[2].n);
+		} else if(ket->ptypes[0]==SR_KEMIP_STR && ket->ptypes[1]==SR_KEMIP_INT
+				&& ket->ptypes[2]==SR_KEMIP_STR) {
+			if(!PyArg_ParseTuple(args, "sis:kemi-param-ssn", &vps[0].s.s,
+						&vps[1].n, &vps[2].s.s)) {
+				LM_ERR("unable to retrieve str-int-str param %d\n", i);
+				return sr_kemi_apy_return_false();
+			}
+			vps[0].s.len = strlen(vps[0].s.s);
+			vps[2].s.len = strlen(vps[2].s.s);
+			LM_DBG("params[%d] for: %.*s are str-str-int: [%.*s] [%d] [%.*s]\n",
+					i, fname.len, fname.s,
+					vps[0].s.len, vps[0].s.s,
+					vps[1].n, vps[2].s.len, vps[2].s.s);
 		} else if(ket->ptypes[0]==SR_KEMIP_STR && ket->ptypes[1]==SR_KEMIP_STR
 				&& ket->ptypes[2]==SR_KEMIP_INT) {
 			if(!PyArg_ParseTuple(args, "ssi:kemi-param-ssn", &vps[0].s.s,
@@ -330,7 +355,7 @@ PyObject *sr_apy_kemi_exec_func_ex(sr_ke
 			vps[0].s.len = strlen(vps[0].s.s);
 			vps[1].s.len = strlen(vps[1].s.s);
 			vps[2].s.len = strlen(vps[2].s.s);
-			LM_DBG("params[%d] for: %.*s are str-str-int: [%.*s] [%.*s]"
+			LM_DBG("params[%d] for: %.*s are str-str-str: [%.*s] [%.*s]"
 					" [%.*s]\n", i, fname.len, fname.s,
 					vps[0].s.len, vps[0].s.s,
 					vps[1].s.len, vps[1].s.s, vps[2].s.len, vps[2].s.s);
--- a/src/modules/app_ruby/README
+++ b/src/modules/app_ruby/README
@@ -34,7 +34,7 @@ Daniel-Constantin Mierla
         5. RPC Commands
 
               5.1. app_ruby.reload
-              5.2. ruby_jsdt.api_list
+              5.2. app_ruby.api_list
 
         6. Example of usage
 
@@ -64,7 +64,7 @@ Chapter 1. Admin Guide
    5. RPC Commands
 
         5.1. app_ruby.reload
-        5.2. ruby_jsdt.api_list
+        5.2. app_ruby.api_list
 
    6. Example of usage
 
@@ -140,7 +140,7 @@ ruby_run("rb_funcx", "$rU", "2");
 5. RPC Commands
 
    5.1. app_ruby.reload
-   5.2. ruby_jsdt.api_list
+   5.2. app_ruby.api_list
 
 5.1.  app_ruby.reload
 
@@ -157,11 +157,11 @@ ruby_run("rb_funcx", "$rU", "2");
 kamcmd app_ruby.reload
 ...
 
-5.2.  ruby_jsdt.api_list
+5.2.  app_ruby.api_list
 
    List the functions available via Kemi framework.
 
-   Name: ruby_jsdt.api_list
+   Name: app_ruby.api_list
 
    Parameters: none
 
--- a/src/modules/app_ruby/app_ruby_api.c
+++ b/src/modules/app_ruby/app_ruby_api.c
@@ -758,7 +758,8 @@ VALUE sr_kemi_ruby_exec_func(ksr_ruby_co
 
 	LM_DBG("executing %p eidx %d\n", ket, eidx);
 	if(env_R==NULL || env_R->msg==NULL || ket==NULL) {
-		LM_ERR("invalid ruby environment attributes or parameters\n");
+		LM_ERR("invalid ruby environment attributes or parameters (%p/%p/%p)\n",
+				env_R, env_R->msg, ket);
 		return Qfalse;
 	}
 
--- a/src/modules/app_ruby/doc/app_ruby_admin.xml
+++ b/src/modules/app_ruby/doc/app_ruby_admin.xml
@@ -143,13 +143,13 @@ ruby_run("rb_funcx", "$rU", "2");
         </section>
        <section id="app_ruby.r.api_list">
             <title>
-            <function moreinfo="none">ruby_jsdt.api_list</function>
+            <function moreinfo="none">app_ruby.api_list</function>
             </title>
             <para>
 			List the functions available via Kemi framework.
             </para>
             <para>
-            Name: <emphasis>ruby_jsdt.api_list</emphasis>
+            Name: <emphasis>app_ruby.api_list</emphasis>
             </para>
             <para>Parameters: <emphasis>none</emphasis></para>
             <para>
--- a/src/modules/app_sqlang/squirrel/sqstdlib/sqstdlib.dsp
+++ b/src/modules/app_sqlang/squirrel/sqstdlib/sqstdlib.dsp
@@ -1,131 +1,131 @@
-# Microsoft Developer Studio Project File - Name="sqstdlib" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Static Library" 0x0104
-
-CFG=sqstdlib - Win32 Release
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "sqstdlib.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "sqstdlib.mak" CFG="sqstdlib - Win32 Release"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "sqstdlib - Win32 Release" (based on "Win32 (x86) Static Library")
-!MESSAGE "sqstdlib - Win32 Debug" (based on "Win32 (x86) Static Library")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_LocalPath ".."
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "sqstdlib - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
-# ADD CPP /nologo /W3 /GX /O2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
-# ADD BASE RSC /l 0x410 /d "NDEBUG"
-# ADD RSC /l 0x410 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo /out:"..\lib\sqstdlib.lib"
-
-!ELSEIF  "$(CFG)" == "sqstdlib - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "Debug"
-# PROP BASE Intermediate_Dir "Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
-# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
-# ADD BASE RSC /l 0x410 /d "_DEBUG"
-# ADD RSC /l 0x410 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo /out:"..\lib\sqstdlib.lib"
-
-!ENDIF 
-
-# Begin Target
-
-# Name "sqstdlib - Win32 Release"
-# Name "sqstdlib - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\sqstdblob.cpp
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstdio.cpp
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstdmath.cpp
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstdrex.cpp
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstdstream.cpp
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstdstring.cpp
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstdaux.cpp
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstdsystem.cpp
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\sqstdblobimpl.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstdstream.h
-# End Source File
-# End Group
-# End Target
-# End Project
+# Microsoft Developer Studio Project File - Name="sqstdlib" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=sqstdlib - Win32 Release
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "sqstdlib.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "sqstdlib.mak" CFG="sqstdlib - Win32 Release"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "sqstdlib - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "sqstdlib - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_LocalPath ".."
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "sqstdlib - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x410 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\sqstdlib.lib"
+
+!ELSEIF  "$(CFG)" == "sqstdlib - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x410 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\sqstdlib.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "sqstdlib - Win32 Release"
+# Name "sqstdlib - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\sqstdblob.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdio.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdmath.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdrex.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdstream.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdstring.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdaux.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdsystem.cpp
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\sqstdblobimpl.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstdstream.h
+# End Source File
+# End Group
+# End Target
+# End Project
--- a/src/modules/app_sqlang/squirrel/squirrel/squirrel.dsp
+++ b/src/modules/app_sqlang/squirrel/squirrel/squirrel.dsp
@@ -1,302 +1,302 @@
-# Microsoft Developer Studio Project File - Name="squirrel" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Static Library" 0x0104
-
-CFG=squirrel - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "squirrel.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "squirrel.mak" CFG="squirrel - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "squirrel - Win32 Release" (based on "Win32 (x86) Static Library")
-!MESSAGE "squirrel - Win32 Debug" (based on "Win32 (x86) Static Library")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_LocalPath ".."
-CPP=cl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
-# ADD CPP /nologo /W3 /GX /O2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "GARBAGE_COLLECTOR" /YX /FD /c
-# ADD BASE RSC /l 0x410 /d "NDEBUG"
-# ADD RSC /l 0x410 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo /out:"..\lib\squirrel.lib"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "Debug"
-# PROP BASE Intermediate_Dir "Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
-# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
-# ADD BASE RSC /l 0x410 /d "_DEBUG"
-# ADD RSC /l 0x410 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LIB32=link.exe -lib
-# ADD BASE LIB32 /nologo
-# ADD LIB32 /nologo /out:"..\lib\squirrel.lib"
-
-!ENDIF 
-
-# Begin Target
-
-# Name "squirrel - Win32 Release"
-# Name "squirrel - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\sqapi.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqbaselib.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqcompiler.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqdebug.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqfuncstate.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqlexer.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqmem.cpp
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqobject.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstate.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqtable.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqclass.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqvm.cpp
-
-!IF  "$(CFG)" == "squirrel - Win32 Release"
-
-!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
-
-# ADD CPP /YX"stdafx.h"
-
-!ENDIF 
-
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\sqarray.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqclosure.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqcompiler.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqfuncproto.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqfuncstate.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqlexer.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqobject.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqopcodes.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqpcheader.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstate.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqstring.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqtable.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\squserdata.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\squtils.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqclass.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sqvm.h
-# End Source File
-# End Group
-# End Target
-# End Project
+# Microsoft Developer Studio Project File - Name="squirrel" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=squirrel - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "squirrel.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "squirrel.mak" CFG="squirrel - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "squirrel - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "squirrel - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_LocalPath ".."
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "GARBAGE_COLLECTOR" /YX /FD /c
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x410 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\squirrel.lib"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x410 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"..\lib\squirrel.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "squirrel - Win32 Release"
+# Name "squirrel - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\sqapi.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqbaselib.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqcompiler.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqdebug.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqfuncstate.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqlexer.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqmem.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqobject.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstate.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqtable.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqclass.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqvm.cpp
+
+!IF  "$(CFG)" == "squirrel - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "squirrel - Win32 Debug"
+
+# ADD CPP /YX"stdafx.h"
+
+!ENDIF 
+
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\sqarray.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqclosure.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqcompiler.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqfuncproto.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqfuncstate.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqlexer.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqobject.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqopcodes.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqpcheader.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstate.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqstring.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqtable.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\squserdata.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\squtils.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqclass.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sqvm.h
+# End Source File
+# End Group
+# End Target
+# End Project
--- a/src/modules/auth_radius/extra.h
+++ b/src/modules/auth_radius/extra.h
@@ -36,7 +36,7 @@ struct extra_attr
 	struct extra_attr *next;
 };
 
-#define MAX_EXTRA 4
+#define MAX_EXTRA 32
 
 void init_extra_engine(void);
 
--- a/src/modules/call_control/README
+++ b/src/modules/call_control/README
@@ -92,6 +92,11 @@ Chapter 1. Admin Guide
        also instruct the rating engine to debit the balance for the caller
        with the consumed amount. The callcontrol application is available
        from http://callcontrol.ag-projects.com/
+     * At the moment the callcontrol application only supports the old
+       “MI” interface for communication with Kamailio. This interface is
+       unfortunately not available anymore in Kamailio. So this
+       application can't be used right now together with the call_control
+       module.
      * A rating engine that is used to calculate the time limit based on
        the caller's credit and the destination price and to debit the
        caller's balance after a call ends. This is available as part of
--- a/src/modules/call_control/doc/call_control_admin.xml
+++ b/src/modules/call_control/doc/call_control_admin.xml
@@ -45,6 +45,15 @@
         </listitem>
         <listitem>
           <para>
+            At the moment the callcontrol application only supports the old
+            <quote>MI</quote> interface for communication with Kamailio. This
+            interface is unfortunately not available anymore in Kamailio. So
+            this application can't be used right now together with the
+            call_control module.
+          </para>
+        </listitem>
+        <listitem>
+          <para>
             A rating engine that is used to calculate the time limit based on
             the caller's credit and the destination price and to debit the
             caller's balance after a call ends. This is available as part of
--- a/src/modules/call_obj/call_obj_mod.c
+++ b/src/modules/call_obj/call_obj_mod.c
@@ -28,7 +28,7 @@ int call_obj_end = 0;
 
 /* module commands */
 static cmd_export_t cmds[] = {
-	{"call_obj_get", (cmd_function)w_call_obj_get, 1, fixup_pvar_null, fixup_free_pvar_null, ANY_ROUTE},
+	{"call_obj_get", (cmd_function)w_call_obj_get, 1, fixup_pvar_null, 0, ANY_ROUTE},
 	{"call_obj_free", (cmd_function)w_call_obj_free, 1, fixup_var_str_1, 0, ANY_ROUTE},
 	{ 0, 0, 0, 0, 0, 0}
 };
@@ -105,7 +105,7 @@ static void rpc_call_obj_list(rpc_t *rpc
 	cobj_elem_t *list = NULL;
 
 	int rc = rpc->scan(ctx, "d*d", &duration, &limit);
-	if (rc != -1 && rc != 2) {
+	if (rc != 1 && rc != 2) {
 		rpc->fault(ctx, 400, "requires arguments for duration number (and optionally limit)");
 		goto clean;
 	}
--- a/src/modules/corex/corex_lib.c
+++ b/src/modules/corex/corex_lib.c
@@ -114,6 +114,7 @@ int corex_add_alias_subdomains(char* ali
 	corex_alias_t ta;
 	corex_alias_t *na;
 
+	LM_DBG("try to add alias: %s\n", aliasval);
 	memset(&ta, 0, sizeof(corex_alias_t));
 
 	p = strchr(aliasval, ':');
@@ -134,27 +135,38 @@ int corex_add_alias_subdomains(char* ali
 		} else if((p-aliasval)==4 && strncasecmp(aliasval, "sctp", 4)==0) {
 			ta.proto = PROTO_SCTP;
 		} else {
-			/* use hostname */
-			ta.alias.s = aliasval;
-			ta.alias.len = p - aliasval;
+			/* invalid protocol */
+			LM_ERR("invalid protocol %.*s", (int) (p-aliasval), aliasval);
+			goto error;
 		}
-	}
-	if(ta.alias.len==0) {
+		/* hostname */
 		p++;
-		if(p>=aliasval+strlen(aliasval))
+		ta.alias.s = aliasval + (p-aliasval);
+
+		if(p>=aliasval+strlen(aliasval)) {
 			goto error;
-		ta.alias.s = p;
+		}
+		/* port */
 		p = strchr(ta.alias.s, ':');
 		if(p==NULL) {
 			ta.alias.len = strlen(ta.alias.s);
 			goto done;
 		}
+		ta.alias.len = p - ta.alias.s;
+		p++;
+                ta.port = str2s(p, strlen(p), NULL);
+
+	} else {
+		/* hostname */
+		ta.alias.s = aliasval;
+		ta.alias.len = p - ta.alias.s;
+		/* port */
+		p++;
+		if(p>=aliasval+strlen(aliasval)) {
+			goto error;
+		}
+		ta.port = str2s(p, strlen(p), NULL);
 	}
-	/* port */
-	p++;
-	if(p>=aliasval+strlen(aliasval))
-		goto error;
-	ta.port = str2s(p, strlen(p), NULL);
 
 done:
 	if(ta.alias.len==0)
@@ -169,6 +181,8 @@ done:
 	na->next = _corex_alias_list;
 	_corex_alias_list = na;
 
+	LM_DBG("alias: %d:%.*s:%d from value: %s added\n", ta.proto,
+		ta.alias.len, ta.alias.s, ta.port, aliasval);
 	return 0;
 
 error:
@@ -181,6 +195,8 @@ int corex_check_self(str* host, unsigned
 {
 	corex_alias_t *ta;
 
+	LM_DBG("check self for: %d:%.*s:%d\n", (int) proto, host->len,
+			host->s, (int)port);
 	for(ta=_corex_alias_list; ta; ta=ta->next) {
 		if(host->len<ta->alias.len)
 			continue;
@@ -191,21 +207,22 @@ int corex_check_self(str* host, unsigned
 		if(host->len==ta->alias.len
 				&& strncasecmp(host->s, ta->alias.s, host->len)==0) {
 			/* match domain */
-			LM_DBG("check self domain match: %d:%.*s:%d\n", (int)ta->port,
-					ta->alias.len, ta->alias.s, (int)ta->proto);
+			LM_DBG("check self domain match: %d:%.*s:%d\n", (int)ta->proto,
+				ta->alias.len, ta->alias.s, (int)ta->port);
 			return 1;
 		}
 		if(strncasecmp(ta->alias.s, host->s + host->len - ta->alias.len,
 					ta->alias.len)==0) {
 			if(host->s[host->len - ta->alias.len - 1]=='.') {
 				/* match sub-domain */
-				LM_DBG("check self sub-domain match: %d:%.*s:%d\n", (int)ta->port,
-					ta->alias.len, ta->alias.s, (int)ta->proto);
+				LM_DBG("check self sub-domain match: %d:%.*s:%d\n",
+					(int)ta->proto, ta->alias.len, ta->alias.s,
+					(int)ta->port);
 				return 1;
 			}
 		}
 	}
-
+	LM_DBG("no match found\n");
 	return 0; /* no match */
 }
 
--- a/src/modules/corex/corex_mod.c
+++ b/src/modules/corex/corex_mod.c
@@ -630,6 +630,8 @@ static int ki_set_socket_helper(sip_msg_
 				ssock->len, ssock->s, smode);
 		goto error;
 	}
+	LM_DBG("trying to set %s-socket to [%.*s] (%d)\n",
+				(smode==0)?"snd":"rcv", ssock->len, ssock->s, smode);
 	si = grep_sock_info(&host, (unsigned short)port, (unsigned short)proto);
 	if (si!=NULL) {
 		if(smode==0) {
--- a/src/modules/corex/corex_nio.c
+++ b/src/modules/corex/corex_nio.c
@@ -141,6 +141,7 @@ int nio_msg_sent(sr_event_param_t *evp)
     int_str avp_value;
     struct usr_avp *avp;
     struct run_act_ctx ra_ctx;
+    str nbuf = STR_NULL;
 
     obuf = (str*)evp->data;
 
@@ -163,7 +164,15 @@ int nio_msg_sent(sr_event_param_t *evp)
         if(avp!=NULL && is_avp_str_val(avp)) {
             msg.buf = avp_value.s.s;
             msg.len = avp_value.s.len;
-            obuf->s = nio_msg_update(&msg, (unsigned int*)&obuf->len);
+            nbuf.s = nio_msg_update(&msg, (unsigned int*)&nbuf.len);
+			if(nbuf.s!=NULL) {
+				LM_DBG("new outbound buffer generated\n");
+				pkg_free(obuf->s);
+				obuf->s = nbuf.s;
+				obuf->len = nbuf.len;
+			} else {
+				LM_ERR("failed to generate new outbound buffer\n");
+			}
         } else {
             LM_WARN("no value set for AVP %.*s, using unmodified message\n",
                 nio_msg_avp_param.len, nio_msg_avp_param.s);
--- a/src/modules/db_berkeley/Makefile
+++ b/src/modules/db_berkeley/Makefile
@@ -25,7 +25,7 @@ ifeq ($(INSTALL_FLAVOUR),kamailio)
 # extra install for kamailio
 
 install-berkeley-scripts: $(bin_prefix)/$(bin_dir)
-		BERKELEYDBON=yes make -C ../../../utils/kamctl/ install-modules
+	BERKELEYDBON=yes $(MAKE) -C ../../../utils/kamctl/ install-modules
 
 install-scripts: install-berkeley-scripts
 
--- a/src/modules/db_mysql/km_dbase.c
+++ b/src/modules/db_mysql/km_dbase.c
@@ -35,7 +35,6 @@
 #include <string.h>
 #include <mysql.h>
 #include <errmsg.h>
-#include <mysql_version.h>
 #include "../../core/mem/mem.h"
 #include "../../core/dprint.h"
 #include "../../core/async_task.h"
--- a/src/modules/db_mysql/my_uri.c
+++ b/src/modules/db_mysql/my_uri.c
@@ -95,12 +95,13 @@ static int parse_mysql_uri(struct my_uri
 		ST_USER_HOST,  /* Username or hostname */
 		ST_PASS_PORT,  /* Password or port part */
 		ST_HOST,       /* Hostname part */
+		ST_HOST6,      /* Hostname part IPv6 */
 		ST_PORT,       /* Port part */
 		ST_DB          /* Database part */
 	};
 
 	enum state st;
-	int  i;
+	int  i, ipv6_flag=0;
 	const char* begin;
 	char* prev_token;
 
@@ -156,6 +157,11 @@ static int parse_mysql_uri(struct my_uri
 				begin = uri->s + i + 1;
 				break;
 
+			case '[':
+				st = ST_HOST6;
+				begin = uri->s + i + 1;
+				break;
+
 			case '/':
 				if (dupl_string(&res->host, begin, uri->s + i) < 0) goto err;
 				if (dupl_string(&res->database, uri->s + i + 1, uri->s + uri->len) < 0) goto err;
@@ -184,19 +190,33 @@ static int parse_mysql_uri(struct my_uri
 
 		case ST_HOST:
 			switch(uri->s[i]) {
+			case '[':
+				st = ST_HOST6;
+				begin = uri->s + i + 1;
+				break;
+
 			case ':':
 				st = ST_PORT;
-				if (dupl_string(&res->host, begin, uri->s + i) < 0) goto err;
+				if (dupl_string(&res->host, begin, uri->s + i - ipv6_flag) < 0) goto err;
 				begin = uri->s + i + 1;
 				break;
 
 			case '/':
-				if (dupl_string(&res->host, begin, uri->s + i) < 0) goto err;
+				if (dupl_string(&res->host, begin, uri->s + i - ipv6_flag) < 0) goto err;
 				if (dupl_string(&res->database, uri->s + i + 1, uri->s + uri->len) < 0) goto err;
 				return 0;
 			}
 			break;
 
+		case ST_HOST6:
+			switch(uri->s[i]) {
+			case ']':
+				ipv6_flag = 1;
+				st = ST_HOST;
+				break;
+			}
+			break;
+
 		case ST_PORT:
 			switch(uri->s[i]) {
 			case '/':
--- a/src/modules/db_oracle/Makefile
+++ b/src/modules/db_oracle/Makefile
@@ -17,7 +17,7 @@ ifeq ($(INSTALL_FLAVOUR),kamailio)
 # extra install for kamailio
 
 install-oracle-scripts: $(bin_prefix)/$(bin_dir)
-		ORACLEON=yes make -C ../../../utils/kamctl/ install-modules
+	ORACLEON=yes $(MAKE) -C ../../../utils/kamctl/ install-modules
 
 install-scripts: install-oracle-scripts
 
--- a/src/modules/db_postgres/pg_uri.c
+++ b/src/modules/db_postgres/pg_uri.c
@@ -109,12 +109,13 @@ static int parse_postgres_uri(struct pg_
 		ST_USER_HOST, /* Username or hostname */
 		ST_PASS_PORT, /* Password or port part */
 		ST_HOST,	  /* Hostname part */
+		ST_HOST6,	  /* Hostname part IPv6 */
 		ST_PORT,	  /* Port part */
 		ST_DB		  /* Database part */
 	};
 
 	enum state st;
-	int i;
+	int i, ipv6_flag=0;
 	const char *begin;
 	char *prev_token;
 
@@ -172,6 +173,11 @@ static int parse_postgres_uri(struct pg_
 						begin = uri->s + i + 1;
 						break;
 
+					case '[':
+						st = ST_HOST6;
+						begin = uri->s + i + 1;
+						break;
+
 					case '/':
 						if(memchr(uri->s + i + 1, '/', uri->len - i - 1)
 								!= NULL)
@@ -212,9 +218,14 @@ static int parse_postgres_uri(struct pg_
 
 			case ST_HOST:
 				switch(uri->s[i]) {
+					case '[':
+						st = ST_HOST6;
+						begin = uri->s + i + 1;
+						break;
+
 					case ':':
 						st = ST_PORT;
-						if(dupl_string(&res->host, begin, uri->s + i) < 0)
+						if(dupl_string(&res->host, begin, uri->s + i - ipv6_flag) < 0)
 							goto err;
 						begin = uri->s + i + 1;
 						break;
@@ -223,7 +234,7 @@ static int parse_postgres_uri(struct pg_
 						if(memchr(uri->s + i + 1, '/', uri->len - i - 1)
 								!= NULL)
 							break;
-						if(dupl_string(&res->host, begin, uri->s + i) < 0)
+						if(dupl_string(&res->host, begin, uri->s + i - ipv6_flag) < 0)
 							goto err;
 						if(dupl_string(&res->database, uri->s + i + 1,
 								   uri->s + uri->len)
@@ -233,6 +244,15 @@ static int parse_postgres_uri(struct pg_
 				}
 				break;
 
+			case ST_HOST6:
+				switch(uri->s[i]) {
+					case ']':
+						ipv6_flag = 1;
+						st = ST_HOST;
+						break;
+				}
+				break;
+
 			case ST_PORT:
 				switch(uri->s[i]) {
 					case '/':
--- a/src/modules/db_redis/README
+++ b/src/modules/db_redis/README
@@ -10,8 +10,6 @@ Andreas Granig
 
    <agranig@sipwise.com>
 
-Edited by
-
 Alex Balashov
 
    <abalashov@evaristesys.com>
@@ -138,7 +136,9 @@ nce/string,server_id/int,connection_id/i
    parameter, but it does not need to be related to the table loaded from
    Redis server -- for example, if used only for permissions module with
    'address' table, then the 'keys' parameter can be specified for
-   'version' table.
+   'version' table. However, if it used for a module that inserts or
+   updates the records in database table, the key for entry must be
+   defined for that table.
 
    The mappings can be freely defined in the "keys" module parameter,
    which is composed of a semi-colon separated list of definitions in the
@@ -235,6 +235,7 @@ loadmodule "db_redis.so"
 #!define DBURL_ACC    "redis://127.0.0.1:6379/6"
 #!define DBURL_AUTH   "redis://127.0.0.1:6379/7"
 #!define DBURL_PERM   "redis://127.0.0.1:6379/8"
+#!define DBURL_DLG    "redis://127.0.0.1:6379/9"
 ...
 modparam("db_redis", "schema_path", "/usr/share/kamailio/db_redis/kamailio")
 modparam("db_redis", "keys", "version=entry:table_name")
@@ -242,6 +243,9 @@ modparam("db_redis", "keys", "location=e
 artition,keepalive")
 modparam("db_redis", "keys", "acc=entry:callid,time_hires&cid:callid")
 modparam("db_redis", "keys", "subscriber=entry:username,domain")
+modparam("db_redis", "keys", "dialog=entry:hash_entry,hash_id&cid:callid")
+modparam("db_redis", "keys", "dialog_vars=entry:hash_entry,hash_id,dialog_key&di
+alog:hash_entry,hash_id")
 ...
 modparam("usrloc", "db_url", DBURL_USRLOC)
 ...
@@ -251,6 +255,8 @@ modparam("auth_db", "db_url", DBURL_AUTH
 ...
 modparam("permissions", "db_url", DBURL_PERM)
 ...
+modparam("dialog", "db_url", DBURL_DLG)
+...
 
    Samples adding records for address table using 'redis-cli':
 
--- a/src/modules/db_redis/doc/db_redis_admin.xml
+++ b/src/modules/db_redis/doc/db_redis_admin.xml
@@ -81,7 +81,9 @@ username/string,domain/string,contact/st
 			parameter, but it does not need to be related to the table loaded
 			from Redis server -- for example, if used only for permissions module with
 			'address' table, then the 'keys' parameter can be specified for
-			'version' table.
+			'version' table. However, if it used for a module that inserts or
+			updates the records in database table, the key for entry must be defined for
+			that table.
 		</para>
 		<para>
 			The mappings can be freely defined in the "keys" module parameter, which is
@@ -224,12 +226,15 @@ loadmodule "db_redis.so"
 #!define DBURL_ACC    "redis://127.0.0.1:6379/6"
 #!define DBURL_AUTH   "redis://127.0.0.1:6379/7"
 #!define DBURL_PERM   "redis://127.0.0.1:6379/8"
+#!define DBURL_DLG    "redis://127.0.0.1:6379/9"
 ...
 modparam("db_redis", "schema_path", "/usr/share/kamailio/db_redis/kamailio")
 modparam("db_redis", "keys", "version=entry:table_name")
 modparam("db_redis", "keys", "location=entry:ruid&amp;usrdom:username,domain&amp;timer:partition,keepalive")
 modparam("db_redis", "keys", "acc=entry:callid,time_hires&amp;cid:callid")
 modparam("db_redis", "keys", "subscriber=entry:username,domain")
+modparam("db_redis", "keys", "dialog=entry:hash_entry,hash_id&amp;cid:callid")
+modparam("db_redis", "keys", "dialog_vars=entry:hash_entry,hash_id,dialog_key&amp;dialog:hash_entry,hash_id")
 ...
 modparam("usrloc", "db_url", DBURL_USRLOC)
 ...
@@ -239,6 +244,8 @@ modparam("auth_db", "db_url", DBURL_AUTH
 ...
 modparam("permissions", "db_url", DBURL_PERM)
 ...
+modparam("dialog", "db_url", DBURL_DLG)
+...
 			</programlisting>
 		</example>
 		<para>
--- a/src/modules/db_sqlite/Makefile
+++ b/src/modules/db_sqlite/Makefile
@@ -20,7 +20,7 @@ ifeq ($(INSTALL_FLAVOUR),kamailio)
 # extra install for kamailio
 
 install-sqlite-scripts: $(bin_prefix)/$(bin_dir)
-		SQLITEON=yes make -C ../../../utils/kamctl/ install-modules
+	SQLITEON=yes $(MAKE) -C ../../../utils/kamctl/ install-modules
 
 install-scripts: install-sqlite-scripts
 
--- a/src/modules/db_text/README
+++ b/src/modules/db_text/README
@@ -10,14 +10,10 @@ Ovidiu Sas
 
    <osas@voipembedded.com>
 
-Edited by
-
 Daniel-Constantin Mierla
 
    <miconda@gmail.com>
 
-Edited by
-
 Olle E. Johansson
 
    <oej@edvina.net>
@@ -355,7 +351,7 @@ modparam("module_name", "db_url", "text:
    Here are definitions for the most important tables as well as a basic
    configuration file to use db_text with Kamailio. The table structures
    may change in time and you will have to adjust these examples. Check
-   the source code directory “utils/kamctl/dbtxt/kamailio” for current
+   the source code directory “utils/kamctl/dbtext/kamailio” for current
    definitions.
 
    You have to populate the table 'subscriber' by hand with user profiles
--- a/src/modules/db_text/doc/db_text_admin.xml
+++ b/src/modules/db_text/doc/db_text_admin.xml
@@ -434,7 +434,7 @@ modparam("module_name", "db_url", "text:
 		Here are definitions for the most important tables as well as a basic 
 		configuration file to use db_text with &kamailio;. The table structures
 		may change in time and you will have to adjust these examples. Check the
-		source code directory <quote>utils/kamctl/dbtxt/kamailio</quote> for
+		source code directory <quote>utils/kamctl/dbtext/kamailio</quote> for
 		current definitions.
 		</para>
 		<para>
--- a/src/modules/dialog/README
+++ b/src/modules/dialog/README
@@ -12,18 +12,12 @@ Edited by
 
 Bogdan-Andrei Iancu
 
-Edited by
-
 Carsten Bock
 
-Edited by
-
 Alex Balashov
 
    <abalashov@evaristesys.com>
 
-Edited by
-
 Olle E. Johansson
 
    <oej@edvina.net>
@@ -1917,9 +1911,9 @@ kamcmd dlg.list_ctx
 
    RPC Command Format:
 ...
-kamcmd dlg.list abcdrssfrs122444@192.168.1.1 AAdfeEFF33
+kamcmd dlg.dlg_list abcdrssfrs122444@192.168.1.1 AAdfeEFF33
 ...
-kamcmd dlg.list abcdrssfrs122444@192.168.1.1
+kamcmd dlg.dlg_list abcdrssfrs122444@192.168.1.1
 ...
 
 9.4. dlg.dlg_list_ctx
@@ -2217,36 +2211,36 @@ Chapter 3. Frequently Asked Questions
 
    3.1.
 
-       What happened with “use_tight_match” parameter?
+   What happened with “use_tight_match” parameter?
 
-       The parameter was removed with version 1.3 as the option of tight
-       matching became mandatory and not configurable. Now, the tight matching
-       is done all the time (when using DID matching).
+   The parameter was removed with version 1.3 as the option of tight
+   matching became mandatory and not configurable. Now, the tight matching
+   is done all the time (when using DID matching).
 
    3.2.
 
-       Where can I find more about Kamailio?
+   Where can I find more about Kamailio?
 
-       Take a look at https://www.kamailio.org/.
+   Take a look at https://www.kamailio.org/.
 
    3.3.
 
-       Where can I post a question about this module?
+   Where can I post a question about this module?
 
-       First at all check if your question was already answered on one of our
-       mailing lists:
-         * User Mailing List -
-           https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-users
-         * Developer Mailing List -
-           https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-dev
-
-       E-mails regarding any stable Kamailio release should be sent to
-       <sr-users@lists.kamailio.org> and e-mails regarding development
-       versions should be sent to <sr-dev@lists.kamailio.org>.
+   First at all check if your question was already answered on one of our
+   mailing lists:
+     * User Mailing List -
+       https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-users
+     * Developer Mailing List -
+       https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-dev
+
+   E-mails regarding any stable Kamailio release should be sent to
+   <sr-users@lists.kamailio.org> and e-mails regarding development
+   versions should be sent to <sr-dev@lists.kamailio.org>.
 
    3.4.
 
-       How can I report a bug?
+   How can I report a bug?
 
-       Please follow the guidelines provided at:
-       https://github.com/kamailio/kamailio/issues.
+   Please follow the guidelines provided at:
+   https://github.com/kamailio/kamailio/issues.
--- a/src/modules/dialog/dialog.c
+++ b/src/modules/dialog/dialog.c
@@ -707,7 +707,6 @@ static int mod_init(void)
 		}
 	}
 
-	destroy_dlg_callbacks( DLGCB_LOADED );
 
 	/* timer process to send keep alive requests */
 	if(dlg_ka_timer>0 && dlg_ka_interval>0)
--- a/src/modules/dialog/dlg_cb.c
+++ b/src/modules/dialog/dlg_cb.c
@@ -232,6 +232,23 @@ void run_create_callbacks(struct dlg_cel
 	return;
 }
 
+void run_dlg_load_callbacks(struct dlg_cell *dlg)
+{
+	struct dlg_callback *cb;
+
+	if (load_cbs && load_cbs!=POINTER_CLOSED_MARKER) {
+		for ( cb=load_cbs->first; cb; cb=cb->next ) {
+			params.req = NULL;
+			params.rpl = NULL;
+			params.direction = DLG_DIR_NONE;
+			params.param = &cb->param;
+	
+			cb->callback( dlg, DLGCB_LOADED, &params );
+		}
+  }
+	return;
+}
+
 
 void run_dlg_callbacks( int type ,
 						struct dlg_cell *dlg,
--- a/src/modules/dialog/dlg_cb.h
+++ b/src/modules/dialog/dlg_cb.h
@@ -109,6 +109,7 @@ void run_dlg_callbacks( int type ,
 
 void run_load_callbacks( void );
 
+void run_dlg_load_callbacks(struct dlg_cell *dlg);
 
 /*!
  * \brief Function that returns valid SIP message from given dialog callback parameter struct
--- a/src/modules/dialog/dlg_cseq.c
+++ b/src/modules/dialog/dlg_cseq.c
@@ -364,6 +364,7 @@ int dlg_cseq_msg_sent(sr_event_param_t *
 	struct via_body *via;
 	hdr_field_t *hfk = NULL;
 	sr_cfgenv_t *cenv = NULL;
+	str nbuf = STR_NULL;
 
 	obuf = (str*)evp->data;
 	memset(&msg, 0, sizeof(sip_msg_t));
@@ -520,11 +521,13 @@ int dlg_cseq_msg_sent(sr_event_param_t *
 		}
 	}
 	/* replace old msg content */
-	obuf->s = pkg_malloc((tbuf_len+1)*sizeof(char));
-	if(obuf->s==NULL) {
+	nbuf.s = pkg_malloc((tbuf_len+1)*sizeof(char));
+	if(nbuf.s==NULL) {
 		LM_ERR("not enough memory for new message\n");
 		goto done;
 	}
+	pkg_free(obuf->s);
+	obuf->s = nbuf.s;
 	memcpy(obuf->s, tbuf, tbuf_len);
 	obuf->s[tbuf_len] = 0;
 	obuf->len = tbuf_len;
--- a/src/modules/dialog/dlg_db_handler.c
+++ b/src/modules/dialog/dlg_db_handler.c
@@ -40,6 +40,7 @@
 #include "../../core/counters.h"
 #include "dlg_hash.h"
 #include "dlg_var.h"
+#include "dlg_cb.h"
 #include "dlg_profile.h"
 #include "dlg_db_handler.h"
 
@@ -452,7 +453,7 @@ int load_dialog_info_from_db(int dlg_has
 			dlg_set_toroute(dlg, &toroute_name);
 
 			GET_STR_VALUE(xdata, values, 21, 0, 0);
-			if(xdata.s!=NULL && dlg->state!=DLG_STATE_DELETED)
+			if(xdata.len > 0 && xdata.s!=NULL && dlg->state!=DLG_STATE_DELETED)
 			{
 				srjson_InitDoc(&jdoc, NULL);
 				jdoc.buf = xdata;
@@ -488,6 +489,7 @@ int load_dialog_info_from_db(int dlg_has
 					get_ticks());
 
 			dlg->dflags = 0;
+  
 			if(mode!=0) {
 				if(loaded_extra<DLG_MAX_DB_LOAD_EXTRA) {
 					dbuid[loaded_extra].h_entry = dlg->h_entry;
@@ -497,6 +499,8 @@ int load_dialog_info_from_db(int dlg_has
 					dlg->dflags |= DLG_FLAG_DB_LOAD_EXTRA;
 					loaded_extra_more = 1;
 				}
+			  /* if loading at runtime run the callbacks for the loaded dialog */
+			  run_dlg_load_callbacks(dlg);
 			}
 			next_dialog:
 			;
--- a/src/modules/dialog/dlg_handlers.c
+++ b/src/modules/dialog/dlg_handlers.c
@@ -1428,7 +1428,7 @@ void dlg_onroute(struct sip_msg* req, st
 				dlg->tag[DLG_CALLER_LEG].len, dlg->tag[DLG_CALLER_LEG].s,
 				dlg->tag[DLG_CALLEE_LEG].len, dlg->tag[DLG_CALLEE_LEG].s);
 		} else if (ret > 0) {
-			LM_WARN("inconsitent dlg timer data on dlg %p [%u:%u] "
+			LM_WARN("inconsistent dlg timer data on dlg %p [%u:%u] "
 				"with clid '%.*s' and tags '%.*s' '%.*s'\n",
 				dlg, dlg->h_entry, dlg->h_id,
 				dlg->callid.len, dlg->callid.s,
@@ -1451,7 +1451,7 @@ void dlg_onroute(struct sip_msg* req, st
 		goto done;
 	}
 
-	if ( (event==DLG_EVENT_REQ || event==DLG_EVENT_REQACK)
+	if ( (event==DLG_EVENT_REQ || event==DLG_EVENT_REQACK || event==DLG_EVENT_REQPRACK)
 	&& (new_state==DLG_STATE_CONFIRMED || new_state==DLG_STATE_EARLY)) {
 
 		timeout = get_dlg_timeout(req);
--- a/src/modules/dialog/dlg_req_within.c
+++ b/src/modules/dialog/dlg_req_within.c
@@ -208,7 +208,7 @@ void bye_reply_cb(struct cell* t, int ty
 				dlg->tag[DLG_CALLER_LEG].len, dlg->tag[DLG_CALLER_LEG].s,
 				dlg->tag[DLG_CALLEE_LEG].len, dlg->tag[DLG_CALLEE_LEG].s);
 		} else if (ret > 0) {
-			LM_WARN("inconsitent dlg timer data on dlg %p [%u:%u] "
+			LM_WARN("inconsistent dlg timer data on dlg %p [%u:%u] "
 				"with clid '%.*s' and tags '%.*s' '%.*s'\n",
 				dlg, dlg->h_entry, dlg->h_id,
 				dlg->callid.len, dlg->callid.s,
--- a/src/modules/dialog/doc/dialog_admin.xml
+++ b/src/modules/dialog/doc/dialog_admin.xml
@@ -2428,9 +2428,9 @@ if(has_totag()) {
 		<para>RPC Command Format:</para>
 		<programlisting  format="linespecific">
 ...
-&kamcmd; dlg.list abcdrssfrs122444@192.168.1.1 AAdfeEFF33
+&kamcmd; dlg.dlg_list abcdrssfrs122444@192.168.1.1 AAdfeEFF33
 ...
-&kamcmd; dlg.list abcdrssfrs122444@192.168.1.1
+&kamcmd; dlg.dlg_list abcdrssfrs122444@192.168.1.1
 ...
 		</programlisting>
 		</section>
--- a/src/modules/dispatcher/README
+++ b/src/modules/dispatcher/README
@@ -10,30 +10,20 @@ Daniel-Constantin Mierla
 
    <miconda@gmail.com>
 
-Edited by
-
 Carsten Bock
 
    ng-voice GmbH
 
-Edited by
-
 Olle E. Johansson
 
    Edvina AB
 
-Edited by
-
 Alessandro Arrichiello
 
    Hewlett Packard
 
-Edited by
-
 Luis Martin
 
-Edited by
-
 Julien Chavanton
 
    <jchavanton@gmail.com>
@@ -1463,7 +1453,7 @@ kamcmd dispatcher.ping_active 0
    Optionally, these fields can be followed by:
      * flags - control the mode of using the destination address and
        sending keepalives. It is a bitwise value that can be built using
-       the folowing flags:
+       the following flags:
           + 1 (bit at index 0 - 1 <<0) - inactive destination
           + 2 (bit at index 1 - 1 <<1) - temporary trying destination (in
             the way to become inactive if it does not reply to keepalives
@@ -1878,48 +1868,48 @@ Chapter 2. Frequently Asked Questions
 
    2.1.
 
-       Does dispatcher provide a fair distribution?
+   Does dispatcher provide a fair distribution?
 
-       The algorithms doing hashing over parts of SIP message don't guarantee
-       a fair distribution. You should do some measurements to decide what
-       hashing algorithm fits better in your environment.
-
-       Other distribution algorithms such as round robin or call load
-       dispatching do a fair distribution in terms of delivered calls to
-       gateways.
+   The algorithms doing hashing over parts of SIP message don't guarantee
+   a fair distribution. You should do some measurements to decide what
+   hashing algorithm fits better in your environment.
+
+   Other distribution algorithms such as round robin or call load
+   dispatching do a fair distribution in terms of delivered calls to
+   gateways.
 
    2.2.
 
-       Is dispatcher dialog stateful?
+   Is dispatcher dialog stateful?
 
-       No. Dispatcher is stateless, although some distribution algorithms are
-       designed to select same destination for subsequent requests of the same
-       dialog (e.g., hashing the call-id).
+   No. Dispatcher is stateless, although some distribution algorithms are
+   designed to select same destination for subsequent requests of the same
+   dialog (e.g., hashing the call-id).
 
    2.3.
 
-       Where can I find more about Kamailio?
+   Where can I find more about Kamailio?
 
-       Take a look at https://www.kamailio.org/.
+   Take a look at https://www.kamailio.org/.
 
    2.4.
 
-       Where can I post a question about this module?
+   Where can I post a question about this module?
 
-       First at all check if your question was already answered on one of our
-       mailing lists:
-         * User Mailing List -
-           https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-users
-         * Developer Mailing List -
-           https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-dev
-
-       E-mails regarding any stable version should be sent to
-       <sr-users@lists.kamailio.org> and e-mail regarding development versions
-       or GIT snapshots should be send to <sr-dev@lists.kamailio.org>.
+   First at all check if your question was already answered on one of our
+   mailing lists:
+     * User Mailing List -
+       https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-users
+     * Developer Mailing List -
+       https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-dev
+
+   E-mails regarding any stable version should be sent to
+   <sr-users@lists.kamailio.org> and e-mail regarding development versions
+   or GIT snapshots should be send to <sr-dev@lists.kamailio.org>.
 
    2.5.
 
-       How can I report a bug?
+   How can I report a bug?
 
-       Please follow the guidelines provided at:
-       https://github.com/kamailio/kamailio/issues
+   Please follow the guidelines provided at:
+   https://github.com/kamailio/kamailio/issues
--- a/src/modules/dispatcher/dispatch.c
+++ b/src/modules/dispatcher/dispatch.c
@@ -2026,6 +2026,7 @@ int ds_manage_routes(sip_msg_t *msg, ds_
 	int i;
 	unsigned int hash;
 	ds_set_t *idx = NULL;
+	int ulast = 0;
 
 	if(msg == NULL) {
 		LM_ERR("bad parameters\n");
@@ -2082,6 +2083,7 @@ int ds_manage_routes(sip_msg_t *msg, ds_
 		case DS_ALG_ROUNDROBIN: /* 4 - round robin */
 			hash = idx->last;
 			idx->last = (idx->last + 1) % idx->nr;
+			ulast = 1;
 			break;
 		case DS_ALG_HASHAUTHUSER: /* 5 - hash auth username */
 			i = ds_hash_authusername(msg, &hash);
@@ -2093,6 +2095,7 @@ int ds_manage_routes(sip_msg_t *msg, ds_
 					/* No Authorization found: Use round robin */
 					hash = idx->last;
 					idx->last = (idx->last + 1) % idx->nr;
+					ulast = 1;
 					break;
 				default:
 					LM_ERR("can't get authorization hash\n");
@@ -2194,6 +2197,11 @@ int ds_manage_routes(sip_msg_t *msg, ds_
 		rstate->emode = 1;
 	}
 
+	/* update last field for next select to point after the current active used */
+	if(ulast) {
+		idx->last = (hash + 1) % idx->nr;
+	}
+
 	LM_DBG("selected [%d-%d-%d/%d] <%.*s>\n", rstate->alg, rstate->setid,
 			rstate->umode, hash,
 			idx->dlist[hash].uri.len, idx->dlist[hash].uri.s);
--- a/src/modules/dispatcher/doc/dispatcher_admin.xml
+++ b/src/modules/dispatcher/doc/dispatcher_admin.xml
@@ -1798,7 +1798,7 @@ DEST: {
 			<listitem>
 			<para>flags - control the mode of using the destination address and
 			sending keepalives. It is a bitwise value that can be built using
-			the folowing flags:
+			the following flags:
 			<itemizedlist>
 				<listitem><para>1 (bit at index 0 - 1 &lt;&lt;0) - inactive destination</para>
 				</listitem>
--- a/src/modules/domain/hash.c
+++ b/src/modules/domain/hash.c
@@ -204,6 +204,7 @@ void hash_table_free(struct domain_list
 			shm_free(ap);
 			ap = next_ap;
 		}
+		shm_free(np);
 		np = np->next;
 	}
 
--- a/src/modules/evapi/evapi_dispatch.c
+++ b/src/modules/evapi/evapi_dispatch.c
@@ -37,6 +37,7 @@
 #include "../../core/dprint.h"
 #include "../../core/ut.h"
 #include "../../core/cfg/cfg_struct.h"
+#include "../../core/receive.h"
 #include "../../core/kemi.h"
 #include "../../core/fmsg.h"
 
@@ -150,8 +151,10 @@ int evapi_run_cfg_route(evapi_env_t *eve
 	if((rt<0) && (_evapi_event_callback.s==NULL || _evapi_event_callback.len<=0))
 		return 0;
 
-	fmsg = faked_msg_next();
-	memcpy(&tmsg, fmsg, sizeof(sip_msg_t));
+	if(faked_msg_get_new(&tmsg)<0) {
+		LM_ERR("failed to get a new faked message\n");
+		return -1;
+	}
 	fmsg = &tmsg;
 	evapi_set_msg_env(fmsg, evenv);
 	backup_rt = get_route_type();
@@ -170,6 +173,9 @@ int evapi_run_cfg_route(evapi_env_t *eve
 	}
 	set_route_type(backup_rt);
 	evapi_set_msg_env(fmsg, NULL);
+	/* free the structure -- it is a clone of faked msg */
+	free_sip_msg(fmsg);
+	ksr_msg_env_reset();
 	return 0;
 }
 
@@ -781,7 +787,11 @@ int _evapi_relay(str *evdata, str *ctag,
 		cfg_update();
 		LM_DBG("dispatching [%p] [%.*s] (%d)\n", emsg,
 				emsg->data.len, emsg->data.s, emsg->data.len);
-		evapi_dispatch_notify(emsg);
+		if(evapi_dispatch_notify(emsg) == 0) {
+			shm_free(emsg);
+			LM_WARN("message not delivered - no client connected\n");
+			return -1;
+		}
 		shm_free(emsg);
 	}
 	return 0;
--- a/src/modules/exec/exec.c
+++ b/src/modules/exec/exec.c
@@ -282,8 +282,11 @@ int exec_avp(struct sip_msg *msg, char *
 
 		i++;
 	}
-	if(i == 0)
+	if(i == 0) {
 		LM_DBG("no result from %s\n", cmd);
+	} else {
+		LM_DBG("%d results from %s\n", i, cmd);
+	}
 	/* success */
 	ret = 1;
 
--- a/src/modules/gzcompress/gzcompress_mod.c
+++ b/src/modules/gzcompress/gzcompress_mod.c
@@ -338,6 +338,7 @@ int gzc_msg_sent(sr_event_param_t *evp)
 	unsigned long olen;
 	unsigned long nlen;
 	int ret;
+	str nbuf = STR_NULL;
 
 	obuf = (str*)evp->data;
 	memset(&msg, 0, sizeof(sip_msg_t));
@@ -383,7 +384,15 @@ int gzc_msg_sent(sr_event_param_t *evp)
 		goto done;
 	}
 
-	obuf->s = gzc_msg_update(&msg, (unsigned int*)&obuf->len);
+	nbuf.s = gzc_msg_update(&msg, (unsigned int*)&nbuf.len);
+	if(nbuf.s!=NULL) {
+		LM_DBG("new outbound buffer generated\n");
+		pkg_free(obuf->s);
+		obuf->s = nbuf.s;
+		obuf->len = nbuf.len;
+	} else {
+		LM_ERR("failed to generate new outbound buffer\n");
+	}
 
 done:
 	free_sip_msg(&msg);
--- a/src/modules/htable/README
+++ b/src/modules/htable/README
@@ -11,14 +11,10 @@ Elena-Ramona Modroiu
 
    <ramona@rosdev.ro>
 
-Edited by
-
 Alex Balashov
 
    <abalashov@evaristesys.com>
 
-Edited by
-
 Ovidiu Sas
 
    <osas@voipembedded.com>
@@ -590,9 +586,14 @@ modparam("htable", "timer_interval", 10)
 
 3.11. db_expires (integer)
 
-   If set to 1, the module will load/save the expires values of the items
+   If set to 1, the module loads/saves the value for expire of the items
    in hash table from/to database. It applies only to hash tables that
-   have the auto-expires attribute defined.
+   have the auto-expires attribute defined. If set to 0, only the key name
+   and the value are loaded, the expires for each item being set to 0.
+
+   Note that the module is not reloading automatically the items from
+   database when they expire, the reloading can be done only via RPC
+   command.
 
    Default value is 0.
 
--- a/src/modules/htable/doc/htable_admin.xml
+++ b/src/modules/htable/doc/htable_admin.xml
@@ -600,9 +600,16 @@ modparam("htable", "timer_interval", 10)
 	<section id="htable.p.db_expires">
 		<title><varname>db_expires</varname> (integer)</title>
 		<para>
-			If set to 1, the module will load/save the expires values of the items in
-			hash table from/to database. It applies only to hash tables that
-			have the auto-expires attribute defined.
+			If set to 1, the module loads/saves the value for expire of
+			the items in hash table from/to database. It applies only to hash
+			tables that have the auto-expires attribute defined. If set to 0,
+			only the key name and the value are loaded, the expires for each
+			item being set to 0.
+		</para>
+		<para>
+			Note that the module is not reloading automatically the items from
+			database when they expire, the reloading can be done only via RPC
+			command.
 		</para>
 		<para>
 		<emphasis>
--- a/src/modules/htable/ht_dmq.c
+++ b/src/modules/htable/ht_dmq.c
@@ -588,11 +588,11 @@ int ht_dmq_handle_sync(srjson_doc_t* jdo
 			if(ht==NULL) {
 				LM_WARN("unable to get table %.*s\n",
 						htname.len, (htname.s)?htname.s:"");
-			}
-
-			if (ht_set_cell_ex(ht, &cname, type, &val, 0, expire - now) < 0) {
-				LM_WARN("unable to set cell %.*s in table %.*s\n",
-						cname.len, cname.s, ht->name.len, ht->name.s);
+			} else {
+				if (ht_set_cell_ex(ht, &cname, type, &val, 0, expire - now) < 0) {
+					LM_WARN("unable to set cell %.*s in table %.*s\n",
+							cname.len, cname.s, ht->name.len, ht->name.s);
+				}
 			}
 		}
 
--- a/src/modules/ims_dialog/dlg_handlers.c
+++ b/src/modules/ims_dialog/dlg_handlers.c
@@ -981,7 +981,7 @@ void dlg_onroute(struct sip_msg* req, st
                     dlg->from_tag.len, dlg->from_tag.s);
 
         } else if (ret > 0) {
-            LM_WARN("inconsitent dlg timer data on dlg %p [%u:%u] "
+            LM_WARN("inconsistent dlg timer data on dlg %p [%u:%u] "
                     "with clid '%.*s' and tags '%.*s' \n",
                     dlg, dlg->h_entry, dlg->h_id,
                     dlg->callid.len, dlg->callid.s,
@@ -1020,7 +1020,7 @@ void dlg_onroute(struct sip_msg* req, st
                     dlg->from_tag.len, dlg->from_tag.s);
 
         } else if (ret > 0) {
-            LM_WARN("inconsitent dlg timer data on dlg %p [%u:%u] "
+            LM_WARN("inconsistent dlg timer data on dlg %p [%u:%u] "
                     "with clid '%.*s' and tags '%.*s' \n",
                     dlg, dlg->h_entry, dlg->h_id,
                     dlg->callid.len, dlg->callid.s,
@@ -1056,7 +1056,7 @@ void dlg_onroute(struct sip_msg* req, st
                     dlg->from_tag.len, dlg->from_tag.s);
 
         } else if (ret > 0) {
-            LM_WARN("inconsitent dlg timer data on dlg %p [%u:%u] "
+            LM_WARN("inconsistent dlg timer data on dlg %p [%u:%u] "
                     "with clid '%.*s' and tags '%.*s' \n",
                     dlg, dlg->h_entry, dlg->h_id,
                     dlg->callid.len, dlg->callid.s,
--- a/src/modules/ims_dialog/dlg_req_within.c
+++ b/src/modules/ims_dialog/dlg_req_within.c
@@ -190,7 +190,7 @@ void bye_reply_cb(struct cell* t, int ty
                     dlg, dlg->h_entry, dlg->h_id,
                     dlg->callid.len, dlg->callid.s);
         } else if (ret > 0) {
-            LM_WARN("inconsitent dlg timer data on dlg %p [%u:%u] "
+            LM_WARN("inconsistent dlg timer data on dlg %p [%u:%u] "
                     "with clid '%.*s'\n",
                     dlg, dlg->h_entry, dlg->h_id,
                     dlg->callid.len, dlg->callid.s);
--- a/src/modules/ims_isc/checker.c
+++ b/src/modules/ims_isc/checker.c
@@ -189,22 +189,30 @@ static int isc_check_session_desc(ims_sp
  */
 static int isc_check_ruri(ims_spt *spt, struct sip_msg *msg) {
 	char buf[256];
+	char buf2[256];
 	regex_t comp;
 
 	if (spt->request_uri.len >= sizeof(buf)) {
-	    LM_ERR("RURI \"%.*s\" is to long to be processed (max %d bytes)\n", spt->request_uri.len, spt->request_uri.s, (int) (sizeof(buf) - 1));
+	    LM_ERR("RURI regexp \"%.*s\" is too long to be compiled (max %d bytes)\n", spt->request_uri.len, spt->request_uri.s, (int) (sizeof(buf) - 1));
+	    return FALSE;
+	}
+
+	if (msg->first_line.u.request.uri.len >= sizeof(buf2)) {
+	    LM_ERR("RURI \"%.*s\" is too long to be processed (max %d bytes)\n", msg->first_line.u.request.uri.len, msg->first_line.u.request.uri.s, (int) (sizeof(buf2) - 1));
 	    return FALSE;
 	}
 
 	/* compile the regex for content */
 	memcpy(buf, spt->request_uri.s, spt->request_uri.len);
 	buf[spt->request_uri.len] = 0;
-	if(regcomp(&(comp), buf, REG_ICASE | REG_EXTENDED) != 0) {
+	if (regcomp(&(comp), buf, REG_ICASE | REG_EXTENDED) != 0) {
 	    LM_ERR("Error compiling the following regexp for RURI content: %.*s\n", spt->request_uri.len, spt->request_uri.s);
 	    return FALSE;
 	}
 
-	if (regexec(&(comp), buf, 0, NULL, 0) == 0) //regex match
+	memcpy(buf2, msg->first_line.u.request.uri.s, msg->first_line.u.request.uri.len);
+	buf2[msg->first_line.u.request.uri.len] = 0;
+	if (regexec(&(comp), buf2, 0, NULL, 0) == 0) //regex match
 	{
 		regfree(&(comp));
 		return TRUE;
--- a/src/modules/ims_registrar_scscf/CxDataType_Rel7.xsd
+++ b/src/modules/ims_registrar_scscf/CxDataType_Rel7.xsd
@@ -1,301 +1,301 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
-	<xs:simpleType name="tPriority" final="list restriction">
-		<xs:restriction base="xs:int">
-			<xs:minInclusive value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tProfilePartIndicator" final="list restriction">
-		<xs:restriction base="xs:unsignedByte">
-			<xs:maxInclusive value="1"/>
-			<xs:enumeration value="0">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">REGISTERED</label>
-						<definition xml:lang="en">iFC is part of the registered profile</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="1">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">UNREGISTERED</label>
-						<definition xml:lang="en">iFC is part of the unregistered profile</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tSharedIFCSetID" final="list restriction">
-		<xs:restriction base="xs:int">
-			<xs:minInclusive value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tGroupID" final="list restriction">
-		<xs:restriction base="xs:int">
-			<xs:minInclusive value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tRegistrationType" final="list restriction">
-		<xs:restriction base="xs:unsignedByte">
-			<xs:maxInclusive value="2"/>
-			<xs:enumeration value="0">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">INITIAL_REGISTRATION</label>
-						<definition xml:lang="en">Matches to REGISTER messages that are related to initial registration</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="1">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">RE-REGISTRATION</label>
-						<definition xml:lang="en">Matches to REGISTER messages that are related to re-registration</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="2">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">DE-REGISTRATION</label>
-						<definition xml:lang="en">Matches to REGISTER messages that are related to de-registration</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tDefaultHandling" final="list restriction">
-		<xs:restriction base="xs:unsignedByte">
-			<xs:maxInclusive value="1"/>
-			<xs:enumeration value="0">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">SESSION_CONTINUED</label>
-						<definition xml:lang="en">Session Continued</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="1">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">SESSION_TERMINATED</label>
-						<definition xml:lang="en">Session Terminated</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tDirectionOfRequest" final="list restriction">
-		<xs:restriction base="xs:unsignedByte">
-			<xs:maxInclusive value="3"/>
-			<xs:enumeration value="0">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">ORIGINATING_SESSION</label>
-						<definition xml:lang="en">Originating Session</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="1">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">TERMINATING_REGISTERED</label>
-						<definition xml:lang="en">Terminating Session for registered user</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="2">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">TERMINATING_UNREGISTERED</label>
-						<definition xml:lang="en">Terminating Session for unregistered user</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="3">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">ORIGINATING_UNREGISTERED</label>
-						<definition xml:lang="en">Originating Session for an unregistered user</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tPrivateID" final="list restriction">
-		<xs:restriction base="xs:anyURI"/>
-	</xs:simpleType>
-	<xs:simpleType name="tSIP_URL" final="list restriction">
-		<xs:restriction base="xs:anyURI"/>
-	</xs:simpleType>
-	<xs:simpleType name="tTEL_URL" final="list restriction">
-		<xs:restriction base="xs:anyURI"/>
-	</xs:simpleType>
-	<xs:simpleType name="tIdentity" final="list restriction">
-		<xs:union memberTypes="tSIP_URL tTEL_URL"/>
-	</xs:simpleType>
-	<xs:simpleType name="tIdentityType" final="list restriction">
-		<xs:restriction base="xs:unsignedByte">
-			<xs:minInclusive value="0"/>
-			<xs:maxInclusive value="2"/>
-			<xs:enumeration value="0">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">PUBLIC_USER_IDENTITY</label>
-						<definition xml:lang="en">Identity is a Public User Identity.</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="1">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">DISTINCT_PSI</label>
-						<definition xml:lang="en">Identity is a distinct Public Service Identity.</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-			<xs:enumeration value="2">
-				<xs:annotation>
-					<xs:documentation>
-						<label xml:lang="en">WILDCARDED_PSI</label>
-						<definition xml:lang="en">Identity matches a wildcarded Public Service Identity.</definition>
-					</xs:documentation>
-				</xs:annotation>
-			</xs:enumeration>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:complexType name="tPublicIdentityExtension">
-		<xs:sequence>
-			<xs:element name="IdentityType" type="tIdentityType" minOccurs="0"/>
-			<xs:element name="WildcardedPSI" type="xs:anyURI" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:simpleType name="tServiceInfo" final="list restriction">
-		<xs:restriction base="xs:string">
-			<xs:minLength value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tString" final="list restriction">
-		<xs:restriction base="xs:string">
-			<xs:minLength value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:simpleType name="tBool">
-		<xs:restriction base="xs:boolean"/>
-	</xs:simpleType>
-	<xs:simpleType name="tSubscribedMediaProfileId" final="list restriction">
-		<xs:restriction base="xs:int">
-			<xs:minInclusive value="0"/>
-		</xs:restriction>
-	</xs:simpleType>
-	<xs:complexType name="tExtension">
-		<xs:sequence>
-			<xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tServiceProfileExtension">
-		<xs:sequence>
-			<xs:element name="SharedIFCSetID" type="tSharedIFCSetID" minOccurs="0" maxOccurs="unbounded"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tSePoTriExtension">
-		<xs:sequence>
-			<xs:element name="RegistrationType" type="tRegistrationType" minOccurs="0" maxOccurs="2"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tIMSSubscription">
-		<xs:sequence>
-			<xs:element name="PrivateID" type="tPrivateID"/>
-			<xs:element name="ServiceProfile" type="tServiceProfile" maxOccurs="unbounded"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tServiceProfile">
-		<xs:sequence>
-			<xs:element name="PublicIdentity" type="tPublicIdentity" maxOccurs="unbounded"/>
-			<xs:element name="CoreNetworkServicesAuthorization" type="tCoreNetworkServicesAuthorization" minOccurs="0"/>
-			<xs:element name="InitialFilterCriteria" type="tInitialFilterCriteria" minOccurs="0" maxOccurs="unbounded"/>
-			<xs:element name="Extension" type="tServiceProfileExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tCoreNetworkServicesAuthorization">
-		<xs:sequence>
-			<xs:element name="SubscribedMediaProfileId" type="tSubscribedMediaProfileId" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tInitialFilterCriteria">
-		<xs:sequence>
-			<xs:element name="Priority" type="tPriority"/>
-			<xs:element name="TriggerPoint" type="tTrigger" minOccurs="0"/>
-			<xs:element name="ApplicationServer" type="tApplicationServer"/>
-			<xs:element name="ProfilePartIndicator" type="tProfilePartIndicator" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tTrigger">
-		<xs:sequence>
-			<xs:element name="ConditionTypeCNF" type="tBool"/>
-			<xs:element name="SPT" type="tSePoTri" maxOccurs="unbounded"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tSePoTri">
-		<xs:sequence>
-			<xs:element name="ConditionNegated" type="tBool" default="0" minOccurs="0"/>
-			<xs:element name="Group" type="tGroupID" maxOccurs="unbounded"/>
-			<xs:choice>
-				<xs:element name="RequestURI" type="tString"/>
-				<xs:element name="Method" type="tString"/>
-				<xs:element name="SIPHeader" type="tHeader"/>
-				<xs:element name="SessionCase" type="tDirectionOfRequest"/>
-				<xs:element name="SessionDescription" type="tSessionDescription"/>
-			</xs:choice>
-			<xs:element name="Extension" type="tSePoTriExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tHeader">
-		<xs:sequence>
-			<xs:element name="Header" type="tString"/>
-			<xs:element name="Content" type="tString" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tSessionDescription">
-		<xs:sequence>
-			<xs:element name="Line" type="tString"/>
-			<xs:element name="Content" type="tString" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tApplicationServer">
-		<xs:sequence>
-			<xs:element name="ServerName" type="tSIP_URL"/>
-			<xs:element name="DefaultHandling" type="tDefaultHandling" minOccurs="0"/>
-			<xs:element name="ServiceInfo" type="tServiceInfo" minOccurs="0"/>
-			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:complexType name="tPublicIdentity">
-		<xs:sequence>
-			<xs:element name="BarringIndication" type="tBool" default="0" minOccurs="0"/>
-			<xs:element name="Identity" type="tIdentity"/>
-			<xs:element name="Extension" type="tPublicIdentityExtension" minOccurs="0"/>
-			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
-		</xs:sequence>
-	</xs:complexType>
-	<xs:element name="IMSSubscription" type="tIMSSubscription"/>
-</xs:schema>
+<?xml version="1.0" encoding="UTF-8"?>
+<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified">
+	<xs:simpleType name="tPriority" final="list restriction">
+		<xs:restriction base="xs:int">
+			<xs:minInclusive value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tProfilePartIndicator" final="list restriction">
+		<xs:restriction base="xs:unsignedByte">
+			<xs:maxInclusive value="1"/>
+			<xs:enumeration value="0">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">REGISTERED</label>
+						<definition xml:lang="en">iFC is part of the registered profile</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="1">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">UNREGISTERED</label>
+						<definition xml:lang="en">iFC is part of the unregistered profile</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tSharedIFCSetID" final="list restriction">
+		<xs:restriction base="xs:int">
+			<xs:minInclusive value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tGroupID" final="list restriction">
+		<xs:restriction base="xs:int">
+			<xs:minInclusive value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tRegistrationType" final="list restriction">
+		<xs:restriction base="xs:unsignedByte">
+			<xs:maxInclusive value="2"/>
+			<xs:enumeration value="0">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">INITIAL_REGISTRATION</label>
+						<definition xml:lang="en">Matches to REGISTER messages that are related to initial registration</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="1">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">RE-REGISTRATION</label>
+						<definition xml:lang="en">Matches to REGISTER messages that are related to re-registration</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="2">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">DE-REGISTRATION</label>
+						<definition xml:lang="en">Matches to REGISTER messages that are related to de-registration</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tDefaultHandling" final="list restriction">
+		<xs:restriction base="xs:unsignedByte">
+			<xs:maxInclusive value="1"/>
+			<xs:enumeration value="0">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">SESSION_CONTINUED</label>
+						<definition xml:lang="en">Session Continued</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="1">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">SESSION_TERMINATED</label>
+						<definition xml:lang="en">Session Terminated</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tDirectionOfRequest" final="list restriction">
+		<xs:restriction base="xs:unsignedByte">
+			<xs:maxInclusive value="3"/>
+			<xs:enumeration value="0">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">ORIGINATING_SESSION</label>
+						<definition xml:lang="en">Originating Session</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="1">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">TERMINATING_REGISTERED</label>
+						<definition xml:lang="en">Terminating Session for registered user</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="2">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">TERMINATING_UNREGISTERED</label>
+						<definition xml:lang="en">Terminating Session for unregistered user</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="3">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">ORIGINATING_UNREGISTERED</label>
+						<definition xml:lang="en">Originating Session for an unregistered user</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tPrivateID" final="list restriction">
+		<xs:restriction base="xs:anyURI"/>
+	</xs:simpleType>
+	<xs:simpleType name="tSIP_URL" final="list restriction">
+		<xs:restriction base="xs:anyURI"/>
+	</xs:simpleType>
+	<xs:simpleType name="tTEL_URL" final="list restriction">
+		<xs:restriction base="xs:anyURI"/>
+	</xs:simpleType>
+	<xs:simpleType name="tIdentity" final="list restriction">
+		<xs:union memberTypes="tSIP_URL tTEL_URL"/>
+	</xs:simpleType>
+	<xs:simpleType name="tIdentityType" final="list restriction">
+		<xs:restriction base="xs:unsignedByte">
+			<xs:minInclusive value="0"/>
+			<xs:maxInclusive value="2"/>
+			<xs:enumeration value="0">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">PUBLIC_USER_IDENTITY</label>
+						<definition xml:lang="en">Identity is a Public User Identity.</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="1">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">DISTINCT_PSI</label>
+						<definition xml:lang="en">Identity is a distinct Public Service Identity.</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+			<xs:enumeration value="2">
+				<xs:annotation>
+					<xs:documentation>
+						<label xml:lang="en">WILDCARDED_PSI</label>
+						<definition xml:lang="en">Identity matches a wildcarded Public Service Identity.</definition>
+					</xs:documentation>
+				</xs:annotation>
+			</xs:enumeration>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="tPublicIdentityExtension">
+		<xs:sequence>
+			<xs:element name="IdentityType" type="tIdentityType" minOccurs="0"/>
+			<xs:element name="WildcardedPSI" type="xs:anyURI" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:simpleType name="tServiceInfo" final="list restriction">
+		<xs:restriction base="xs:string">
+			<xs:minLength value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tString" final="list restriction">
+		<xs:restriction base="xs:string">
+			<xs:minLength value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:simpleType name="tBool">
+		<xs:restriction base="xs:boolean"/>
+	</xs:simpleType>
+	<xs:simpleType name="tSubscribedMediaProfileId" final="list restriction">
+		<xs:restriction base="xs:int">
+			<xs:minInclusive value="0"/>
+		</xs:restriction>
+	</xs:simpleType>
+	<xs:complexType name="tExtension">
+		<xs:sequence>
+			<xs:any processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tServiceProfileExtension">
+		<xs:sequence>
+			<xs:element name="SharedIFCSetID" type="tSharedIFCSetID" minOccurs="0" maxOccurs="unbounded"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tSePoTriExtension">
+		<xs:sequence>
+			<xs:element name="RegistrationType" type="tRegistrationType" minOccurs="0" maxOccurs="2"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tIMSSubscription">
+		<xs:sequence>
+			<xs:element name="PrivateID" type="tPrivateID"/>
+			<xs:element name="ServiceProfile" type="tServiceProfile" maxOccurs="unbounded"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tServiceProfile">
+		<xs:sequence>
+			<xs:element name="PublicIdentity" type="tPublicIdentity" maxOccurs="unbounded"/>
+			<xs:element name="CoreNetworkServicesAuthorization" type="tCoreNetworkServicesAuthorization" minOccurs="0"/>
+			<xs:element name="InitialFilterCriteria" type="tInitialFilterCriteria" minOccurs="0" maxOccurs="unbounded"/>
+			<xs:element name="Extension" type="tServiceProfileExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tCoreNetworkServicesAuthorization">
+		<xs:sequence>
+			<xs:element name="SubscribedMediaProfileId" type="tSubscribedMediaProfileId" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tInitialFilterCriteria">
+		<xs:sequence>
+			<xs:element name="Priority" type="tPriority"/>
+			<xs:element name="TriggerPoint" type="tTrigger" minOccurs="0"/>
+			<xs:element name="ApplicationServer" type="tApplicationServer"/>
+			<xs:element name="ProfilePartIndicator" type="tProfilePartIndicator" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tTrigger">
+		<xs:sequence>
+			<xs:element name="ConditionTypeCNF" type="tBool"/>
+			<xs:element name="SPT" type="tSePoTri" maxOccurs="unbounded"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tSePoTri">
+		<xs:sequence>
+			<xs:element name="ConditionNegated" type="tBool" default="0" minOccurs="0"/>
+			<xs:element name="Group" type="tGroupID" maxOccurs="unbounded"/>
+			<xs:choice>
+				<xs:element name="RequestURI" type="tString"/>
+				<xs:element name="Method" type="tString"/>
+				<xs:element name="SIPHeader" type="tHeader"/>
+				<xs:element name="SessionCase" type="tDirectionOfRequest"/>
+				<xs:element name="SessionDescription" type="tSessionDescription"/>
+			</xs:choice>
+			<xs:element name="Extension" type="tSePoTriExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tHeader">
+		<xs:sequence>
+			<xs:element name="Header" type="tString"/>
+			<xs:element name="Content" type="tString" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tSessionDescription">
+		<xs:sequence>
+			<xs:element name="Line" type="tString"/>
+			<xs:element name="Content" type="tString" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tApplicationServer">
+		<xs:sequence>
+			<xs:element name="ServerName" type="tSIP_URL"/>
+			<xs:element name="DefaultHandling" type="tDefaultHandling" minOccurs="0"/>
+			<xs:element name="ServiceInfo" type="tServiceInfo" minOccurs="0"/>
+			<xs:element name="Extension" type="tExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:complexType name="tPublicIdentity">
+		<xs:sequence>
+			<xs:element name="BarringIndication" type="tBool" default="0" minOccurs="0"/>
+			<xs:element name="Identity" type="tIdentity"/>
+			<xs:element name="Extension" type="tPublicIdentityExtension" minOccurs="0"/>
+			<xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
+		</xs:sequence>
+	</xs:complexType>
+	<xs:element name="IMSSubscription" type="tIMSSubscription"/>
+</xs:schema>
--- a/src/modules/ims_registrar_scscf/README
+++ b/src/modules/ims_registrar_scscf/README
@@ -1,4 +1,4 @@
-IMS Usrloc PCSCF Module
+IMS Registrar SCSCF Module
 
 Jason Penton
 
@@ -810,28 +810,28 @@ Chapter 2. Frequently Asked Questions
 
    2.1.
 
-       Where can I find more about Kamailio?
+   Where can I find more about Kamailio?
 
-       Take a look at https://www.kamailio.org/.
+   Take a look at https://www.kamailio.org/.
 
    2.2.
 
-       Where can I post a question about this module?
+   Where can I post a question about this module?
 
-       First at all check if your question was already answered on one of our
-       mailing lists:
-         * User Mailing List -
-           https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-users
-         * Developer Mailing List -
-           https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-dev
-
-       E-mails regarding any stable Kamailio release should be sent to
-       <sr-users@lists.kamailio.org> and e-mails regarding development
-       versions should be sent to <sr-dev@lists.kamailio.org>.
+   First at all check if your question was already answered on one of our
+   mailing lists:
+     * User Mailing List -
+       https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-users
+     * Developer Mailing List -
+       https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-dev
+
+   E-mails regarding any stable Kamailio release should be sent to
+   <sr-users@lists.kamailio.org> and e-mails regarding development
+   versions should be sent to <sr-dev@lists.kamailio.org>.
 
    2.3.
 
-       How can I report a bug?
+   How can I report a bug?
 
-       Please follow the guidelines provided at:
-       https://github.com/kamailio/kamailio/issues.
+   Please follow the guidelines provided at:
+   https://github.com/kamailio/kamailio/issues.
--- a/src/modules/ims_registrar_scscf/doc/ims_registrar_scscf.xml
+++ b/src/modules/ims_registrar_scscf/doc/ims_registrar_scscf.xml
@@ -7,7 +7,7 @@
 ]>
 <book>
   <bookinfo>
-    <title>IMS Usrloc PCSCF Module</title>
+    <title>IMS Registrar SCSCF Module</title>
 
     <productname class="trade">&kamailioname;</productname>
 
--- /dev/null
+++ b/src/modules/ims_usrloc_scscf/README
@@ -0,0 +1,434 @@
+IMS Usrloc SCSCF Module
+
+Jason Penton
+
+   Smile Communications
+
+Edited by
+
+Richard Good
+
+   Smile Communications
+
+Yasin Caner
+
+   Copyright © 2012 Smile Communications
+     __________________________________________________________________
+
+   Table of Contents
+
+   1. Admin Guide
+
+        1. Overview
+        2. Dependencies
+
+              2.1. Kamailio Modules
+
+        3. Parameters
+
+              3.1. db_url (string)
+              3.2. db_mode (string)
+              3.3. maxcontact (int)
+              3.4. maxcontact_3gpp (int)
+              3.5. maxcontact_behaviour (int)
+              3.6. max_subscribes(int)
+              3.7. sub_dialog_hash_size(int)
+              3.8. timer_procs(int)
+              3.9. timer_interval (int)
+              3.10. desc_time_order (int)
+              3.11. matching_mode (int)
+              3.12. cseq_delay (int)
+              3.13. fetch_rows(int)
+              3.14. hash_size (string)
+              3.15. subs_hash_size (int)
+              3.16. contacts_hash_size (integer)
+              3.17. nat_bflag (integer)
+              3.18. contact_delete_delay (int)
+              3.19. support_wildcardPSI (int)
+              3.20. unreg_validity (int)
+              3.21. user_data_xsd (string)
+
+        4. RPC Commands
+
+              4.1. ulscscf.status
+              4.2. ulscscf.showimpu
+              4.3. ulscscf.snapshot
+
+   2. Frequently Asked Questions
+
+   List of Examples
+
+   1.1. Set db_urlparameter
+   1.2. Set db_mode(int)
+   1.3. Set maxcontactparameter
+   1.4. Set maxcontact_3gppparameter
+   1.5. Set maxcontact_behaviour parameter
+   1.6. Set subscription_expires_rangeparameter
+   1.7. Setsub_dialog_hash_sizeparameter
+   1.8. Settimer_procsparameter
+   1.9. Set timer_intervalparameter
+   1.10. Set desc_time_orderparameter
+   1.11. Set matching_modeparameter
+   1.12. Set scscf_nameparameter
+   1.13. Set fetch_rowsparameter
+   1.14. Set hash_sizeparameter
+   1.15. Set subs_hash_sizeparameter
+   1.16. Set contacts_hash_sizeparameter
+   1.17. Set nat_bflagparameter
+   1.18. Set contact_delete_delayparameter
+   1.19. Set support_wildcardPSI parameter
+   1.20. Set unreg_validity parameter
+   1.21. Set unreg_validity parameter
+
+Chapter 1. Admin Guide
+
+   Table of Contents
+
+   1. Overview
+   2. Dependencies
+
+        2.1. Kamailio Modules
+
+   3. Parameters
+
+        3.1. db_url (string)
+        3.2. db_mode (string)
+        3.3. maxcontact (int)
+        3.4. maxcontact_3gpp (int)
+        3.5. maxcontact_behaviour (int)
+        3.6. max_subscribes(int)
+        3.7. sub_dialog_hash_size(int)
+        3.8. timer_procs(int)
+        3.9. timer_interval (int)
+        3.10. desc_time_order (int)
+        3.11. matching_mode (int)
+        3.12. cseq_delay (int)
+        3.13. fetch_rows(int)
+        3.14. hash_size (string)
+        3.15. subs_hash_size (int)
+        3.16. contacts_hash_size (integer)
+        3.17. nat_bflag (integer)
+        3.18. contact_delete_delay (int)
+        3.19. support_wildcardPSI (int)
+        3.20. unreg_validity (int)
+        3.21. user_data_xsd (string)
+
+   4. RPC Commands
+
+        4.1. ulscscf.status
+        4.2. ulscscf.showimpu
+        4.3. ulscscf.snapshot
+
+1. Overview
+
+   This module serves as a storage engine for SCSCF contacts, much like
+   the standard Kamailio module that is usrloc, is a storage engine for
+   standard SIP contacts.
+
+2. Dependencies
+
+   2.1. Kamailio Modules
+
+2.1. Kamailio Modules
+
+   The following modules must be loaded before this module:
+     * TM
+     * Presence
+     * IMS dialog
+
+3. Parameters
+
+   3.1. db_url (string)
+   3.2. db_mode (string)
+   3.3. maxcontact (int)
+   3.4. maxcontact_3gpp (int)
+   3.5. maxcontact_behaviour (int)
+   3.6. max_subscribes(int)
+   3.7. sub_dialog_hash_size(int)
+   3.8. timer_procs(int)
+   3.9. timer_interval (int)
+   3.10. desc_time_order (int)
+   3.11. matching_mode (int)
+   3.12. cseq_delay (int)
+   3.13. fetch_rows(int)
+   3.14. hash_size (string)
+   3.15. subs_hash_size (int)
+   3.16. contacts_hash_size (integer)
+   3.17. nat_bflag (integer)
+   3.18. contact_delete_delay (int)
+   3.19. support_wildcardPSI (int)
+   3.20. unreg_validity (int)
+   3.21. user_data_xsd (string)
+
+3.1. db_url (string)
+
+   database URL for storing impu/contacts records
+
+   Example 1.1. Set db_urlparameter
+        modparam("ims_usrloc_scscf", "db_url", "mysql//username:password@localho
+st/scscf")
+
+3.2. db_mode (string)
+
+   This is the database mode to be used for the SCSCF usrloc data
+   persistent storage. Currently this module supports the Write-Back
+   scheme only.
+     * 0 - This disables database completely. Only memory will be used.
+       Contacts will not survive restart.
+     * 1 - Write-Backend scheme. All changes are made to memory and
+       database synchronization is done in the timer
+
+   Default value is 0.
+
+   Example 1.2. Set db_mode(int)
+...
+        modparam("ims_usrloc_scscf", "db_mode", 1)
+
+3.3. maxcontact (int)
+
+   The parameter can be used to limit the number of contact for each impu
+
+   Default value is 0(max)
+
+   Example 1.3. Set maxcontactparameter
+...
+        modparam("ims_usrloc_scscf", "maxcontact", 10)
+
+3.4. maxcontact_3gpp (int)
+
+   The parameter can be used to limit the number of 3GPP contact for each
+   impu
+
+   Default value is 0.(max)
+
+   Example 1.4. Set maxcontact_3gppparameter
+...
+        modparam("ims_usrloc_scscf", "maxcontact_3gpp", 0)
+
+3.5. maxcontact_behaviour (int)
+
+   Behaviour of usrloc , after impu reach max contacts limit.
+     * 0 - Disabled
+     * 1 - Reject after reaching limit.
+     * 2 - Overwrite
+
+   Default value is 0.
+
+   Example 1.5. Set maxcontact_behaviour parameter
+...
+        modparam("ims_usrloc_scscf", "maxcontact_behaviour", 2)
+
+3.6. max_subscribes(int)
+
+   Max number of subscribes allowed per watcher for each IMPU
+
+   Default value is 0.
+
+   Example 1.6. Set subscription_expires_rangeparameter
+...
+        modparam("ims_usrloc_scscf", "max_subscribes", 2)
+
+3.7. sub_dialog_hash_size(int)
+
+   Subscriber dialog hash table size
+
+   Default value is 10.
+
+   Example 1.7. Setsub_dialog_hash_sizeparameter
+...
+        modparam("ims_usrloc_scscf", "sub_dialog_hash_size", 512)
+
+3.8. timer_procs(int)
+
+   process number of handling registeration
+
+   Default value is 0
+
+   Example 1.8. Settimer_procsparameter
+...
+        modparam("ims_usrloc_scscf", "timer_procs", 5)
+
+3.9. timer_interval (int)
+
+   Number of seconds between two timer runs. The module uses a timer to
+   delete expired contacts, synchronize with database and other tasks,
+   that need to be run periodically
+
+   Default value is 90
+
+   Example 1.9. Set timer_intervalparameter
+...
+        modparam("ims_usrloc_scscf", "timer_interval", 120)
+
+3.10. desc_time_order (int)
+
+   If the user's contacts should be kept timestamp ordered; otherwise the
+   contact will be ordered based on q value. Non 0 value means true.
+
+   Default value is timestamp ordering not enabled
+
+   Example 1.10. Set desc_time_orderparameter
+...
+        modparam("ims_usrloc_scscf", "desc_time_order", 1)
+
+3.11. matching_mode (int)
+
+   What contact matching algorithm to be used.
+     * 0 - Contact Only matching
+     * 1 - Contact and Callid Matching
+     * 2 - Contact and Path header matching
+     * 3 - Only contact IP and Port Matching
+
+   Default value is 0.
+
+   Example 1.11. Set matching_modeparameter
+...
+        modparam("ims_usrloc_scscf", "matching_mode", 0)
+
+3.12. cseq_delay (int)
+
+   Delay (in seconds) for accepting as retransmissions register requests
+   with same Call-ID and Cseq.
+
+   Default value is 20.
+
+   Example 1.12. Set scscf_nameparameter
+...
+        modparam("ims_usrloc_scscf", "cseq_delay", 20)
+
+3.13. fetch_rows(int)
+
+   The number of the rows to be fetched at once from database when loading
+   the location records.
+
+   Default value is 2000.
+
+   Example 1.13. Set fetch_rowsparameter
+...
+        modparam("ims_usrloc_scscf", "fetch_rows", 3000)
+
+3.14. hash_size (string)
+
+   The number of entries of the hash table used by usrloc
+
+   Default value 512
+
+   Example 1.14. Set hash_sizeparameter
+...
+        modparam("ims_usrloc_scscf", "hash_size", 512)
+
+3.15. subs_hash_size (int)
+
+   The number of entries of the hash table used by usrloc to store the ims
+   subscribe records
+
+   Default value 512
+
+   Example 1.15. Set subs_hash_sizeparameter
+...
+        modparam("ims_usrloc_scscf", "subs_hash_size", 512)
+
+3.16. contacts_hash_size (integer)
+
+   The number of entries of the hash table used by usrloc to store the
+   contact records
+
+   Default value is 512
+
+   Example 1.16. Set contacts_hash_sizeparameter
+...
+        modparam("ims_usrloc_scscf", "contacts_hash_size", 512)
+
+3.17. nat_bflag (integer)
+
+   NAT marker to handle natted registration
+
+   Default value is 0
+
+   Example 1.17. Set nat_bflagparameter
+        modparam("ims_usrloc_scscf", "nat_bflag", 3)
+
+3.18. contact_delete_delay (int)
+
+   If contact is put into delay delete state ,this is how long we delay
+   before deleting
+
+   Default value is 30
+
+   Example 1.18. Set contact_delete_delayparameter
+        modparam("ims_usrloc_scscf", "contact_delete_delay", 32)
+
+3.19. support_wildcardPSI (int)
+
+   Wildcard Public-Service-Identity (RFC5002). it will be actived by
+   setting 1
+
+   Default value is 0.(disabled)
+
+   Example 1.19. Set support_wildcardPSI parameter
+        modparam("ims_usrloc_scscf", "support_wildcardPSI", 0)
+
+3.20. unreg_validity (int)
+
+   Default validity time in seconds for unregister assignment to SCSCF
+
+   Default value is 1800
+
+   Example 1.20. Set unreg_validity parameter
+        modparam("ims_usrloc_scscf", "unreg_validity", 0)
+
+3.21. user_data_xsd (string)
+
+   Default value is 1800
+
+   Example 1.21. Set unreg_validity parameter
+        modparam("ims_usrloc_scscf", "user_data_xsd", "/usr/local/etc/kamailio/C
+xDataType_Rel6.xsd")
+
+4. RPC Commands
+
+   4.1. ulscscf.status
+   4.2. ulscscf.showimpu
+   4.3. ulscscf.snapshot
+
+   Exported RPC commands.
+
+4.1. ulscscf.status
+
+4.2. ulscscf.showimpu
+
+4.3. ulscscf.snapshot
+
+Chapter 2. Frequently Asked Questions
+
+   2.1. Where can I find more about Kamailio?
+   2.2. Where can I post a question about this module?
+   2.3. How can I report a bug?
+
+   2.1.
+
+   Where can I find more about Kamailio?
+
+   Take a look at https://www.kamailio.org/.
+
+   2.2.
+
+   Where can I post a question about this module?
+
+   First at all check if your question was already answered on one of our
+   mailing lists:
+     * User Mailing List -
+       https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-users
+     * Developer Mailing List -
+       https://lists.kamailio.org/cgi-bin/mailman/listinfo/sr-dev
+
+   E-mails regarding any stable Kamailio release should be sent to
+   <sr-users@lists.kamailio.org> and e-mails regarding development
+   versions should be sent to <sr-dev@lists.kamailio.org>.
+
+   2.3.
+
+   How can I report a bug?
+
+   Please follow the guidelines provided at:
+   https://github.com/kamailio/kamailio/issues.
--- a/src/modules/janssonrpcc/unit_tests/Makefile
+++ b/src/modules/janssonrpcc/unit_tests/Makefile
@@ -1,11 +1,11 @@
-CC = gcc
-FILES = *.c ../netstring.c ../jsonrpc_global.c seatest/seatest.c
-OUT_EXE = test
-
-build: $(FILES)
-	$(CC) -std=gnu99 -pedantic -D TEST -o $(OUT_EXE) $(FILES) -lm -levent
-
-clean:
-	rm -f *.o core
-
-rebuild: clean build
+CC = gcc
+FILES = *.c ../netstring.c ../jsonrpc_global.c seatest/seatest.c
+OUT_EXE = test
+
+build: $(FILES)
+	$(CC) -std=gnu99 -pedantic -D TEST -o $(OUT_EXE) $(FILES) -lm -levent
+
+clean:
+	rm -f *.o core
+
+rebuild: clean build
--- a/src/modules/janssonrpcc/unit_tests/seatest/license.txt
+++ b/src/modules/janssonrpcc/unit_tests/seatest/license.txt
@@ -1,19 +1,19 @@
- Copyright (c) 2010 Keith Nicholas
-
- Permission is hereby granted, free of charge, to any person obtaining a copy
- of this software and associated documentation files (the "Software"), to deal
- in the Software without restriction, including without limitation the rights
- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- copies of the Software, and to permit persons to whom the Software is
- furnished to do so, subject to the following conditions:
-
- The above copyright notice and this permission notice shall be included in
- all copies or substantial portions of the Software.
-
- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+ Copyright (c) 2010 Keith Nicholas
+
+ Permission is hereby granted, free of charge, to any person obtaining a copy
+ of this software and associated documentation files (the "Software"), to deal
+ in the Software without restriction, including without limitation the rights
+ to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ copies of the Software, and to permit persons to whom the Software is
+ furnished to do so, subject to the following conditions:
+
+ The above copyright notice and this permission notice shall be included in
+ all copies or substantial portions of the Software.
+
+ THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
\ No newline at end of file
--- a/src/modules/janssonrpcc/unit_tests/seatest/seatest.c
+++ b/src/modules/janssonrpcc/unit_tests/seatest/seatest.c
@@ -1,248 +1,248 @@
-#include "seatest.h"
-#include <string.h>
-#ifdef WIN32
-#include <conio.h>
-#include "windows.h"
-#else
-unsigned int GetTickCount() { return 0;}
-void _getch( void ) { }
-#endif
-
-static int sea_tests_run = 0;
-static int sea_tests_passed = 0;
-static int sea_tests_failed = 0;
-static char* seatest_current_fixture;
-
-static void (*seatest_suite_setup_func)( void ) = 0;
-static void (*seatest_suite_teardown_func)( void ) = 0;
-static void (*seatest_fixture_setup)( void ) = 0;
-static void (*seatest_fixture_teardown)( void ) = 0;
-
-
-
-void suite_setup(void (*setup)( void ))
-{
-	seatest_suite_setup_func = setup;
-}
-void suite_teardown(void (*teardown)( void ))
-{
-	seatest_suite_teardown_func = teardown;
-}
-
-void seatest_suite_setup( void )
-{
-	if(seatest_suite_setup_func != 0) seatest_suite_setup_func();
-}
-
-void seatest_suite_teardown( void )
-{
-	if(seatest_suite_teardown_func != 0) seatest_suite_teardown_func();
-}
-
-void fixture_setup(void (*setup)( void ))
-{
-	seatest_fixture_setup = setup;
-}
-void fixture_teardown(void (*teardown)( void ))
-{
-	seatest_fixture_teardown = teardown;
-}
-
-void seatest_setup( void )
-{
-	if(seatest_fixture_setup != 0) seatest_fixture_setup();
-}
-
-void seatest_teardown( void )
-{
-	if(seatest_fixture_teardown != 0) seatest_fixture_teardown();
-}
-
-char* test_file_name(char* path)
-{
-	char* file = path + strlen(path);
-	while(file != path && *file!= '\\' ) file--;
-	if(*file == '\\') file++;
-	return file;
-}
-
-static int seatest_fixture_tests_run;
-static int seatest_fixture_tests_failed;
-
-void seatest_simple_test_result(int passed, char* reason, const char* function, unsigned int line)
-{
-	if (!passed)
-	{
-		printf("%-20s Line %-5d %s\r\n", function, line, reason );
-		sea_tests_failed++; 
-	}
-	else
-	{
-		sea_tests_passed++; 
-	}	
-}
-
-void seatest_assert_true(int test, const char* function, unsigned int line)
-{
-	seatest_simple_test_result(test, "Should of been true", function, line);
-
-}
-
-void seatest_assert_false(int test, const char* function, unsigned int line)
-{
-	seatest_simple_test_result(!test, "Should of been false", function, line);	
-}
-
-
-void seatest_assert_int_equal(int expected, int actual, const char* function, unsigned int line)
-{
-	char s[SEATEST_PRINT_BUFFER_SIZE];
-	sprintf(s, "Expected %d but was %d", expected, actual);
-	seatest_simple_test_result(expected==actual, s, function, line);	
-}
-
-void seatest_assert_ulong_equal(unsigned long expected, unsigned long actual, const char* function, unsigned int line)
-{
-	char s[SEATEST_PRINT_BUFFER_SIZE];
-	sprintf(s, "Expected %lu but was %lu", expected, actual);
-	seatest_simple_test_result(expected==actual, s, function, line);	
-}
-
-void seatest_assert_float_equal( float expected, float actual, float delta, const char* function, unsigned int line )
-{
-	char s[SEATEST_PRINT_BUFFER_SIZE];
-	float result = expected-actual;
-	sprintf(s, "Expected %f but was %f", expected, actual);
-	if(result < 0.0) result = 0.0f - result;
-	seatest_simple_test_result( result <= delta, s, function, line);	
-}
-
-void seatest_assert_double_equal( double expected, double actual, double delta, const char* function, unsigned int line )
-{
-	char s[SEATEST_PRINT_BUFFER_SIZE];
-	double result = expected-actual;
-	sprintf(s, "Expected %f but was %f", expected, actual);
-	if(result < 0.0) result = 0.0 - result;
-	seatest_simple_test_result( result <= delta, s, function, line);	
-}
-
-void seatest_assert_string_equal(char* expected, char* actual, const char* function, unsigned int line)
-{
-	char s[SEATEST_PRINT_BUFFER_SIZE];
-	sprintf(s, "Expected %s but was %s", expected, actual);
-	seatest_simple_test_result(strcmp(expected, actual)==0, s, function, line);	
-}
-
-void seatest_assert_string_ends_with(char* expected, char* actual, const char* function, unsigned int line)
-{
-	char s[SEATEST_PRINT_BUFFER_SIZE];
-	sprintf(s, "Expected %s to end with %s", actual, expected);
-	seatest_simple_test_result(strcmp(expected, actual+(strlen(actual)-strlen(expected)))==0, s, function, line);	
-}
-
-void seatest_assert_string_starts_with(char* expected, char* actual, const char* function, unsigned int line)
-{
-	char s[SEATEST_PRINT_BUFFER_SIZE];
-	sprintf(s, "Expected %s to start with %s", actual, expected);
-	seatest_simple_test_result(strncmp(expected, actual, strlen(expected))==0, s, function, line);	
-}
-
-void seatest_assert_string_contains(char* expected, char* actual, const char* function, unsigned int line)
-{
-	char s[SEATEST_PRINT_BUFFER_SIZE];
-	sprintf(s, "Expected %s to be in %s", expected, actual);
-	seatest_simple_test_result(strstr(actual, expected)!=0, s, function, line);	
-}
-
-void seatest_assert_string_doesnt_contain(char* expected, char* actual, const char* function, unsigned int line)
-{
-	char s[SEATEST_PRINT_BUFFER_SIZE];
-	sprintf(s, "Expected %s not to have %s in it", actual, expected);
-	seatest_simple_test_result(strstr(actual, expected)==0, s, function, line);	
-}
-
-void seatest_run_test(void)
-{
-	sea_tests_run++; 
-}
-
-void seatest_header_printer(char* s, int length, char f)
-{
-	int l = strlen(s);
-	int d = (length- (l + 2)) / 2;
-	int i;
-	for(i = 0; i<d; i++) printf("%c",f);
-	printf(" %s ", s);
-	for(i = (d+l+2); i<length; i++) printf("%c",f);
-	printf("\r\n");
-}
-
-
-void seatest_test_fixture_start(char* filepath)
-{
-	seatest_current_fixture = test_file_name(filepath);
-	seatest_header_printer(seatest_current_fixture, 50, '-');
-	seatest_fixture_tests_failed = sea_tests_failed;
-	seatest_fixture_tests_run = sea_tests_run;
-	seatest_fixture_teardown = 0;
-	seatest_fixture_setup = 0;
-}
-
-void seatest_test_fixture_end()
-{
-	char s[SEATEST_PRINT_BUFFER_SIZE];
-	sprintf(s, "%d run  %d failed", sea_tests_run-seatest_fixture_tests_run, sea_tests_failed-seatest_fixture_tests_failed);
-	seatest_header_printer(s, 50, ' ');
-	printf("\r\n");
-}
-
-static char* seatest_fixture_filter = 0;
-static char* seatest_test_filter = 0;
-
-void fixture_filter(char* filter)
-{
-	seatest_fixture_filter = filter;
-}
-
-
-void test_filter(char* filter)
-{
-	seatest_test_filter = filter;
-}
-
-
-int seatest_should_run( char* fixture, char* test)
-{
-	int run = 1;
-	if(seatest_fixture_filter) 
-	{
-		if(strncmp(seatest_fixture_filter, fixture, strlen(seatest_fixture_filter)) != 0) run = 0;
-	}
-	if(seatest_test_filter) 
-	{
-		if(strncmp(seatest_test_filter, test, strlen(seatest_test_filter)) != 0) run = 0;
-	}
-	return run;
-}
-
-int run_tests(void (*tests)(void))
-{
-	unsigned long end;
-	unsigned long start = GetTickCount();
-	tests();	 
-	end = GetTickCount();
-	printf("\r\n\r\n==================SEATEST v%s====================\r\n\r\n", SEATEST_VERSION);	 
-	if (sea_tests_failed > 0) {
-		printf("                      Failed\r\n");			
-	}
-	else {
-		printf("               ALL TESTS PASSED\r\n");
-	}
-	printf("                 %d tests run\r\n", sea_tests_run);
-	printf("                    in %lu ms\r\n",end - start);
-	printf("==================================================\r\n");
-
-	_getch();
-	return sea_tests_failed == 0;
-}
-
+#include "seatest.h"
+#include <string.h>
+#ifdef WIN32
+#include <conio.h>
+#include "windows.h"
+#else
+unsigned int GetTickCount() { return 0;}
+void _getch( void ) { }
+#endif
+
+static int sea_tests_run = 0;
+static int sea_tests_passed = 0;
+static int sea_tests_failed = 0;
+static char* seatest_current_fixture;
+
+static void (*seatest_suite_setup_func)( void ) = 0;
+static void (*seatest_suite_teardown_func)( void ) = 0;
+static void (*seatest_fixture_setup)( void ) = 0;
+static void (*seatest_fixture_teardown)( void ) = 0;
+
+
+
+void suite_setup(void (*setup)( void ))
+{
+	seatest_suite_setup_func = setup;
+}
+void suite_teardown(void (*teardown)( void ))
+{
+	seatest_suite_teardown_func = teardown;
+}
+
+void seatest_suite_setup( void )
+{
+	if(seatest_suite_setup_func != 0) seatest_suite_setup_func();
+}
+
+void seatest_suite_teardown( void )
+{
+	if(seatest_suite_teardown_func != 0) seatest_suite_teardown_func();
+}
+
+void fixture_setup(void (*setup)( void ))
+{
+	seatest_fixture_setup = setup;
+}
+void fixture_teardown(void (*teardown)( void ))
+{
+	seatest_fixture_teardown = teardown;
+}
+
+void seatest_setup( void )
+{
+	if(seatest_fixture_setup != 0) seatest_fixture_setup();
+}
+
+void seatest_teardown( void )
+{
+	if(seatest_fixture_teardown != 0) seatest_fixture_teardown();
+}
+
+char* test_file_name(char* path)
+{
+	char* file = path + strlen(path);
+	while(file != path && *file!= '\\' ) file--;
+	if(*file == '\\') file++;
+	return file;
+}
+
+static int seatest_fixture_tests_run;
+static int seatest_fixture_tests_failed;
+
+void seatest_simple_test_result(int passed, char* reason, const char* function, unsigned int line)
+{
+	if (!passed)
+	{
+		printf("%-20s Line %-5d %s\r\n", function, line, reason );
+		sea_tests_failed++; 
+	}
+	else
+	{
+		sea_tests_passed++; 
+	}	
+}
+
+void seatest_assert_true(int test, const char* function, unsigned int line)
+{
+	seatest_simple_test_result(test, "Should of been true", function, line);
+
+}
+
+void seatest_assert_false(int test, const char* function, unsigned int line)
+{
+	seatest_simple_test_result(!test, "Should of been false", function, line);	
+}
+
+
+void seatest_assert_int_equal(int expected, int actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %d but was %d", expected, actual);
+	seatest_simple_test_result(expected==actual, s, function, line);	
+}
+
+void seatest_assert_ulong_equal(unsigned long expected, unsigned long actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %lu but was %lu", expected, actual);
+	seatest_simple_test_result(expected==actual, s, function, line);	
+}
+
+void seatest_assert_float_equal( float expected, float actual, float delta, const char* function, unsigned int line )
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	float result = expected-actual;
+	sprintf(s, "Expected %f but was %f", expected, actual);
+	if(result < 0.0) result = 0.0f - result;
+	seatest_simple_test_result( result <= delta, s, function, line);	
+}
+
+void seatest_assert_double_equal( double expected, double actual, double delta, const char* function, unsigned int line )
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	double result = expected-actual;
+	sprintf(s, "Expected %f but was %f", expected, actual);
+	if(result < 0.0) result = 0.0 - result;
+	seatest_simple_test_result( result <= delta, s, function, line);	
+}
+
+void seatest_assert_string_equal(char* expected, char* actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %s but was %s", expected, actual);
+	seatest_simple_test_result(strcmp(expected, actual)==0, s, function, line);	
+}
+
+void seatest_assert_string_ends_with(char* expected, char* actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %s to end with %s", actual, expected);
+	seatest_simple_test_result(strcmp(expected, actual+(strlen(actual)-strlen(expected)))==0, s, function, line);	
+}
+
+void seatest_assert_string_starts_with(char* expected, char* actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %s to start with %s", actual, expected);
+	seatest_simple_test_result(strncmp(expected, actual, strlen(expected))==0, s, function, line);	
+}
+
+void seatest_assert_string_contains(char* expected, char* actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %s to be in %s", expected, actual);
+	seatest_simple_test_result(strstr(actual, expected)!=0, s, function, line);	
+}
+
+void seatest_assert_string_doesnt_contain(char* expected, char* actual, const char* function, unsigned int line)
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "Expected %s not to have %s in it", actual, expected);
+	seatest_simple_test_result(strstr(actual, expected)==0, s, function, line);	
+}
+
+void seatest_run_test(void)
+{
+	sea_tests_run++; 
+}
+
+void seatest_header_printer(char* s, int length, char f)
+{
+	int l = strlen(s);
+	int d = (length- (l + 2)) / 2;
+	int i;
+	for(i = 0; i<d; i++) printf("%c",f);
+	printf(" %s ", s);
+	for(i = (d+l+2); i<length; i++) printf("%c",f);
+	printf("\r\n");
+}
+
+
+void seatest_test_fixture_start(char* filepath)
+{
+	seatest_current_fixture = test_file_name(filepath);
+	seatest_header_printer(seatest_current_fixture, 50, '-');
+	seatest_fixture_tests_failed = sea_tests_failed;
+	seatest_fixture_tests_run = sea_tests_run;
+	seatest_fixture_teardown = 0;
+	seatest_fixture_setup = 0;
+}
+
+void seatest_test_fixture_end()
+{
+	char s[SEATEST_PRINT_BUFFER_SIZE];
+	sprintf(s, "%d run  %d failed", sea_tests_run-seatest_fixture_tests_run, sea_tests_failed-seatest_fixture_tests_failed);
+	seatest_header_printer(s, 50, ' ');
+	printf("\r\n");
+}
+
+static char* seatest_fixture_filter = 0;
+static char* seatest_test_filter = 0;
+
+void fixture_filter(char* filter)
+{
+	seatest_fixture_filter = filter;
+}
+
+
+void test_filter(char* filter)
+{
+	seatest_test_filter = filter;
+}
+
+
+int seatest_should_run( char* fixture, char* test)
+{
+	int run = 1;
+	if(seatest_fixture_filter) 
+	{
+		if(strncmp(seatest_fixture_filter, fixture, strlen(seatest_fixture_filter)) != 0) run = 0;
+	}
+	if(seatest_test_filter) 
+	{
+		if(strncmp(seatest_test_filter, test, strlen(seatest_test_filter)) != 0) run = 0;
+	}
+	return run;
+}
+
+int run_tests(void (*tests)(void))
+{
+	unsigned long end;
+	unsigned long start = GetTickCount();
+	tests();	 
+	end = GetTickCount();
+	printf("\r\n\r\n==================SEATEST v%s====================\r\n\r\n", SEATEST_VERSION);	 
+	if (sea_tests_failed > 0) {
+		printf("                      Failed\r\n");			
+	}
+	else {
+		printf("               ALL TESTS PASSED\r\n");
+	}
+	printf("                 %d tests run\r\n", sea_tests_run);
+	printf("                    in %lu ms\r\n",end - start);
+	printf("==================================================\r\n");
+
+	_getch();
+	return sea_tests_failed == 0;
+}
+
--- a/src/modules/janssonrpcc/unit_tests/seatest/seatest.h
+++ b/src/modules/janssonrpcc/unit_tests/seatest/seatest.h
@@ -1,74 +1,74 @@
-#ifndef SEATEST_H
-#define SEATEST_H
-#include <stdio.h>
-
-/*
-Defines
-*/
-
-#define SEATEST_VERSION "0.5"
-#define SEATEST_PROJECT_HOME "http://code.google.com/p/seatest/"
-#define SEATEST_PRINT_BUFFER_SIZE 100000
-
-/*
-Declarations
-*/
-
-void seatest_test_fixture_start(char* filepath);
-void seatest_test_fixture_end( void );
-void seatest_simple_test_result(int passed, char* reason, const char* function, unsigned int line);
-void seatest_assert_true(int test, const char* function, unsigned int line);
-void seatest_assert_false(int test, const char* function, unsigned int line);
-void seatest_assert_int_equal(int expected, int actual, const char* function, unsigned int line);
-void seatest_assert_ulong_equal(unsigned long expected, unsigned long actual, const char* function, unsigned int line);
-void seatest_assert_float_equal(float expected, float actual, float delta, const char* function, unsigned int line);
-void seatest_assert_double_equal(double expected, double actual, double delta, const char* function, unsigned int line);
-void seatest_assert_string_equal(char* expected, char* actual, const char* function, unsigned int line);
-void seatest_assert_string_ends_with(char* expected, char* actual, const char* function, unsigned int line);
-void seatest_assert_string_starts_with(char* expected, char* actual, const char* function, unsigned int line);
-void seatest_assert_string_contains(char* expected, char* actual, const char* function, unsigned int line);
-void seatest_assert_string_doesnt_contain(char* expected, char* actual, const char* function, unsigned int line);
-int seatest_should_run( char* fixture, char* test);
-void seatest_run_test(void);
-void seatest_setup( void );
-void seatest_teardown( void );
-void seatest_suite_teardown( void );
-void seatest_suite_setup( void );
-
-/*
-Assert Macros
-*/
-
-#define assert_true(test) do { seatest_assert_true(test, __FUNCTION__, __LINE__); } while (0)
-#define assert_false(test) do {  seatest_assert_false(test, __FUNCTION__, __LINE__); } while (0)
-#define assert_int_equal(expected, actual) do {  seatest_assert_int_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_ulong_equal(expected, actual) do {  seatest_assert_ulong_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_string_equal(expected, actual) do {  seatest_assert_string_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_n_array_equal(expected, actual, n) do { int seatest_count; for(seatest_count=0; seatest_count<n; seatest_count++) { char s_seatest[SEATEST_PRINT_BUFFER_SIZE]; sprintf(s_seatest,"Expected %d to be %d at position %d", actual[seatest_count], expected[seatest_count], seatest_count); seatest_simple_test_result((expected[seatest_count] == actual[seatest_count]), s_seatest, __FUNCTION__, __LINE__);} } while (0)
-#define assert_bit_set(bit_number, value) { seatest_simple_test_result(((1 << bit_number) & value), " Expected bit to be set" ,  __FUNCTION__, __LINE__); } while (0)
-#define assert_bit_not_set(bit_number, value) { seatest_simple_test_result(!((1 << bit_number) & value), " Expected bit not to to be set" ,  __FUNCTION__, __LINE__); } while (0)
-#define assert_bit_mask_matches(value, mask) { seatest_simple_test_result(((value & mask) == mask), " Expected all bits of mask to be set" ,  __FUNCTION__, __LINE__); } while (0)
-#define assert_fail(message) { seatest_simple_test_result(0, message,  __FUNCTION__, __LINE__); } while (0)
-#define assert_float_equal(expected, actual, delta) do {  seatest_assert_float_equal(expected, actual, delta, __FUNCTION__, __LINE__); } while (0)
-#define assert_double_equal(expected, actual, delta) do {  seatest_assert_double_equal(expected, actual, delta, __FUNCTION__, __LINE__); } while (0)
-#define assert_string_contains(expected, actual) do {  seatest_assert_string_contains(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_string_doesnt_contain(expected, actual) do {  seatest_assert_string_doesnt_contain(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_string_starts_with(expected, actual) do {  seatest_assert_string_starts_with(expected, actual, __FUNCTION__, __LINE__); } while (0)
-#define assert_string_ends_with(expected, actual) do {  seatest_assert_string_ends_with(expected, actual, __FUNCTION__, __LINE__); } while (0)
-
-/*
-Fixture / Test Management
-*/
-
-void fixture_setup(void (*setup)( void ));
-void fixture_teardown(void (*teardown)( void ));
-#define run_test(test) do { if(seatest_should_run(__FILE__, #test)) {seatest_suite_setup(); seatest_setup(); test(); seatest_teardown(); seatest_suite_teardown(); seatest_run_test();  }} while (0)
-#define test_fixture_start() do { seatest_test_fixture_start(__FILE__); } while (0)
-#define test_fixture_end() do { seatest_test_fixture_end();} while (0)
-void fixture_filter(char* filter);
-void test_filter(char* filter);
-
-int run_tests(void (*tests)(void));
-void suite_teardown(void (*teardown)( void ));
-void suite_setup(void (*setup)( void ));
-#endif 
+#ifndef SEATEST_H
+#define SEATEST_H
+#include <stdio.h>
+
+/*
+Defines
+*/
+
+#define SEATEST_VERSION "0.5"
+#define SEATEST_PROJECT_HOME "http://code.google.com/p/seatest/"
+#define SEATEST_PRINT_BUFFER_SIZE 100000
+
+/*
+Declarations
+*/
+
+void seatest_test_fixture_start(char* filepath);
+void seatest_test_fixture_end( void );
+void seatest_simple_test_result(int passed, char* reason, const char* function, unsigned int line);
+void seatest_assert_true(int test, const char* function, unsigned int line);
+void seatest_assert_false(int test, const char* function, unsigned int line);
+void seatest_assert_int_equal(int expected, int actual, const char* function, unsigned int line);
+void seatest_assert_ulong_equal(unsigned long expected, unsigned long actual, const char* function, unsigned int line);
+void seatest_assert_float_equal(float expected, float actual, float delta, const char* function, unsigned int line);
+void seatest_assert_double_equal(double expected, double actual, double delta, const char* function, unsigned int line);
+void seatest_assert_string_equal(char* expected, char* actual, const char* function, unsigned int line);
+void seatest_assert_string_ends_with(char* expected, char* actual, const char* function, unsigned int line);
+void seatest_assert_string_starts_with(char* expected, char* actual, const char* function, unsigned int line);
+void seatest_assert_string_contains(char* expected, char* actual, const char* function, unsigned int line);
+void seatest_assert_string_doesnt_contain(char* expected, char* actual, const char* function, unsigned int line);
+int seatest_should_run( char* fixture, char* test);
+void seatest_run_test(void);
+void seatest_setup( void );
+void seatest_teardown( void );
+void seatest_suite_teardown( void );
+void seatest_suite_setup( void );
+
+/*
+Assert Macros
+*/
+
+#define assert_true(test) do { seatest_assert_true(test, __FUNCTION__, __LINE__); } while (0)
+#define assert_false(test) do {  seatest_assert_false(test, __FUNCTION__, __LINE__); } while (0)
+#define assert_int_equal(expected, actual) do {  seatest_assert_int_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_ulong_equal(expected, actual) do {  seatest_assert_ulong_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_string_equal(expected, actual) do {  seatest_assert_string_equal(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_n_array_equal(expected, actual, n) do { int seatest_count; for(seatest_count=0; seatest_count<n; seatest_count++) { char s_seatest[SEATEST_PRINT_BUFFER_SIZE]; sprintf(s_seatest,"Expected %d to be %d at position %d", actual[seatest_count], expected[seatest_count], seatest_count); seatest_simple_test_result((expected[seatest_count] == actual[seatest_count]), s_seatest, __FUNCTION__, __LINE__);} } while (0)
+#define assert_bit_set(bit_number, value) { seatest_simple_test_result(((1 << bit_number) & value), " Expected bit to be set" ,  __FUNCTION__, __LINE__); } while (0)
+#define assert_bit_not_set(bit_number, value) { seatest_simple_test_result(!((1 << bit_number) & value), " Expected bit not to to be set" ,  __FUNCTION__, __LINE__); } while (0)
+#define assert_bit_mask_matches(value, mask) { seatest_simple_test_result(((value & mask) == mask), " Expected all bits of mask to be set" ,  __FUNCTION__, __LINE__); } while (0)
+#define assert_fail(message) { seatest_simple_test_result(0, message,  __FUNCTION__, __LINE__); } while (0)
+#define assert_float_equal(expected, actual, delta) do {  seatest_assert_float_equal(expected, actual, delta, __FUNCTION__, __LINE__); } while (0)
+#define assert_double_equal(expected, actual, delta) do {  seatest_assert_double_equal(expected, actual, delta, __FUNCTION__, __LINE__); } while (0)
+#define assert_string_contains(expected, actual) do {  seatest_assert_string_contains(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_string_doesnt_contain(expected, actual) do {  seatest_assert_string_doesnt_contain(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_string_starts_with(expected, actual) do {  seatest_assert_string_starts_with(expected, actual, __FUNCTION__, __LINE__); } while (0)
+#define assert_string_ends_with(expected, actual) do {  seatest_assert_string_ends_with(expected, actual, __FUNCTION__, __LINE__); } while (0)
+
+/*
+Fixture / Test Management
+*/
+
+void fixture_setup(void (*setup)( void ));
+void fixture_teardown(void (*teardown)( void ));
+#define run_test(test) do { if(seatest_should_run(__FILE__, #test)) {seatest_suite_setup(); seatest_setup(); test(); seatest_teardown(); seatest_suite_teardown(); seatest_run_test();  }} while (0)
+#define test_fixture_start() do { seatest_test_fixture_start(__FILE__); } while (0)
+#define test_fixture_end() do { seatest_test_fixture_end();} while (0)
+void fixture_filter(char* filter);
+void test_filter(char* filter);
+
+int run_tests(void (*tests)(void));
+void suite_teardown(void (*teardown)( void ));
+void suite_setup(void (*setup)( void ));
+#endif 
--- a/src/modules/log_systemd/journal_send.c
+++ b/src/modules/log_systemd/journal_send.c
@@ -40,6 +40,7 @@ int k_sd_journal_send_xavp(str *rname)
 
 	if (!rxavp || rxavp->val.type != SR_XTYPE_XAVP) {
 		LM_ERR("not a valid xavp: %.*s?\n", rname->len, rname->s);
+		return -1;
 	}
 
 	/* first, count xavp nodes */
--- a/src/modules/misc_radius/extra.h
+++ b/src/modules/misc_radius/extra.h
@@ -36,7 +36,7 @@ struct extra_attr
 	struct extra_attr *next;
 };
 
-#define MAX_EXTRA 4
+#define MAX_EXTRA 32
 
 void init_extra_engine(void);
 
--- a/src/modules/msilo/README
+++ b/src/modules/msilo/README
@@ -14,8 +14,6 @@ Daniel-Constantin Mierla
 
    <miconda@gmail.com>
 
-Edited by
-
 Juha Heinanen
 
    <jh@tutpro.com>
@@ -510,7 +508,7 @@ modparam("msilo", "expire_time", 36000)
    module keeps each request send by itself for a new online user and if
    the reply is 2xx then the message is deleted from database.
 
-   Default value is “30”.
+   Default value is “60”.
 
    Example 1.21. Set the “check_time” parameter
 ...
@@ -537,7 +535,7 @@ modparam("msilo", "send_time", 60)
    Number of “check_time” cycles when to check if there are expired
    messages in database.
 
-   Default value is “5”.
+   Default value is “10”.
 
    Example 1.23. Set the “clean_period” parameter
 ...
--- a/src/modules/msilo/doc/msilo_admin.xml
+++ b/src/modules/msilo/doc/msilo_admin.xml
@@ -465,7 +465,7 @@ modparam("msilo", "expire_time", 36000)
 		</para>
 		<para>
 		<emphasis>
-			Default value is <quote>30</quote>.
+			Default value is <quote>60</quote>.
 		</emphasis>
 		</para>
 		<example>
@@ -509,7 +509,7 @@ modparam("msilo", "send_time", 60)
 		</para>
 		<para>
 		<emphasis>
-			Default value is <quote>5</quote>.
+			Default value is <quote>10</quote>.
 		</emphasis>
 		</para>
 		<example>
--- a/src/modules/nathelper/nathelper.c
+++ b/src/modules/nathelper/nathelper.c
@@ -1951,6 +1951,8 @@ static void nh_timer(unsigned int ticks,
 					+ iteration,
 			natping_processes * natping_interval, options);
 	if(rval < 0) {
+		if(buf != NULL)
+			pkg_free(buf);
 		LM_ERR("failed to fetch contacts\n");
 		goto done;
 	}
--- a/src/modules/pdb/pdb.c
+++ b/src/modules/pdb/pdb.c
@@ -148,9 +148,13 @@ static void pdb_msg_dbg(struct pdb_msg m
     char buf[PAYLOADSIZE * 3 + 1];
     char *ptr = buf;
 
-    for (i = 0; i < msg.hdr.length - sizeof(msg.hdr); i++) {
-        ptr += sprintf(ptr,"%02X ", msg.bdy.payload[i]);
-    }
+	if(msg.hdr.length > sizeof(msg.hdr)) {
+		for (i = 0; i < msg.hdr.length - sizeof(msg.hdr); i++) {
+			ptr += sprintf(ptr, "%02X ", msg.bdy.payload[i]);
+		}
+	} else {
+		*ptr = '\0';
+	}
 
     LM_DBG("%s\n"
            "version = %d\ntype = %d\ncode = %d\nid = %d\nlen = %d\n"
--- a/src/modules/phonenum/README
+++ b/src/modules/phonenum/README
@@ -26,6 +26,7 @@ Daniel-Constantin Mierla
         3. Parameters
 
               3.1. smode (int)
+              3.2. resid (str)
 
         4. Functions
 
@@ -37,8 +38,9 @@ Daniel-Constantin Mierla
    List of Examples
 
    1.1. Set smode parameter
-   1.2. phonenum_match usage
-   1.3. phonenum_match_cn usage
+   1.2. Set resid parameter
+   1.3. phonenum_match usage
+   1.4. phonenum_match_cn usage
 
 Chapter 1. Admin Guide
 
@@ -53,6 +55,7 @@ Chapter 1. Admin Guide
    3. Parameters
 
         3.1. smode (int)
+        3.2. resid (str)
 
    4. Functions
 
@@ -95,10 +98,11 @@ Chapter 1. Admin Guide
 3. Parameters
 
    3.1. smode (int)
+   3.2. resid (str)
 
 3.1. smode (int)
 
-   Phone number search mode.
+   Phone number search mode (not in use yet).
 
    Default value is “0”.
 
@@ -107,6 +111,23 @@ Chapter 1. Admin Guide
 modparam("phonenum", "smode", 0)
 ...
 
+3.2. resid (str)
+
+   Preregister result container id during initialization, enabling the use
+   of the module in KEMI scripts. In native Kamailio.cfg file,
+   registration is done when parsing config and finding variables.
+
+   Default value is “” (empty).
+
+   Example 1.2. Set resid parameter
+...
+modparam("phonenum", "resid", "src")
+...
+if(phonenum_match("1-484-555-8888", "src")) {
+   ...
+}
+...
+
 4. Functions
 
    4.1. phonenum_match(num, pvc)
@@ -115,14 +136,14 @@ modparam("phonenum", "smode", 0)
 4.1.  phonenum_match(num, pvc)
 
    Match num against the libphonenumber and set the attributes inside the
-   pvc container. The function has to be called before accessing a key
-   via: $phn(pvc=>key).
+   pvc result container. The function has to be called before accessing a
+   key via: $phn(pvc=>key).
 
    The parameters can be static strings or strings with variables.
 
    It can be used from ANY_ROUTE.
 
-   Example 1.2. phonenum_match usage
+   Example 1.3. phonenum_match usage
 ...
 if(phonenum_match("1-484-555-8888", "src")) {
     if($phn(src=>valid)==1) {
@@ -144,7 +165,7 @@ if(phonenum_match("1-484-555-8888", "src
 
    It can be used from ANY_ROUTE.
 
-   Example 1.3. phonenum_match_cn usage
+   Example 1.4. phonenum_match_cn usage
 ...
 if(phonenum_match_cn("1-484-555-8888", "US", "src")) {
     if($phn(src=>valid)==1) {
--- a/src/modules/phonenum/doc/phonenum_admin.xml
+++ b/src/modules/phonenum/doc/phonenum_admin.xml
@@ -71,7 +71,7 @@
 	<section id="phonenum.p.smode">
 	    <title><varname>smode</varname> (int)</title>
 	    <para>
-		Phone number search mode.
+		Phone number search mode (not in use yet).
 	    </para>
 	    <para>
 		<emphasis>
@@ -87,7 +87,31 @@ modparam("phonenum", "smode", 0)
 </programlisting>
 	    </example>
 	</section>
-
+	<section id="phonenum.p.resid">
+	    <title><varname>resid</varname> (str)</title>
+	    <para>
+		Preregister result container id during initialization, enabling the use
+		of the module in KEMI scripts. In native &kamailio;.cfg file, registration
+		is done when parsing config and finding variables.
+	    </para>
+	    <para>
+		<emphasis>
+		    Default value is <quote></quote> (empty).
+		</emphasis>
+	    </para>
+	    <example>
+		<title>Set <varname>resid</varname> parameter</title>
+		<programlisting format="linespecific">
+...
+modparam("phonenum", "resid", "src")
+...
+if(phonenum_match("1-484-555-8888", "src")) {
+   ...
+}
+...
+</programlisting>
+	    </example>
+	</section>
 	</section>
 
     <section>
@@ -98,7 +122,7 @@ modparam("phonenum", "smode", 0)
 	    </title>
 	    <para>
 			Match num against the libphonenumber and set the attributes inside
-			the pvc container. The function has to be called before accessing
+			the pvc result container. The function has to be called before accessing
 			a key via: $phn(pvc=&gt;key).
 	    </para>
 	    <para>
--- a/src/modules/phonenum/phonenum_mod.c
+++ b/src/modules/phonenum/phonenum_mod.c
@@ -47,6 +47,8 @@ static int w_phonenum_match_cn(struct si
 		char *str3);
 static int phonenum_match(sip_msg_t *msg, str *tomatch, str *pvclass);
 
+static int phonenum_resid_param(modparam_t type, void* val);
+
 /* clang-format off */
 static pv_export_t mod_pvs[] = {
 	{ {"phn", sizeof("phn")-1}, PVT_OTHER, pv_get_phonenum, 0,
@@ -64,6 +66,7 @@ static cmd_export_t cmds[]={
 
 static param_export_t params[]={
 	{"smode", PARAM_INT, &phonenum_smode},
+	{"resid", PARAM_STR|PARAM_USE_FUNC, &phonenum_resid_param},
 	{0, 0, 0}
 };
 
@@ -102,6 +105,21 @@ static void mod_destroy(void)
 	phonenum_destroy_pv();
 }
 
+/**
+ *
+ */
+static int phonenum_resid_param(modparam_t type, void* val)
+{
+	str rname;
+
+	rname = *((str*)val);
+	if(sr_phonenum_add_resid(&rname) < 0) {
+		LM_ERR("failed to register result container with id: %.*s\n",
+				rname.len, rname.s);
+		return -1;
+	}
+	return 0;
+}
 
 static int phonenum_match(sip_msg_t *msg, str *tomatch, str *pvclass)
 {
--- a/src/modules/phonenum/phonenum_pv.c
+++ b/src/modules/phonenum/phonenum_pv.c
@@ -111,6 +111,13 @@ sr_phonenum_item_t *sr_phonenum_add_item
 	return it;
 }
 
+int sr_phonenum_add_resid(str *rname)
+{
+	if(sr_phonenum_add_item(rname)==NULL) {
+		return -1;
+	}
+	return 0;
+}
 
 int pv_parse_phonenum_name(pv_spec_p sp, str *in)
 {
--- a/src/modules/phonenum/phonenum_pv.h
+++ b/src/modules/phonenum/phonenum_pv.h
@@ -34,6 +34,7 @@ int phonenum_init_pv(int smode);
 void phonenum_destroy_pv(void);
 void phonenum_pv_reset(str *pvclass);
 int phonenum_update_pv(str *tomatch, str *cncode, str *pvclass);
+int sr_phonenum_add_resid(str *rname);
 
 #endif
 
--- a/src/modules/presence/README
+++ b/src/modules/presence/README
@@ -12,8 +12,6 @@ Edited by
 
 Anca-Maria Vamanu
 
-Edited by
-
 Juha Heinanen
 
    Copyright © 2006 Voice Sistem SRL
@@ -92,7 +90,7 @@ Juha Heinanen
 
         7. Events
 
-              7.1. present:notify-reply
+              7.1. presence:notify-reply
 
         8. Installation
 
@@ -234,7 +232,7 @@ Chapter 1. Admin Guide
 
    7. Events
 
-        7.1. present:notify-reply
+        7.1. presence:notify-reply
 
    8. Installation
 
@@ -388,9 +386,9 @@ modparam("presence", "clean_period", 100
    Default value is “0”.
 
    Example 1.6. Set cseq_offset parameter
-                ...
-                modparam("presence", "cseq_offset", 1)
-                ...
+...
+modparam("presence", "cseq_offset", 1)
+...
 
 3.7. db_update_period (int)
 
@@ -535,9 +533,9 @@ modparam("presence", "max_expires", 3600
    Default value is “0”.
 
    Example 1.16. Set min_expires parameter
-            ...
-            modparam("presence", "min_expires", 1800)
-            ...
+...
+modparam("presence", "min_expires", 1800)
+...
 
 3.17. min_expires_action (int)
 
@@ -831,9 +829,9 @@ modparam("presence", "retrieve_order_by"
    Default value is “0”.
 
    Example 1.34. Set sip_uri_match parameter
-            ...
-            modparam("presence", "sip_uri_match", 1)
-            ...
+...
+modparam("presence", "sip_uri_match", 1)
+...
 
 3.35. enable_dmq (integer)
 
@@ -848,9 +846,9 @@ modparam("presence", "retrieve_order_by"
    Default value is 0.
 
    Example 1.35. Set enable_dmq parameter
-                        ...
-                        modparam("presence", "enable_dmq", 1)
-                        ...
+...
+modparam("presence", "enable_dmq", 1)
+...
 
 4. Functions
 
@@ -950,10 +948,10 @@ if (method=="MESSAGE") {
    This function can be used from ANY_ROUTE.
 
    Example 1.39. pres_has_subscribers usage
-            ...
-            if(pres_has_subscribers($var(uri), "message-summary"))
-            do something...;
-            ...
+...
+if(pres_has_subscribers($var(uri), "message-summary"))
+    # do something...;
+...
 
 4.5.  pres_refresh_watchers(uri, event, type[, file_uri, filename])
 
@@ -1060,7 +1058,7 @@ kamcmd presence.refreshWatchers sip:test
    Access the attributes of handled subscription. It must be used after a
    successful call of “handle_subscription()” or in the following events.
      * tm:local-request - before notify is sent
-     * present:notify-reply - after notify is sent
+     * presence:notify-reply - after notify is sent
 
    The “attr” can be:
      * uri - subscription presentity uri
@@ -1100,7 +1098,7 @@ if(handle_subscription())
 
    Access the reply message received when notifying subscriber. It must be
    used in the following events.
-     * present:notify-reply - after notify is sent
+     * presence:notify-reply - after notify is sent
 
    The “attr” can be any pseudo var that accesses attributes of msg
 
@@ -1114,9 +1112,9 @@ event_route[presence:notify-reply]
 
 7. Events
 
-   7.1. present:notify-reply
+   7.1. presence:notify-reply
 
-7.1. present:notify-reply
+7.1. presence:notify-reply
 
    Fired after notify reply is received or timeout.
 
--- a/src/modules/presence/doc/presence_admin.xml
+++ b/src/modules/presence/doc/presence_admin.xml
@@ -192,10 +192,10 @@ modparam("presence", "clean_period", 100
         <example>
             <title>Set <varname>cseq_offset</varname> parameter</title>
             <programlisting format="linespecific">
-                ...
-                modparam("presence", "cseq_offset", 1)
-                ...
-            </programlisting>
+...
+modparam("presence", "cseq_offset", 1)
+...
+</programlisting>
         </example>
     </section>
     <section id="presence.p.db_update_period">
@@ -422,10 +422,10 @@ modparam("presence", "max_expires", 3600
     <example>
         <title>Set <varname>min_expires</varname> parameter</title>
         <programlisting format="linespecific">
-            ...
-            modparam("presence", "min_expires", 1800)
-            ...
-        </programlisting>
+...
+modparam("presence", "min_expires", 1800)
+...
+</programlisting>
     </example>
 </section>
 
@@ -895,10 +895,10 @@ modparam("presence", "retrieve_order_by"
     <example>
         <title>Set <varname>sip_uri_match</varname> parameter</title>
         <programlisting format="linespecific">
-            ...
-            modparam("presence", "sip_uri_match", 1)
-            ...
-        </programlisting>
+...
+modparam("presence", "sip_uri_match", 1)
+...
+</programlisting>
     </example>
 </section>
 
@@ -922,10 +922,10 @@ modparam("presence", "retrieve_order_by"
 	<example>
 		<title>Set <varname>enable_dmq</varname> parameter</title>
 		<programlisting format="linespecific">
-			...
-			modparam("presence", "enable_dmq", 1)
-			...
-		</programlisting>
+...
+modparam("presence", "enable_dmq", 1)
+...
+</programlisting>
 	</example>
 </section>
 
@@ -1087,11 +1087,11 @@ if (method=="MESSAGE") {
     <example>
         <title><function>pres_has_subscribers</function> usage</title>
         <programlisting format="linespecific">
-            ...
-            if(pres_has_subscribers($var(uri), "message-summary"))
-            do something...;
-            ...
-        </programlisting>
+...
+if(pres_has_subscribers($var(uri), "message-summary"))
+    # do something...;
+...
+</programlisting>
     </example>
 </section>
 
@@ -1208,7 +1208,7 @@ pres_update_watchers("sip:test@kamailio.
 ...
 &kamcmd; presence.cleanup
 ...
-	  </programlisting>
+</programlisting>
     </section>
 	<section id="presence.r.refreshWatchers">
 		<title>presence.refreshWatchers</title>
@@ -1264,7 +1264,7 @@ pres_update_watchers("sip:test@kamailio.
 ...
 &kamcmd; presence.refreshWatchers sip:test@kamailio.org presence 1
 ...
-		</programlisting>
+</programlisting>
 	</section>
 </section>
 
@@ -1283,7 +1283,7 @@ pres_update_watchers("sip:test@kamailio.
 				</para>
 				</listitem>
 				<listitem>
-				<para><emphasis>present:notify-reply</emphasis> - after notify is sent
+				<para><emphasis>presence:notify-reply</emphasis> - after notify is sent
 				</para>
 				</listitem>
 			</itemizedlist>
@@ -1399,7 +1399,7 @@ if(handle_subscription())
   xlog("presentity=$subs(uri)\n");
 }
 ...
-				 </programlisting>
+</programlisting>
 			</example>
 		</section>
 
@@ -1410,7 +1410,7 @@ if(handle_subscription())
 				It must be used in the following events.
 			<itemizedlist>
 				<listitem>
-				<para><emphasis>present:notify-reply</emphasis> - after notify is sent
+				<para><emphasis>presence:notify-reply</emphasis> - after notify is sent
 				</para>
 				</listitem>
 			</itemizedlist>
@@ -1428,7 +1428,7 @@ event_route[presence:notify-reply]
   xlog("received message = $notify_reply($mb)\n");
 }
 ...
-				 </programlisting>
+</programlisting>
 			</example>
 		</section>
 </section>
@@ -1436,7 +1436,7 @@ event_route[presence:notify-reply]
 <section>
 	<title>Events</title>
 		<section>
-			<title><varname>present:notify-reply</varname></title>
+			<title><varname>presence:notify-reply</varname></title>
 			<para>
 				Fired after notify reply is received or timeout.
 			</para>
@@ -1450,7 +1450,7 @@ event_route[presence:notify-reply]
   xlog("received message = $notify_reply($mb)\n");
 }
 ...
-				 </programlisting>
+</programlisting>
 			</example>
 		</section>
 </section>
--- a/src/modules/presence/event_list.c
+++ b/src/modules/presence/event_list.c
@@ -150,6 +150,7 @@ int add_event(pres_ev_t* event)
 		if(ev== NULL)
 		{
 			free_event_params(parsed_event.params.list, PKG_MEM_TYPE);
+			parsed_event.params.list = NULL;
 			ERR_MEM(SHARE_MEM);
 		}
 		memset(ev, 0, sizeof(pres_ev_t));
--- a/src/modules/pv/pv_core.c
+++ b/src/modules/pv/pv_core.c
@@ -2604,6 +2604,7 @@ int pv_set_force_sock(struct sip_msg* ms
 		goto error;
 	}
 	val->rs.s[val->rs.len] = backup;
+	LM_DBG("trying to set send-socket to [%.*s]\n", val->rs.len, val->rs.s);
 	si = grep_sock_info(&host, (unsigned short)port, (unsigned short)proto);
 	if (si!=NULL)
 	{
--- a/src/modules/pv/pv_trans.c
+++ b/src/modules/pv/pv_trans.c
@@ -1232,6 +1232,7 @@ int tr_eval_uri(struct sip_msg *msg, tr_
 	param_hooks_t phooks;
 	param_t *pit=NULL;
 	str sproto;
+	int dlen = 0;
 
 	if(val==NULL || (!(val->flags&PV_VAL_STR)) || val->rs.len<=0)
 		return -1;
@@ -1266,8 +1267,11 @@ int tr_eval_uri(struct sip_msg *msg, tr_
 			free_params(_tr_uri_params);
 			_tr_uri_params = 0;
 		}
+		if(_tr_uri.len>4 && _tr_uri.s[_tr_uri.len-1]==';') {
+			dlen = 1;
+		}
 		/* parse uri -- params only when requested */
-		if(parse_uri(_tr_uri.s, _tr_uri.len, &_tr_parsed_uri)!=0)
+		if(parse_uri(_tr_uri.s, _tr_uri.len - dlen, &_tr_parsed_uri)!=0)
 		{
 			LM_ERR("invalid uri [%.*s]\n", val->rs.len,
 					val->rs.s);
@@ -1505,6 +1509,9 @@ int tr_eval_paramlist(struct sip_msg *ms
 
 		/* parse params */
 		sv = _tr_params_str;
+		if(sv.len>1 && sv.s[sv.len - 1] == _tr_params_separator) {
+			sv.len--;
+		}
 		if (parse_params2(&sv, CLASS_ANY, &phooks, &_tr_params_list,
 					_tr_params_separator)<0)
 			return -1;
--- a/src/modules/registrar/regpv.c
+++ b/src/modules/registrar/regpv.c
@@ -35,6 +35,7 @@
 #include "../../core/action.h"
 #include "../../core/fmsg.h"
 #include "../../core/kemi.h"
+#include "../../core/receive.h"
 #include "../usrloc/usrloc.h"
 #include "registrar.h"
 #include "common.h"
@@ -751,7 +752,7 @@ void reg_ul_expired_contact(ucontact_t*
 		}
 	}
 	set_route_type(backup_rt);
-
+	ksr_msg_env_reset();
 	return;
 error:
 	regpv_free_profile(rpp);
--- a/src/modules/rls/Makefile
+++ b/src/modules/rls/Makefile
@@ -10,6 +10,12 @@ NAME=rls.so
 
 ifeq ($(CROSS_COMPILE),)
 XML2CFG=$(shell which xml2-config)
+ifeq ($(OS), darwin)
+ICU_BUILDER = $(shell \
+	if pkg-config --exists icu-uc; then \
+		echo 'pkg-config icu-uc'; \
+	fi)
+endif
 endif
 
 ifneq ($(XML2CFG),)
@@ -21,6 +27,11 @@ else
 	LIBS+=-L$(LOCALBASE)/lib -lxml2
 endif
 
+ifneq ($(ICU_BUILDER),)
+	DEFS += $(shell $(ICU_BUILDER) --cflags )
+	LIBS += $(shell $(ICU_BUILDER) --libs)
+endif
+
 DEFS+=
 
 SERLIBPATH=../../lib
--- a/src/modules/rls/README
+++ b/src/modules/rls/README
@@ -602,6 +602,8 @@ For rls only:
 
 4.2.  rls_handle_notify()
 
+   Handle NOTIFY requests.
+
    This function can be used from REQUEST_ROUTE.
 
    Example 1.27. rls_handle_notify usage
--- a/src/modules/rls/doc/rls_admin.xml
+++ b/src/modules/rls/doc/rls_admin.xml
@@ -97,10 +97,10 @@
 
 		</section>
 	</section>
-	
+
 	<section>
 	<title>Parameters</title>
-	<section>
+	<section id="rls.p.db_url">
 		<title><varname>db_url</varname>(str)</title>
 		<para>
 		The database url.
@@ -119,7 +119,7 @@ modparam("rls", "db_url", "&exampledb;")
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.rlpres_db_url">
 		<title><varname>rlpres_db_url</varname>(str)</title>
 		<para>
 		The rlpres (rls_presentity table) database url.
@@ -145,7 +145,7 @@ modparam("rls", "rlpres_db_url", "&examp
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.xcap_db_url">
 		<title><varname>xcap_db_url</varname>(str)</title>
 		<para>
 		The xcap database url.
@@ -166,7 +166,7 @@ modparam("rls", "xcap_db_url", "&example
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.db_mode">
 		<title><varname>db_mode</varname>(int)</title>
 		<para>
 		The module supports 2 modes of operation, high speed memory
@@ -188,7 +188,7 @@ modparam("rls", "db_mode", 2)
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.xcap_table">
 		<title><varname>xcap_table</varname>(str)</title>
 		<para>
 		The name of the xcap table in which the integrated server
@@ -209,7 +209,7 @@ modparam("rls", "xcap_table", "xcaps");
 </programlisting>
 		</example>
 	</section>
-	<section>
+	<section id="rls.p.rlsubs_table">
 		<title><varname>rlsubs_table</varname>(str)</title>
 		<para>
 		The name of the db table where resource lists subscription 
@@ -229,7 +229,7 @@ modparam("rls", "rlsubs_table", "rls_sub
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.rlpres_table">
 		<title><varname>rlpres_table</varname>(str)</title>
 		<para>
 		The name of the db table where notified event specific
@@ -249,7 +249,7 @@ modparam("rls", "rlpres_table", "rls_not
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.clean_period">
 		<title><varname>clean_period</varname> (int)</title>
 		<para>
 		The period at which to check for expired information.
@@ -269,7 +269,7 @@ modparam("rls", "clean_period", 100)
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.rlpres_clean_period">
 		<title><varname>rlpres_clean_period</varname> (int)</title>
 		<para>
 		The period at which to check for expired rls_presentity information.
@@ -293,7 +293,7 @@ modparam("rls", "rlpres_clean_period", 1
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.waitn_time">
 		<title><varname>waitn_time</varname> (int)</title>
 		<para>
 		The maximum time period that RLS NOTIFY requests will
@@ -316,7 +316,7 @@ modparam("rls", "waitn_time", 10)
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.notifier_poll_rate">
 		<title><varname>notifier_poll_rate</varname> (int)</title>
 		<para>
 		The number of times per second that the notifier processes
@@ -342,7 +342,7 @@ modparam("rls", "notifier_poll_rate", 20
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.notifier_processes">
 		<title><varname>notifier_processes</varname> (int)</title>
 		<para>
 		The number of notifier processes that should be started.
@@ -365,7 +365,7 @@ modparam("rls", "notifier_processes", 2)
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.max_expires">
 		<title><varname>max_expires</varname> (int)</title>
 		<para>
 		The maximum accepted expires for a subscription to a list. 
@@ -384,7 +384,7 @@ modparam("rls", "max_expires", 10800)
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.expires_offset">
 		<title><varname>expires_offset</varname> (int)</title>
 		<para>
 		This parameter only has an effect when the db_mode is DB_ONLY (mode 2).
@@ -410,7 +410,7 @@ modparam("rls", "expires_offset", 0)
 		</example>
 	</section>
  	
-	<section>
+	<section id="rls.p.hash_size">
 		<title><varname>hash_size</varname> (int)</title>
 		<para>
         The dimension of the hash table used to store subscription to a list.
@@ -430,7 +430,7 @@ modparam("rls", "hash_size", 11)
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.xcap_root">
 		<title><varname>xcap_root</varname> (str)</title>
 		<para>
 		The address of the xcap server.
@@ -449,7 +449,7 @@ modparam("rls", "xcap_root", "http://192
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.integrated_xcap_server">
 		<title><varname>integrated_xcap_server</varname> (int)</title>
 		<para>
 		This parameter should be set if only integrated xcap servers
@@ -469,7 +469,7 @@ modparam("rls", "integrated_xcap_server"
 		</example>
 	</section>
 	
-	<section>
+	<section id="rls.p.to_presence_code">
 		<title><varname>to_presence_code</varname> (int)</title>
 		<para>
 		The code to be returned by rls_handle_subscribe function 
@@ -492,7 +492,7 @@ modparam("rls", "to_presence_code", 10)
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.rls_event">
 		<title><varname>rls_event</varname> (str)</title>
 		<para>
 		The default event that RLS handles is presence. If some other
@@ -513,7 +513,7 @@ modparam("rls", "rls_event", "dialog;sla
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.outbound_proxy">
 		<title><varname>outbound_proxy</varname> (str)</title>
 		<para>
 		The SIP address where to send RLS subscriptions (outbound
@@ -533,7 +533,7 @@ modparam("rls", "outbound_proxy", "sip:p
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.server_address">
 		<title><varname>server_address</varname> (str)</title>
 		<para>
 			The address of the server that will be used as a contact in sent
@@ -550,7 +550,7 @@ modparam("rls", "server_address", "sip:r
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.p.max_notify_body_length">
 		<title><varname>max_notify_body_length</varname> (int)</title>
 		<para>
 			The maximum size that the body of a NOTIFY message may be. 
@@ -566,7 +566,7 @@ modparam("rls", "max_notify_body_length"
 		</programlisting>
 		</example>
 	</section>
-	<section>
+	<section id="rls.p.fetch_rows">
 	    <title><varname>fetch_rows</varname> (integer)</title>
 	    <para>
 		Number of rows to be loaded in one step from database.
@@ -585,7 +585,7 @@ modparam("rls", "fetch_rows", 1000)
 </programlisting>
 	    </example>
 	</section>
-	<section>
+	<section id="rls.p.disable_remote_presence">
 	    <title><varname>disable_remote_presence</varname> (integer)</title>
 	    <para>
 		When set to a non-zero value RLS will not perform back-end SUBSCRIBEs
@@ -611,7 +611,7 @@ modparam("rls", "disable_remote_presence
 </programlisting>
 	    </example>
 	</section>
-	<section>
+	<section id="rls.p.max_backend_subs">
 	    <title><varname>max_backend_subs</varname> (integer)</title>
 	    <para>
 		When set to a non-zero value RLS will limit the number of back-end
@@ -640,7 +640,7 @@ modparam("rls", "max_backend_subs", 30)
 
 <section>
 	<title>Functions</title>
-	<section>
+	<section id="rls.f.rls_handle_subscribe">
 		<title>
 		<function moreinfo="none">rls_handle_subscribe([watcher_uri])</function>
 		</title>
@@ -688,12 +688,12 @@ For rls only:
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.f.rls_handle_notify">
 		<title>
 		<function moreinfo="none">rls_handle_notify()</function>
 		</title>
 		<para>
-			
+		Handle NOTIFY requests.
 		</para>
 		<para>
 		This function can be used from REQUEST_ROUTE.
@@ -709,7 +709,7 @@ if(method=="NOTIFY")
 		</example>
 	</section>
 
-	<section>
+	<section id="rls.f.rls_update_subs">
 		<title>
 		<function moreinfo="none">rls_update_subs(uri, event)</function>
 		</title>
--- a/src/modules/rr/rr_mod.c
+++ b/src/modules/rr/rr_mod.c
@@ -292,6 +292,35 @@ static int ki_record_route(sip_msg_t *ms
 }
 
 /**
+ * wrapper for record_route_preset(msg, key1, key2)
+ */
+static int ki_record_route_preset(sip_msg_t *msg, str *key1, str *key2)
+{
+	if (msg->msg_flags & FL_RR_ADDED) {
+		LM_ERR("Double attempt to record-route\n");
+		return -1;
+	}
+	if (key2 && !enable_double_rr) {
+		LM_ERR("Attempt to double record-route while 'enable_double_rr' param is disabled\n");
+		return -1;
+	}
+
+	if ( record_route_preset( msg, key1)<0 )
+		return -1;
+
+	if (!key2)
+		goto done;
+
+	if ( record_route_preset( msg, key2)<0 )
+		return -1;
+
+done:
+	msg->msg_flags |= FL_RR_ADDED;
+	return 1;
+
+}
+
+/**
  * config wrapper for record_route(msg, params)
  */
 static int w_record_route(struct sip_msg *msg, char *key, char *bar)
@@ -317,7 +346,7 @@ static int w_record_route_preset(struct
 	str s;
 
 	if (msg->msg_flags & FL_RR_ADDED) {
-		LM_ERR("Duble attempt to record-route\n");
+		LM_ERR("Double attempt to record-route\n");
 		return -1;
 	}
 	if (key2 && !enable_double_rr) {
@@ -747,6 +776,11 @@ static sr_kemi_t sr_kemi_rr_exports[] =
 		{ SR_KEMIP_STR, SR_KEMIP_NONE, SR_KEMIP_NONE,
 			SR_KEMIP_NONE, SR_KEMIP_NONE, SR_KEMIP_NONE }
 	},
+	{ str_init("rr"), str_init("record_route_preset"),
+		SR_KEMIP_INT, ki_record_route_preset,
+		{ SR_KEMIP_STR, SR_KEMIP_STR, SR_KEMIP_NONE,
+			SR_KEMIP_NONE, SR_KEMIP_NONE, SR_KEMIP_NONE }
+	},
 	{ {0, 0}, {0, 0}, 0, NULL, { 0, 0, 0, 0, 0, 0 } }
 };
 
--- a/src/modules/rtpengine/rtpengine.c
+++ b/src/modules/rtpengine/rtpengine.c
@@ -2643,7 +2643,7 @@ send_rtpp_command(struct rtpp_node *node
 	static char buf[0x10000];
 	struct pollfd fds[1];
 	struct iovec *v;
-	str out = STR_NULL;
+	str cmd = STR_NULL;
 
 	v = bencode_iovec(dict, &vcnt, 1, 0);
 	if (!v) {
@@ -2708,8 +2708,9 @@ send_rtpp_command(struct rtpp_node *node
 				len = writev(rtpp_socks[node->idx], v, vcnt + 1);
 			} while (len == -1 && (errno == EINTR || errno == ENOBUFS));
 			if (len <= 0) {
-				bencode_get_str(bencode_dictionary_get(dict, "command"), &out);
-				LM_ERR("can't send command \"%.*s\" to RTP proxy <%s>\n", out.len, out.s, node->rn_url.s);
+				bencode_get_str(bencode_dictionary_get(dict, "command"), &cmd);
+				LM_ERR("can't send command \"%.*s\" to RTP proxy <%s>\n",
+					cmd.len, cmd.s, node->rn_url.s);
 				goto badproxy;
 			}
 			rtpengine_tout_ms = cfg_get(rtpengine,rtpengine_cfg,rtpengine_tout_ms);
@@ -2719,7 +2720,9 @@ send_rtpp_command(struct rtpp_node *node
 					len = recv(rtpp_socks[node->idx], buf, sizeof(buf)-1, 0);
 				} while (len == -1 && errno == EINTR);
 				if (len <= 0) {
-					LM_ERR("can't read reply for command \"%.*s\" from RTP proxy <%s>\n", out.len, out.s, node->rn_url.s);
+					bencode_get_str(bencode_dictionary_get(dict, "command"), &cmd);
+					LM_ERR("can't read reply for command \"%.*s\" from RTP proxy <%s>\n",
+						cmd.len, cmd.s, node->rn_url.s);
 					goto badproxy;
 				}
 				if (len >= (v[0].iov_len - 1) &&
@@ -2736,7 +2739,9 @@ send_rtpp_command(struct rtpp_node *node
 			}
 		}
 		if (i == rtpengine_retr) {
-			LM_ERR("timeout waiting reply for command \"%.*s\" from RTP proxy <%s>\n", out.len, out.s, node->rn_url.s);
+			bencode_get_str(bencode_dictionary_get(dict, "command"), &cmd);
+			LM_ERR("timeout waiting reply for command \"%.*s\" from RTP proxy <%s>\n",
+				cmd.len, cmd.s, node->rn_url.s);
 			goto badproxy;
 		}
 	}
@@ -2917,6 +2922,15 @@ select_rtpp_node_old(str callid, str via
 	return node;
 }
 
+unsigned int node_in_set(struct rtpp_node *node, struct rtpp_set *set) {
+	struct rtpp_node *current = set->rn_first;
+	while (current) {
+		if (current->idx == node->idx) return 1;
+		current = current->rn_next;
+	}
+	return 0;
+}
+
 /*
  * Main balancing routine. This DO try to keep the same proxy for
  * the call if some proxies were disabled or enabled (e.g. kamctl command)
@@ -2945,7 +2959,7 @@ select_rtpp_node(str callid, str viabran
 	node = select_rtpp_node_old(callid, viabranch, do_test, op);
 
 	// check node
-	if (!node) {
+	if (!node || (node_in_set(node, active_rtpp_set) == 0)) {
 		// run the selection algorithm
 		node = select_rtpp_node_new(callid, viabranch, do_test, queried_nodes_ptr, queried_nodes);
 
--- a/src/modules/rtpengine/rtpengine_db.c
+++ b/src/modules/rtpengine/rtpengine_db.c
@@ -98,6 +98,7 @@ static int rtpp_load_db(void)
 	if (n_rows == 0)
 	{
 		LM_WARN("No rtpproxy instances in database\n");
+		rtpp_dbf.free_result(rtpp_db_handle, res);
 		return 0;
 	}
 
--- /dev/null
+++ b/src/modules/rtpproxy/test/rtpproxy.patch
@@ -0,0 +1,374 @@
+diff --git a/Makefile.am b/Makefile.am
+index 258de5e..a61bc57 100644
+--- a/Makefile.am
++++ b/Makefile.am
+@@ -5,7 +5,7 @@ rtpproxy_SOURCES=main.c rtp.h rtp_server.c rtp_server.h \
+   rtpp_command.c rtpp_command.h rtpp_log.c rtpp_network.h rtpp_network.c \
+   rtpp_syslog_async.c rtpp_syslog_async.h rtpp_notify.c rtpp_notify.h \
+   rtpp_command_async.h rtpp_command_async.c
+-rtpproxy_LDADD=-lm -lpthread
++rtpproxy_LDADD=-lm -lpthread @LIBS_XMLRPC@
+ dist_man_MANS=rtpproxy.8
+ makeann_SOURCES=makeann.c rtp.h g711.h
+ makeann_LDADD=@LIBS_G729@ @LIBS_GSM@
+diff --git a/Makefile.in b/Makefile.in
+index 47c14fd..cdb5e43 100644
+--- a/Makefile.in
++++ b/Makefile.in
+@@ -217,7 +217,7 @@ rtpproxy_SOURCES = main.c rtp.h rtp_server.c rtp_server.h \
+   rtpp_syslog_async.c rtpp_syslog_async.h rtpp_notify.c rtpp_notify.h \
+   rtpp_command_async.h rtpp_command_async.c
+ 
+-rtpproxy_LDADD = -lm -lpthread
++rtpproxy_LDADD = -lm -lpthread @LIBS_XMLRPC@
+ dist_man_MANS = rtpproxy.8
+ makeann_SOURCES = makeann.c rtp.h g711.h
+ makeann_LDADD = @LIBS_G729@ @LIBS_GSM@
+diff --git a/aclocal.m4 b/aclocal.m4
+index b36bc80..0970c41 100644
+--- a/aclocal.m4
++++ b/aclocal.m4
+@@ -13,8 +13,8 @@
+ 
+ m4_ifndef([AC_AUTOCONF_VERSION],
+   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
+-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.68],,
+-[m4_warning([this file was generated for autoconf 2.68.
++m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.67],,
++[m4_warning([this file was generated for autoconf 2.67.
+ You have another version of autoconf.  It may work, but is not guaranteed to.
+ If you have problems, you may need to regenerate the build system entirely.
+ To do so, use the procedure documented by the package, typically `autoreconf'.])])
+diff --git a/config.h.in b/config.h.in
+index cd0c23a..87491e3 100644
+--- a/config.h.in
++++ b/config.h.in
+@@ -14,6 +14,9 @@
+ /* Define if you have libgsm library installed */
+ #undef ENABLE_GSM
+ 
++/* Define if you have xmlrpc library installed */
++#undef ENABLE_XMLRPC
++
+ /* Define to 1 if you have `alloca', as a function or macro. */
+ #undef HAVE_ALLOCA
+ 
+diff --git a/configure.ac b/configure.ac
+index 54c1a60..1c88b99 100644
+--- a/configure.ac
++++ b/configure.ac
+@@ -53,6 +53,17 @@ then
+    AC_DEFINE([ENABLE_G729], 1, [Define if you have libg729 library installed])
+   )
+ fi
++
++# XML-RPC-Libs:
++AC_CHECK_HEADERS(xmlrpc_client.h xmlrpc.h, found_xmlrpc=yes)
++if test "$found_xmlrpc" = yes
++then
++  AC_CHECK_LIB(curl, curl_version,
++   LIBS_XMLRPC="-lcurl -lxmlrpc_client -lxmlrpc -lxmlrpc_util -lxmlrpc_xmlparse -lxmlrpc_xmltok"
++   AC_DEFINE([ENABLE_XMLRPC], 1, [Define if you have XML-RPC-Client library installed])
++  )
++fi
++
+ ##if test -z "$G729_SUPPORT"
+ ##then
+ ##  echo "*************************************************************************** $ECHO_C" 1>&6
+@@ -94,4 +105,5 @@ AC_CONFIG_FILES([Makefile])
+ AC_SUBST(AM_CFLAGS)
+ AC_SUBST(LIBS_GSM)
+ AC_SUBST(LIBS_G729)
++AC_SUBST(LIBS_XMLRPC)
+ AC_OUTPUT
+diff --git a/rtpp_command.c b/rtpp_command.c
+index c5734ae..d6072de 100644
+--- a/rtpp_command.c
++++ b/rtpp_command.c
+@@ -69,6 +69,9 @@ struct proto_cap proto_caps[] = {
+     { "20081102", "Support for setting codecs in the update/lookup command" },
+     { "20081224", "Support for session timeout notifications" },
+     { "20090810", "Support for automatic bridging" },
++#ifdef ENABLE_XMLRPC
++    { "20100819", "Support for timeout notifications using XML-RPC towards Kamailio/sip-router.org" },
++#endif
+     { NULL, NULL }
+ };
+ 
+@@ -269,6 +272,7 @@ handle_command(struct cfg *cf, int controlfd, double dtime)
+     char *socket_name_u, *notify_tag;
+     struct sockaddr *local_addr;
+     char c;
++    struct rtpp_timeout_handler * my_timeout_h;
+ 
+     requested_nsamples = -1;
+     ia[0] = ia[1] = NULL;
+@@ -468,7 +472,7 @@ handle_command(struct cfg *cf, int controlfd, double dtime)
+     }
+     call_id = argv[1];
+     if (op == UPDATE || op == LOOKUP || op == PLAY) {
+-	max_argc = (op == UPDATE ? 8 : 6);
++	max_argc = (op == PLAY ? 6 : 8);
+ 	if (argc < 5 || argc > max_argc) {
+ 	    rtpp_log_write(RTPP_LOG_ERR, cf->stable.glog, "command syntax error");
+ 	    reply_error(&cf->stable, controlfd, &raddr, rlen, cookie, 4);
+@@ -478,7 +482,7 @@ handle_command(struct cfg *cf, int controlfd, double dtime)
+ 	to_tag = argv[5];
+ 	if (op == PLAY && argv[0][1] != '\0')
+ 	    playcount = atoi(argv[0] + 1);
+-	if (op == UPDATE && argc > 6) {
++	if (op != PLAY && argc > 6) {
+ 	    socket_name_u = argv[6];
+ 	    if (strncmp("unix:", socket_name_u, 5) == 0)
+ 		socket_name_u += 5;
+@@ -965,25 +969,39 @@ handle_command(struct cfg *cf, int controlfd, double dtime)
+     }
+ 
+     pthread_mutex_lock(&cf->glock);
+-    if (op == UPDATE) {
+-	if (cf->timeout_handler->socket_name == NULL && socket_name_u != NULL)
+-	    rtpp_log_write(RTPP_LOG_ERR, spa->log, "must permit notification socket with -n");
++
++    if ((op == UPDATE) || (op == LOOKUP)){
+ 	if (spa->timeout_data.notify_tag != NULL) {
+ 	    free(spa->timeout_data.notify_tag);
+ 	    spa->timeout_data.notify_tag = NULL;
+ 	}
+-	if (cf->timeout_handler->socket_name != NULL && socket_name_u != NULL) {
+-	    if (strcmp(cf->timeout_handler->socket_name, socket_name_u) != 0) {
+-		rtpp_log_write(RTPP_LOG_ERR, spa->log, "invalid socket name %s", socket_name_u);
+-		socket_name_u = NULL;
+-	    } else {
++        spa->timeout_data.handler = NULL;
++	if (socket_name_u != NULL) {
++	    if (cf->timeout_handler != NULL && cf->timeout_handler->socket_name != NULL 
++		&& strlen(cf->timeout_handler->socket_name) == strlen(socket_name_u)
++		&& strcmp(cf->timeout_handler->socket_name, socket_name_u) != 0) {
+ 		rtpp_log_write(RTPP_LOG_INFO, spa->log, "setting timeout handler");
+ 		spa->timeout_data.handler = cf->timeout_handler;
+ 		spa->timeout_data.notify_tag = strdup(notify_tag);
++	    } else {
++		rtpp_log_write(RTPP_LOG_INFO, spa->log, "setting custom timeout handler (%s)", socket_name_u);
++		my_timeout_h = malloc(sizeof(struct rtpp_timeout_handler));
++		if (my_timeout_h == NULL) {
++			rtpp_log_write(RTPP_LOG_ERR, spa->log, "Unable to allocate memory");
++		} else {
++			memset(my_timeout_h, 0, sizeof(struct rtpp_timeout_handler));
++	    		my_timeout_h->socket_name = (char *)malloc(strlen(socket_name_u) + 1);
++	    		if(my_timeout_h->socket_name != NULL) {
++				strcpy(my_timeout_h->socket_name, socket_name_u);
++				spa->timeout_data.handler = my_timeout_h;
++				if (notify_tag != NULL) spa->timeout_data.notify_tag = strdup(notify_tag);
++				else spa->timeout_data.notify_tag = NULL;
++			} else {
++				rtpp_log_write(RTPP_LOG_ERR, spa->log, "Unable to allocate memory");
++				free(my_timeout_h);
++			}
++		}
+ 	    }
+-	} else if (socket_name_u == NULL && spa->timeout_data.handler != NULL) {
+-	    spa->timeout_data.handler = NULL;
+-	    rtpp_log_write(RTPP_LOG_INFO, spa->log, "disabling timeout handler");
+ 	}
+     }
+ 
+diff --git a/rtpp_notify.c b/rtpp_notify.c
+index e92c9ec..e6b30e4 100644
+--- a/rtpp_notify.c
++++ b/rtpp_notify.c
+@@ -42,10 +42,24 @@
+ #include "rtpp_session.h"
+ #include "rtpp_util.h"
+ 
++#ifdef ENABLE_XMLRPC
++#include <xmlrpc.h>
++#include <xmlrpc_client.h>
++#define XMLRPC_CLIENT_NAME       "XML-RPC RTPProxy Client"
++#define XMLRPC_CLIENT_VERSION    "0.2"
++#endif
++
+ struct rtpp_notify_wi
+ {
+     char *notify_buf;
+     int len;
++#ifdef ENABLE_XMLRPC
++    char *call_id;
++    int call_id_len;
++    char *param;
++    int param_len;
++    int custom_handler;
++#endif
+     struct rtpp_timeout_handler *th;
+     rtpp_log_t glog;
+     struct rtpp_notify_wi *next;
+@@ -258,6 +272,13 @@ rtpp_notify_schedule(struct cfg *cf, struct rtpp_session *sp)
+     if (wi == NULL)
+         return -1;
+ 
++#ifdef ENABLE_XMLRPC
++    if (th != cf->timeout_handler)
++	wi->custom_handler = 1;
++    else 
++	wi->custom_handler = 0;
++#endif
++
+     wi->th = th;
+     if (sp->timeout_data.notify_tag == NULL) {
+         /* two 5-digit numbers, space, \0 and \n */
+@@ -289,6 +310,59 @@ rtpp_notify_schedule(struct cfg *cf, struct rtpp_session *sp)
+         len = snprintf(wi->notify_buf, len, "%s\n",
+           sp->timeout_data.notify_tag);
+     }
++#ifdef ENABLE_XMLRPC
++
++    // rtpp_log_write(RTPP_LOG_ERR, wi->glog, "Timeout socket is: %s (%p)\n", wi->th->socket_name, wi->th->socket_name);
++
++    if (strncmp("xmlrpc:", wi->th->socket_name, 7) == 0) {
++	    // Copy the Socket-Name
++	    len = strlen(wi->th->socket_name)+1;
++	    if (wi->param == NULL) {
++		wi->param = malloc(len);
++		if (wi->param == NULL) {
++		    rtpp_notify_queue_return_free_item(wi);
++		    return -1;
++		}
++	    } else {
++		notify_buf = realloc(wi->param, len);
++		if (notify_buf == NULL) {
++		    rtpp_notify_queue_return_free_item(wi);
++		    return -1;
++		}
++		wi->param = notify_buf;
++	    }
++	    memset(wi->param, '\0', len);
++	    len = snprintf(wi->param, len, "%s",
++		  wi->th->socket_name);
++	    wi->param_len = len;
++
++	   // rtpp_log_write(RTPP_LOG_ERR, wi->glog, "wi->param %s (%p)\n", wi->param, wi->param);
++
++	    // Copy the Call-ID:
++	    len = strlen(sp->call_id)+1;
++	    if (wi->call_id == NULL) {
++		wi->call_id = malloc(len);
++		if (wi->call_id == NULL) {
++		    rtpp_notify_queue_return_free_item(wi);
++		    return -1;
++		}
++	    } else {
++		notify_buf = realloc(wi->call_id, len);
++		if (notify_buf == NULL) {
++		    rtpp_notify_queue_return_free_item(wi);
++		    return -1;
++		}
++		wi->call_id = notify_buf;
++	    }
++	    memset(wi->call_id, '\0', len);
++	    len = snprintf(wi->call_id, len, "%s",
++		  sp->call_id);
++	    wi->call_id_len = len;
++
++	  // rtpp_log_write(RTPP_LOG_ERR, wi->glog, "wi->call_id %s (%p)\n", wi->call_id, wi->call_id);
++
++    }
++#endif
+ 
+     wi->glog = cf->stable.glog;
+ 
+@@ -345,29 +419,72 @@ reconnect_timeout_handler(rtpp_log_t log, struct rtpp_timeout_handler *th)
+     }
+ }
+ 
++#ifdef ENABLE_XMLRPC
++static int
++do_xmlrpc_timeout_notification(rtpp_log_t log, struct rtpp_notify_wi *wi) {
++    xmlrpc_env env;
++    xmlrpc_value *result;
++    
++    /* Start up our XML-RPC client library. */
++    xmlrpc_client_init(XMLRPC_CLIENT_NO_FLAGS, XMLRPC_CLIENT_NAME, XMLRPC_CLIENT_VERSION);
++    xmlrpc_env_init(&env);
++
++    /* Get the dialog-Info: */
++    result = xmlrpc_client_call(&env, wi->param+7,
++                                "dlg_terminate_dlg", "(s)",
++                                wi->call_id);
++    if (env.fault_occurred) {
++        rtpp_log_write(RTPP_LOG_ERR, wi->glog, "%s: XML-RPC Fault: %s (%d)\n", wi->call_id, env.fault_string, env.fault_code);
++        return -1;
++    }
++    
++    /* Dispose of our result value. */
++    xmlrpc_DECREF(result);
++
++    /* Shutdown our XML-RPC client library. */
++    xmlrpc_env_clean(&env);
++    xmlrpc_client_cleanup();
++
++    return 0;
++}
++#endif
++
+ static void
+ do_timeout_notification(struct rtpp_notify_wi *wi, int retries)
+ {
+     int result;
+ 
+-    if (wi->th->connected == 0) {
+-        reconnect_timeout_handler(wi->glog, wi->th);
+-
+-        /* If connect fails, no notification will be sent */
+-        if (wi->th->connected == 0) {
+-            rtpp_log_write(RTPP_LOG_ERR, wi->glog, "unable to send timeout notification");
+-            return;
+-        }
++    if (strncmp("xmlrpc:", wi->th->socket_name, 7) == 0) {
++	result = do_xmlrpc_timeout_notification(wi->glog, wi);
++    } else {
++	    if (wi->th->connected == 0) {
++		reconnect_timeout_handler(wi->glog, wi->th);
++
++		/* If connect fails, no notification will be sent */
++		if (wi->th->connected == 0) {
++		    rtpp_log_write(RTPP_LOG_ERR, wi->glog, "unable to send timeout notification");
++		    return;
++		}
++	    }
++
++	    do {
++		result = send(wi->th->fd, wi->notify_buf, wi->len - 1, 0);
++	    } while (result == -1 && errno == EINTR);
+     }
+ 
+-    do {
+-        result = send(wi->th->fd, wi->notify_buf, wi->len - 1, 0);
+-    } while (result == -1 && errno == EINTR);
+-
+     if (result < 0) {
+         wi->th->connected = 0;
+         rtpp_log_ewrite(RTPP_LOG_ERR, wi->glog, "failed to send timeout notification");
+         if (retries > 0)
+             do_timeout_notification(wi, retries - 1);
+     }
++#ifdef ENABLE_XMLRPC
++    // In case we use a custom timeout handler, we have to free it.
++    if (wi->th && (wi->custom_handler == 1)) {
++ 	free(wi->th->socket_name);
++	free(wi->th);
++	wi->th = 0;
++    }
++#endif
++
+ }
+diff --git a/rtpp_session.c b/rtpp_session.c
+index 03e3d8a..51b3319 100644
+--- a/rtpp_session.c
++++ b/rtpp_session.c
+@@ -41,6 +41,7 @@
+ #include "rtpp_record.h"
+ #include "rtpp_session.h"
+ #include "rtpp_util.h"
++#include "rtpp_notify.h"
+ 
+ void
+ init_hash_table(struct cfg_stable *cf)
--- a/src/modules/sanity/sanity.c
+++ b/src/modules/sanity/sanity.c
@@ -698,6 +698,10 @@ int check_proxy_require(sip_msg_t* msg)
 				}
 				LM_DBG("checking proxy require failed\n");
 				if (u) pkg_free(u);
+				if (msg->proxy_require->parsed) {
+					free_str_list(msg->proxy_require->parsed);
+					msg->proxy_require->parsed = NULL;
+				}
 				return SANITY_CHECK_FAILED;
 			}
 			else {
--- a/src/modules/sca/sca_util.c
+++ b/src/modules/sca/sca_util.c
@@ -1,477 +1,477 @@
-/*
- * Copyright (C) 2012 Andrew Mortensen
- *
- * This file is part of the sca module for Kamailio, a free SIP server.
- *
- * The sca module is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version
- *
- * The sca module is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA. 02110-1301 USA
- */
-#include "sca_common.h"
-#include "sca.h"
-#include <assert.h>
-
-#include "sca_util.h"
-#include "../../core/dset.h"
-#include "../../core/parser/sdp/sdp.h"
-
-int sca_get_msg_method(sip_msg_t *msg)
-{
-	assert(msg != NULL);
-
-	if (msg->first_line.type == SIP_REQUEST) {
-		return (msg->REQ_METHOD);
-	}
-
-	return (sca_get_msg_cseq_method(msg));
-}
-
-int sca_get_msg_contact_uri(sip_msg_t *msg, str *contact_uri)
-{
-	contact_body_t *contact_body;
-
-	assert(msg != NULL);
-	assert(contact_uri != NULL);
-
-	if (SCA_HEADER_EMPTY(msg->contact)) {
-		LM_DBG("Empty Contact header\n");
-		contact_uri->s = NULL;
-		contact_uri->len = 0;
-
-		return (0);
-	}
-
-	if (parse_contact(msg->contact) < 0) {
-		LM_ERR("Failed to parse Contact header: %.*s\n",
-				STR_FMT(&msg->contact->body));
-		return (-1);
-	}
-	if ((contact_body = (contact_body_t *) msg->contact->parsed) == NULL) {
-		LM_ERR("Invalid Contact header: %.*s\n", STR_FMT(&msg->contact->body));
-		return (-1);
-	}
-	if (contact_body->star) {
-		LM_ERR("Invalid Contact header: SCA Contact must not be \"*\"\n");
-		return (-1);
-	}
-	if (contact_body->contacts == NULL) {
-		LM_ERR("Invalid Contact header: parser found no contacts\n");
-		return (-1);
-	}
-	if (contact_body->contacts->next) {
-		LM_ERR("Invalid Contact header: Contact may only contain one URI\n");
-		return (-1);
-	}
-
-	contact_uri->s = contact_body->contacts->uri.s;
-	contact_uri->len = contact_body->contacts->uri.len;
-
-	return (1);
-}
-
-int sca_get_msg_cseq_number(sip_msg_t *msg)
-{
-	int cseq;
-
-	assert(msg != NULL);
-
-	if (SCA_HEADER_EMPTY(msg->cseq)) {
-		LM_ERR("Empty Cseq header\n");
-		return (-1);
-	}
-	if (str2int(&(get_cseq(msg)->number), (unsigned int *) &cseq) != 0) {
-		LM_ERR("Bad Cseq header: %.*s\n", STR_FMT(&msg->cseq->body));
-		return (-1);
-	}
-
-	return (cseq);
-}
-
-/*
- *  assumes cseq header in msg is already parsed
- */
-int sca_get_msg_cseq_method(sip_msg_t *msg)
-{
-	assert(msg != NULL);
-
-	if (SCA_HEADER_EMPTY(msg->cseq)) {
-		LM_ERR("Empty Cseq header\n");
-		return (-1);
-	}
-
-	return (get_cseq(msg)->method_id);
-}
-
-int sca_get_msg_from_header(sip_msg_t *msg, struct to_body **from)
-{
-	struct to_body *f;
-
-	assert(msg != NULL);
-	assert(from != NULL);
-
-	if (SCA_HEADER_EMPTY(msg->from)) {
-		LM_ERR("Empty From header\n");
-		return (-1);
-	}
-	if (parse_from_header(msg) < 0) {
-		LM_ERR("Bad From header\n");
-		return (-1);
-	}
-	f = get_from(msg);
-	if (SCA_STR_EMPTY(&f->tag_value)) {
-		LM_ERR("Bad From header: no tag parameter\n");
-		return (-1);
-	}
-
-	// ensure the URI is parsed for future use
-	if (parse_uri(f->uri.s, f->uri.len, GET_FROM_PURI(msg)) < 0) {
-		LM_ERR("Failed to parse From URI %.*s\n", STR_FMT(&f->uri));
-		return (-1);
-	}
-
-	*from = f;
-
-	return (0);
-}
-
-int sca_get_msg_to_header(sip_msg_t *msg, struct to_body **to)
-{
-	struct to_body parsed_to;
-	struct to_body *t = NULL;
-
-	assert(msg != NULL);
-	assert(to != NULL);
-
-	if (SCA_HEADER_EMPTY(msg->to)) {
-		LM_ERR("Empty To header\n");
-		return (-1);
-	}
-	t = get_to(msg);
-	if (t == NULL) {
-		parse_to(msg->to->body.s, msg->to->body.s + msg->to->body.len + 1, // end of buffer
-		&parsed_to);
-		if (parsed_to.error != PARSE_OK) {
-			LM_ERR("Bad To header\n");
-			return (-1);
-		}
-		t = &parsed_to;
-	}
-
-	// ensure the URI is parsed for future use
-	if (parse_uri(t->uri.s, t->uri.len, GET_TO_PURI(msg)) < 0) {
-		LM_ERR("Failed to parse To URI %.*s\n", STR_FMT(&t->uri));
-		return (-1);
-	}
-
-	*to = t;
-
-	return (0);
-}
-
-/*
- * caller needs to call free_to for *body
- */
-int sca_build_to_body_from_uri(sip_msg_t *msg, struct to_body **body, str *uri)
-{
-	assert(msg != NULL);
-	assert(body != NULL);
-	assert(uri != NULL);
-
-	*body = pkg_malloc(sizeof(struct to_body));
-	if(*body == NULL) {
-		LM_ERR("cannot allocate pkg memory\n");
-		return(-1);
-	}
-
-	parse_to(uri->s, uri->s + uri->len + 1, *body);
-	if ((*body)->error != PARSE_OK) {
-		LM_ERR("Bad uri value[%.*s]\n", STR_FMT(uri));
-		free_to(*body);
-		return(-1);
-	}
-	return (0);
-}
-
-/*
- *  count characters requiring escape as defined by escape_common
- */
-int sca_uri_display_escapes_count(str *display) {
-	int c = 0;
-	int i;
-
-	if (SCA_STR_EMPTY(display)) {
-		return (0);
-	}
-
-	for (i = 0; i < display->len; i++) {
-		switch (display->s[i]) {
-		case '\'':
-		case '"':
-		case '\\':
-		case '\0':
-			c++;
-
-		default:
-			break;
-		}
-	}
-
-	return (c);
-}
-
-int sca_uri_extract_aor(str *uri, str *aor)
-{
-	char *semi;
-
-	assert(aor != NULL);
-
-	if (uri == NULL) {
-		aor->s = NULL;
-		aor->len = 0;
-		return (-1);
-	}
-
-	aor->s = uri->s;
-	semi = memchr(uri->s, ';', uri->len);
-	if (semi != NULL) {
-		aor->len = semi - uri->s;
-	} else {
-		aor->len = uri->len;
-	}
-
-	return (0);
-}
-
-int sca_uri_build_aor(str *aor, int maxlen, str *contact_uri, str *domain_uri)
-{
-	char *p;
-	char *dp;
-	int len;
-
-	assert(aor != NULL);
-	assert(contact_uri != NULL);
-	assert(domain_uri != NULL);
-
-	if (contact_uri->len + domain_uri->len >= maxlen) {
-		return (-1);
-	}
-
-	p = memchr(contact_uri->s, '@', contact_uri->len);
-	if (p == NULL) {
-		// no username, by definition can't be an SCA line
-		aor->s = NULL;
-		aor->len = 0;
-
-		return (0);
-	}
-	dp = memchr(domain_uri->s, '@', domain_uri->len);
-	if (dp == NULL) {
-		// may be nameless URI
-		dp = memchr(domain_uri->s, ':', domain_uri->len);
-		if (dp == NULL) {
-			// bad domain URI
-			return (-1);
-		}
-	}
-	dp++;
-
-	len = p - contact_uri->s;
-	memcpy(aor->s, contact_uri->s, len);
-	aor->s[len] = '@';
-	len += 1;
-	aor->len = len;
-
-	len = domain_uri->len - (dp - domain_uri->s);
-	memcpy(aor->s + aor->len, dp, len);
-	aor->len += len;
-
-	return (aor->len);
-}
-
-int sca_aor_create_from_info(str *aor, uri_type type, str *user, str *domain,
-		str *port)
-{
-	str scheme = STR_NULL;
-	int len = 0;
-
-	assert(aor != NULL);
-
-	uri_type_to_str(type, &scheme);
-
-	// +1 for ':', +1 for '@'
-	len = scheme.len + 1 + user->len + 1 + domain->len;
-	if (!SCA_STR_EMPTY(port)) {
-		// +1 for ':'
-		len += 1 + port->len;
-	}
-
-	aor->s = (char *) pkg_malloc(len);
-	if (aor->s == NULL) {
-		LM_ERR("sca_aor_create_from_info: pkg_malloc %d bytes failed\n", len);
-		return (-1);
-	}
-
-	len = 0;
-	SCA_STR_COPY(aor, &scheme);
-	len += scheme.len;
-
-	*(aor->s + len) = ':';
-	aor->len++;
-	len++;
-
-	SCA_STR_APPEND(aor, user);
-	len += user->len;
-
-	*(aor->s + len) = '@';
-	aor->len++;
-	len++;
-
-	SCA_STR_APPEND(aor, domain);
-	len += domain->len;
-
-	if (!SCA_STR_EMPTY(port)) {
-		*(aor->s + len) = ':';
-		len += 1;
-
-		SCA_STR_APPEND(aor, port);
-		len += port->len;
-	}
-
-	return (aor->len);
-}
-
-int sca_create_canonical_aor_for_ua(sip_msg_t *msg, str *c_aor, int ua_opts)
-{
-	struct to_body *tf = NULL;
-	sip_uri_t c_uri;
-	str tf_aor = STR_NULL;
-	str contact_uri = STR_NULL;
-	int rc = -1;
-
-	assert(msg != NULL);
-	assert(c_aor != NULL);
-
-	memset(c_aor, 0, sizeof(str));
-
-	if ((ua_opts & SCA_AOR_TYPE_AUTO)) {
-		if (msg->first_line.type == SIP_REQUEST) {
-			ua_opts = SCA_AOR_TYPE_UAC;
-		} else {
-			ua_opts = SCA_AOR_TYPE_UAS;
-		}
-	}
-
-	if ((ua_opts & SCA_AOR_TYPE_UAC)) {
-		if (sca_get_msg_from_header(msg, &tf) < 0) {
-			LM_ERR("sca_create_canonical_aor: failed to get From header\n");
-			goto done;
-		}
-	} else {
-		if (sca_get_msg_to_header(msg, &tf) < 0) {
-			LM_ERR("sca_create_canonical_aor: failed to get To header\n");
-			goto done;
-		}
-	}
-
-	if (sca_uri_extract_aor(&tf->uri, &tf_aor) < 0) {
-		LM_ERR("sca_create_canonical_aor: failed to extract AoR from "
-				"URI <%.*s>\n", STR_FMT(&tf->uri));
-		goto done;
-	}
-
-	memset(&c_uri, 0, sizeof(sip_uri_t));
-	if ((rc = sca_get_msg_contact_uri(msg, &contact_uri)) < 0) {
-		LM_ERR("sca_create_canonical_aor: failed to get contact URI from "
-				"Contact <%.*s>\n", STR_FMT(&msg->contact->body));
-		goto done;
-	}
-	if (rc > 0) {
-		if (parse_uri(contact_uri.s, contact_uri.len, &c_uri) < 0) {
-			LM_ERR("sca_create_canonical_aor: failed to parse Contact URI "
-					"<%.*s>\n", STR_FMT(&contact_uri));
-			rc = -1;
-			goto done;
-		}
-	}
-
-	if (SCA_STR_EMPTY(&c_uri.user) ||
-	SCA_STR_EQ(&c_uri.user, &tf->parsed_uri.user)) {
-		// empty contact header or Contact user matches To/From AoR
-		c_aor->s = (char *) pkg_malloc(tf_aor.len);
-		c_aor->len = tf_aor.len;
-		memcpy(c_aor->s, tf_aor.s, tf_aor.len);
-	} else {
-		// Contact user and To/From user mismatch
-		if (sca_aor_create_from_info(c_aor, c_uri.type, &c_uri.user,
-				&tf->parsed_uri.host, &tf->parsed_uri.port) < 0) {
-			LM_ERR("sca_create_canonical_aor: failed to create AoR from "
-					"Contact <%.*s> and URI <%.*s>\n",
-					STR_FMT(&contact_uri), STR_FMT(&tf_aor));
-			goto done;
-		}
-	}
-
-	rc = 1;
-
-	done: return (rc);
-}
-
-int sca_create_canonical_aor(sip_msg_t *msg, str *c_aor)
-{
-	return (sca_create_canonical_aor_for_ua(msg, c_aor, SCA_AOR_TYPE_AUTO));
-}
-
-/*
- * XXX this considers any held stream to mean the call is on hold. correct?
- */
-int sca_call_is_held(sip_msg_t *msg)
-{
-	sdp_session_cell_t *session;
-	sdp_stream_cell_t *stream;
-	int n_sess;
-	int n_str;
-	int is_held = 0;
-	int rc;
-
-	if(sca->cfg->onhold_bflag >= 0) {
-		if (isbflagset(0, (flag_t)sca->cfg->onhold_bflag)==1) {
-			LM_DBG("onhold_bflag set, skip parse_sdp and set held\n");
-			return ( 1 );
-		}
-	}
-	rc = parse_sdp(msg);
-	if (rc < 0) {
-		LM_ERR("sca_call_is_held: parse_sdp body failed\n");
-		return (0);
-	} else if (rc > 0) {
-		LM_DBG("sca_call_is_held: parse_sdp returned %d, no SDP body\n", rc);
-		return (0);
-	}
-
-	// Cf. modules_k/textops's exported is_audio_on_hold
-	for (n_sess = 0, session = get_sdp_session(msg, n_sess); session != NULL;
-			n_sess++, session = get_sdp_session(msg, n_sess)) {
-
-		for (n_str = 0, stream = get_sdp_stream(msg, n_sess, n_str);
-				stream != NULL;
-				n_str++, stream = get_sdp_stream(msg, n_sess, n_str)) {
-			if (stream->is_on_hold) {
-				LM_DBG("sca_call_is_held: parse_sdp detected stream is on hold\n");
-				is_held = 1;
-				goto done;
-			}
-		}
-	}
-
-	done: return (is_held);
-}
+/*
+ * Copyright (C) 2012 Andrew Mortensen
+ *
+ * This file is part of the sca module for Kamailio, a free SIP server.
+ *
+ * The sca module is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version
+ *
+ * The sca module is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA. 02110-1301 USA
+ */
+#include "sca_common.h"
+#include "sca.h"
+#include <assert.h>
+
+#include "sca_util.h"
+#include "../../core/dset.h"
+#include "../../core/parser/sdp/sdp.h"
+
+int sca_get_msg_method(sip_msg_t *msg)
+{
+	assert(msg != NULL);
+
+	if (msg->first_line.type == SIP_REQUEST) {
+		return (msg->REQ_METHOD);
+	}
+
+	return (sca_get_msg_cseq_method(msg));
+}
+
+int sca_get_msg_contact_uri(sip_msg_t *msg, str *contact_uri)
+{
+	contact_body_t *contact_body;
+
+	assert(msg != NULL);
+	assert(contact_uri != NULL);
+
+	if (SCA_HEADER_EMPTY(msg->contact)) {
+		LM_DBG("Empty Contact header\n");
+		contact_uri->s = NULL;
+		contact_uri->len = 0;
+
+		return (0);
+	}
+
+	if (parse_contact(msg->contact) < 0) {
+		LM_ERR("Failed to parse Contact header: %.*s\n",
+				STR_FMT(&msg->contact->body));
+		return (-1);
+	}
+	if ((contact_body = (contact_body_t *) msg->contact->parsed) == NULL) {
+		LM_ERR("Invalid Contact header: %.*s\n", STR_FMT(&msg->contact->body));
+		return (-1);
+	}
+	if (contact_body->star) {
+		LM_ERR("Invalid Contact header: SCA Contact must not be \"*\"\n");
+		return (-1);
+	}
+	if (contact_body->contacts == NULL) {
+		LM_ERR("Invalid Contact header: parser found no contacts\n");
+		return (-1);
+	}
+	if (contact_body->contacts->next) {
+		LM_ERR("Invalid Contact header: Contact may only contain one URI\n");
+		return (-1);
+	}
+
+	contact_uri->s = contact_body->contacts->uri.s;
+	contact_uri->len = contact_body->contacts->uri.len;
+
+	return (1);
+}
+
+int sca_get_msg_cseq_number(sip_msg_t *msg)
+{
+	int cseq;
+
+	assert(msg != NULL);
+
+	if (SCA_HEADER_EMPTY(msg->cseq)) {
+		LM_ERR("Empty Cseq header\n");
+		return (-1);
+	}
+	if (str2int(&(get_cseq(msg)->number), (unsigned int *) &cseq) != 0) {
+		LM_ERR("Bad Cseq header: %.*s\n", STR_FMT(&msg->cseq->body));
+		return (-1);
+	}
+
+	return (cseq);
+}
+
+/*
+ *  assumes cseq header in msg is already parsed
+ */
+int sca_get_msg_cseq_method(sip_msg_t *msg)
+{
+	assert(msg != NULL);
+
+	if (SCA_HEADER_EMPTY(msg->cseq)) {
+		LM_ERR("Empty Cseq header\n");
+		return (-1);
+	}
+
+	return (get_cseq(msg)->method_id);
+}
+
+int sca_get_msg_from_header(sip_msg_t *msg, struct to_body **from)
+{
+	struct to_body *f;
+
+	assert(msg != NULL);
+	assert(from != NULL);
+
+	if (SCA_HEADER_EMPTY(msg->from)) {
+		LM_ERR("Empty From header\n");
+		return (-1);
+	}
+	if (parse_from_header(msg) < 0) {
+		LM_ERR("Bad From header\n");
+		return (-1);
+	}
+	f = get_from(msg);
+	if (SCA_STR_EMPTY(&f->tag_value)) {
+		LM_ERR("Bad From header: no tag parameter\n");
+		return (-1);
+	}
+
+	// ensure the URI is parsed for future use
+	if (parse_uri(f->uri.s, f->uri.len, GET_FROM_PURI(msg)) < 0) {
+		LM_ERR("Failed to parse From URI %.*s\n", STR_FMT(&f->uri));
+		return (-1);
+	}
+
+	*from = f;
+
+	return (0);
+}
+
+int sca_get_msg_to_header(sip_msg_t *msg, struct to_body **to)
+{
+	struct to_body parsed_to;
+	struct to_body *t = NULL;
+
+	assert(msg != NULL);
+	assert(to != NULL);
+
+	if (SCA_HEADER_EMPTY(msg->to)) {
+		LM_ERR("Empty To header\n");
+		return (-1);
+	}
+	t = get_to(msg);
+	if (t == NULL) {
+		parse_to(msg->to->body.s, msg->to->body.s + msg->to->body.len + 1, // end of buffer
+		&parsed_to);
+		if (parsed_to.error != PARSE_OK) {
+			LM_ERR("Bad To header\n");
+			return (-1);
+		}
+		t = &parsed_to;
+	}
+
+	// ensure the URI is parsed for future use
+	if (parse_uri(t->uri.s, t->uri.len, GET_TO_PURI(msg)) < 0) {
+		LM_ERR("Failed to parse To URI %.*s\n", STR_FMT(&t->uri));
+		return (-1);
+	}
+
+	*to = t;
+
+	return (0);
+}
+
+/*
+ * caller needs to call free_to for *body
+ */
+int sca_build_to_body_from_uri(sip_msg_t *msg, struct to_body **body, str *uri)
+{
+	assert(msg != NULL);
+	assert(body != NULL);
+	assert(uri != NULL);
+
+	*body = pkg_malloc(sizeof(struct to_body));
+	if(*body == NULL) {
+		LM_ERR("cannot allocate pkg memory\n");
+		return(-1);
+	}
+
+	parse_to(uri->s, uri->s + uri->len + 1, *body);
+	if ((*body)->error != PARSE_OK) {
+		LM_ERR("Bad uri value[%.*s]\n", STR_FMT(uri));
+		free_to(*body);
+		return(-1);
+	}
+	return (0);
+}
+
+/*
+ *  count characters requiring escape as defined by escape_common
+ */
+int sca_uri_display_escapes_count(str *display) {
+	int c = 0;
+	int i;
+
+	if (SCA_STR_EMPTY(display)) {
+		return (0);
+	}
+
+	for (i = 0; i < display->len; i++) {
+		switch (display->s[i]) {
+		case '\'':
+		case '"':
+		case '\\':
+		case '\0':
+			c++;
+
+		default:
+			break;
+		}
+	}
+
+	return (c);
+}
+
+int sca_uri_extract_aor(str *uri, str *aor)
+{
+	char *semi;
+
+	assert(aor != NULL);
+
+	if (uri == NULL) {
+		aor->s = NULL;
+		aor->len = 0;
+		return (-1);
+	}
+
+	aor->s = uri->s;
+	semi = memchr(uri->s, ';', uri->len);
+	if (semi != NULL) {
+		aor->len = semi - uri->s;
+	} else {
+		aor->len = uri->len;
+	}
+
+	return (0);
+}
+
+int sca_uri_build_aor(str *aor, int maxlen, str *contact_uri, str *domain_uri)
+{
+	char *p;
+	char *dp;
+	int len;
+
+	assert(aor != NULL);
+	assert(contact_uri != NULL);
+	assert(domain_uri != NULL);
+
+	if (contact_uri->len + domain_uri->len >= maxlen) {
+		return (-1);
+	}
+
+	p = memchr(contact_uri->s, '@', contact_uri->len);
+	if (p == NULL) {
+		// no username, by definition can't be an SCA line
+		aor->s = NULL;
+		aor->len = 0;
+
+		return (0);
+	}
+	dp = memchr(domain_uri->s, '@', domain_uri->len);
+	if (dp == NULL) {
+		// may be nameless URI
+		dp = memchr(domain_uri->s, ':', domain_uri->len);
+		if (dp == NULL) {
+			// bad domain URI
+			return (-1);
+		}
+	}
+	dp++;
+
+	len = p - contact_uri->s;
+	memcpy(aor->s, contact_uri->s, len);
+	aor->s[len] = '@';
+	len += 1;
+	aor->len = len;
+
+	len = domain_uri->len - (dp - domain_uri->s);
+	memcpy(aor->s + aor->len, dp, len);
+	aor->len += len;
+
+	return (aor->len);
+}
+
+int sca_aor_create_from_info(str *aor, uri_type type, str *user, str *domain,
+		str *port)
+{
+	str scheme = STR_NULL;
+	int len = 0;
+
+	assert(aor != NULL);
+
+	uri_type_to_str(type, &scheme);
+
+	// +1 for ':', +1 for '@'
+	len = scheme.len + 1 + user->len + 1 + domain->len;
+	if (!SCA_STR_EMPTY(port)) {
+		// +1 for ':'
+		len += 1 + port->len;
+	}
+
+	aor->s = (char *) pkg_malloc(len);
+	if (aor->s == NULL) {
+		LM_ERR("sca_aor_create_from_info: pkg_malloc %d bytes failed\n", len);
+		return (-1);
+	}
+
+	len = 0;
+	SCA_STR_COPY(aor, &scheme);
+	len += scheme.len;
+
+	*(aor->s + len) = ':';
+	aor->len++;
+	len++;
+
+	SCA_STR_APPEND(aor, user);
+	len += user->len;
+
+	*(aor->s + len) = '@';
+	aor->len++;
+	len++;
+
+	SCA_STR_APPEND(aor, domain);
+	len += domain->len;
+
+	if (!SCA_STR_EMPTY(port)) {
+		*(aor->s + len) = ':';
+		len += 1;
+
+		SCA_STR_APPEND(aor, port);
+		len += port->len;
+	}
+
+	return (aor->len);
+}
+
+int sca_create_canonical_aor_for_ua(sip_msg_t *msg, str *c_aor, int ua_opts)
+{
+	struct to_body *tf = NULL;
+	sip_uri_t c_uri;
+	str tf_aor = STR_NULL;
+	str contact_uri = STR_NULL;
+	int rc = -1;
+
+	assert(msg != NULL);
+	assert(c_aor != NULL);
+
+	memset(c_aor, 0, sizeof(str));
+
+	if ((ua_opts & SCA_AOR_TYPE_AUTO)) {
+		if (msg->first_line.type == SIP_REQUEST) {
+			ua_opts = SCA_AOR_TYPE_UAC;
+		} else {
+			ua_opts = SCA_AOR_TYPE_UAS;
+		}
+	}
+
+	if ((ua_opts & SCA_AOR_TYPE_UAC)) {
+		if (sca_get_msg_from_header(msg, &tf) < 0) {
+			LM_ERR("sca_create_canonical_aor: failed to get From header\n");
+			goto done;
+		}
+	} else {
+		if (sca_get_msg_to_header(msg, &tf) < 0) {
+			LM_ERR("sca_create_canonical_aor: failed to get To header\n");
+			goto done;
+		}
+	}
+
+	if (sca_uri_extract_aor(&tf->uri, &tf_aor) < 0) {
+		LM_ERR("sca_create_canonical_aor: failed to extract AoR from "
+				"URI <%.*s>\n", STR_FMT(&tf->uri));
+		goto done;
+	}
+
+	memset(&c_uri, 0, sizeof(sip_uri_t));
+	if ((rc = sca_get_msg_contact_uri(msg, &contact_uri)) < 0) {
+		LM_ERR("sca_create_canonical_aor: failed to get contact URI from "
+				"Contact <%.*s>\n", STR_FMT(&msg->contact->body));
+		goto done;
+	}
+	if (rc > 0) {
+		if (parse_uri(contact_uri.s, contact_uri.len, &c_uri) < 0) {
+			LM_ERR("sca_create_canonical_aor: failed to parse Contact URI "
+					"<%.*s>\n", STR_FMT(&contact_uri));
+			rc = -1;
+			goto done;
+		}
+	}
+
+	if (SCA_STR_EMPTY(&c_uri.user) ||
+	SCA_STR_EQ(&c_uri.user, &tf->parsed_uri.user)) {
+		// empty contact header or Contact user matches To/From AoR
+		c_aor->s = (char *) pkg_malloc(tf_aor.len);
+		c_aor->len = tf_aor.len;
+		memcpy(c_aor->s, tf_aor.s, tf_aor.len);
+	} else {
+		// Contact user and To/From user mismatch
+		if (sca_aor_create_from_info(c_aor, c_uri.type, &c_uri.user,
+				&tf->parsed_uri.host, &tf->parsed_uri.port) < 0) {
+			LM_ERR("sca_create_canonical_aor: failed to create AoR from "
+					"Contact <%.*s> and URI <%.*s>\n",
+					STR_FMT(&contact_uri), STR_FMT(&tf_aor));
+			goto done;
+		}
+	}
+
+	rc = 1;
+
+	done: return (rc);
+}
+
+int sca_create_canonical_aor(sip_msg_t *msg, str *c_aor)
+{
+	return (sca_create_canonical_aor_for_ua(msg, c_aor, SCA_AOR_TYPE_AUTO));
+}
+
+/*
+ * XXX this considers any held stream to mean the call is on hold. correct?
+ */
+int sca_call_is_held(sip_msg_t *msg)
+{
+	sdp_session_cell_t *session;
+	sdp_stream_cell_t *stream;
+	int n_sess;
+	int n_str;
+	int is_held = 0;
+	int rc;
+
+	if(sca->cfg->onhold_bflag >= 0) {
+		if (isbflagset(0, (flag_t)sca->cfg->onhold_bflag)==1) {
+			LM_DBG("onhold_bflag set, skip parse_sdp and set held\n");
+			return ( 1 );
+		}
+	}
+	rc = parse_sdp(msg);
+	if (rc < 0) {
+		LM_ERR("sca_call_is_held: parse_sdp body failed\n");
+		return (0);
+	} else if (rc > 0) {
+		LM_DBG("sca_call_is_held: parse_sdp returned %d, no SDP body\n", rc);
+		return (0);
+	}
+
+	// Cf. modules_k/textops's exported is_audio_on_hold
+	for (n_sess = 0, session = get_sdp_session(msg, n_sess); session != NULL;
+			n_sess++, session = get_sdp_session(msg, n_sess)) {
+
+		for (n_str = 0, stream = get_sdp_stream(msg, n_sess, n_str);
+				stream != NULL;
+				n_str++, stream = get_sdp_stream(msg, n_sess, n_str)) {
+			if (stream->is_on_hold) {
+				LM_DBG("sca_call_is_held: parse_sdp detected stream is on hold\n");
+				is_held = 1;
+				goto done;
+			}
+		}
+	}
+
+	done: return (is_held);
+}
--- a/src/modules/sdpops/sdpops_mod.c
+++ b/src/modules/sdpops/sdpops_mod.c
@@ -2187,6 +2187,16 @@ static sr_kemi_t sr_kemi_sdpops_exports[
 		{ SR_KEMIP_STR, SR_KEMIP_NONE, SR_KEMIP_NONE,
 			SR_KEMIP_NONE, SR_KEMIP_NONE, SR_KEMIP_NONE }
 	},
+	{ str_init("sdpops"), str_init("sdp_with_codecs_by_id"),
+		SR_KEMIP_INT, sdp_with_codecs_by_id,
+		{ SR_KEMIP_STR, SR_KEMIP_NONE, SR_KEMIP_NONE,
+			SR_KEMIP_NONE, SR_KEMIP_NONE, SR_KEMIP_NONE }
+	},
+	{ str_init("sdpops"), str_init("sdp_with_codecs_by_name"),
+		SR_KEMIP_INT, sdp_with_codecs_by_name,
+		{ SR_KEMIP_STR, SR_KEMIP_NONE, SR_KEMIP_NONE,
+			SR_KEMIP_NONE, SR_KEMIP_NONE, SR_KEMIP_NONE }
+	},
 	{ str_init("sdpops"), str_init("sdp_get"),
 		SR_KEMIP_INT, ki_sdp_get,
 		{ SR_KEMIP_STR, SR_KEMIP_NONE, SR_KEMIP_NONE,
--- a/src/modules/sipt/sipt.c
+++ b/src/modules/sipt/sipt.c
@@ -339,6 +339,7 @@ static int sipt_get_redirection_number(s
 	str body;
 	body.s = get_body_part(msg, TYPE_APPLICATION,SUBTYPE_ISUP,&body.len);
 
+	sb_s_buf[0] = '\0';
 	if(body.s == NULL)
 	{
 		LM_INFO("No ISUP Message Found");
@@ -350,9 +351,9 @@ static int sipt_get_redirection_number(s
 		LM_DBG("message not an ACM or CPG\n");
 		return -1;
 	}
-	
+
 	isup_get_redirection_number((unsigned char*)body.s, body.len, sb_s_buf);
-	
+
 	if (strlen(sb_s_buf) > 0)
 	{
 		pv_get_strzval(msg, param, res, sb_s_buf);
--- a/src/modules/siptrace/siptrace.c
+++ b/src/modules/siptrace/siptrace.c
@@ -497,14 +497,14 @@ static int sip_trace_store(siptrace_data
 
 static int sip_trace_store_db(siptrace_data_t *sto)
 {
+	if(trace_to_database_flag == NULL || *trace_to_database_flag == 0)
+		goto done;
+
 	if(db_con == NULL) {
 		LM_DBG("database connection not initialized\n");
 		return -1;
 	}
 
-	if(trace_to_database_flag == NULL || *trace_to_database_flag == 0)
-		goto done;
-
 	db_key_t db_keys[NR_KEYS];
 	db_val_t db_vals[NR_KEYS];
 
--- a/src/modules/siputils/options.c
+++ b/src/modules/siputils/options.c
@@ -41,13 +41,14 @@ static str opt_200_rpl = str_init("OK");
 static str opt_500_rpl = str_init("Server internal error");
 
 
-int opt_reply(struct sip_msg* _msg, char* _foo, char* _bar) {
+int ki_opt_reply(struct sip_msg* _msg) {
 	str rpl_hf;
 	int offset = 0;
 
 	/* check if it is called for an OPTIONS request */
 	if (_msg->REQ_METHOD!=METHOD_OPTIONS) {
-		LM_ERR("called for non-OPTIONS request\n");
+		LM_ERR("called for non-OPTIONS request (%d!=%d)\n",
+				_msg->REQ_METHOD, METHOD_OPTIONS);
 		return -1;
 	}
 	if(_msg->parsed_uri_ok==0 && parse_sip_msg_uri(_msg)<0)
@@ -127,3 +128,6 @@ error:
 		return 1;
 }
 
+int opt_reply(struct sip_msg* _msg, char* _foo, char* _bar) {
+	return ki_opt_reply(_msg);
+}
--- a/src/modules/siputils/options.h
+++ b/src/modules/siputils/options.h
@@ -63,6 +63,7 @@ extern str opt_accept_enc;
 extern str opt_accept_lang;
 extern str opt_supported;
 
+int ki_opt_reply(struct sip_msg* _msg);
 int opt_reply(struct sip_msg* _msg, char* _foo, char* _bar);
 
 #endif
--- a/src/modules/siputils/siputils.c
+++ b/src/modules/siputils/siputils.c
@@ -540,6 +540,11 @@ static sr_kemi_t sr_kemi_siputils_export
 		{ SR_KEMIP_STR, SR_KEMIP_STR, SR_KEMIP_NONE,
 			SR_KEMIP_NONE, SR_KEMIP_NONE, SR_KEMIP_NONE }
 	},
+	{ str_init("siputils"), str_init("options_reply"),
+		SR_KEMIP_INT, ki_opt_reply,
+		{ SR_KEMIP_NONE, SR_KEMIP_NONE, SR_KEMIP_NONE,
+			SR_KEMIP_NONE, SR_KEMIP_NONE, SR_KEMIP_NONE }
+	},
 
 	{ {0, 0}, {0, 0}, 0, NULL, { 0, 0, 0, 0, 0, 0 } }
 };
--- a/src/modules/tcpops/README
+++ b/src/modules/tcpops/README
@@ -340,7 +340,7 @@ event_route[tcp:closed] {
 
    Example 1.9. tcp_get_conid usage
 ...
-        if(tcp_conid_alive("127.0.0.1:5060", "$var(conid)")) {
+        if(tcp_get_conid("127.0.0.1:5060", "$var(conid)")) {
                 xlog("connection id is: $var(conid)\n");
         }
 ...
--- a/src/modules/tcpops/doc/functions.xml
+++ b/src/modules/tcpops/doc/functions.xml
@@ -287,7 +287,7 @@ event_route[tcp:closed] {
 			<title><function>tcp_get_conid</function> usage</title>
 			<programlisting><![CDATA[
 ...
-	if(tcp_conid_alive("127.0.0.1:5060", "$var(conid)")) {
+	if(tcp_get_conid("127.0.0.1:5060", "$var(conid)")) {
 		xlog("connection id is: $var(conid)\n");
 	}
 ...
--- a/src/modules/tls/tls_domain.c
+++ b/src/modules/tls/tls_domain.c
@@ -1563,7 +1563,7 @@ tls_domain_t* tls_lookup_cfg(tls_domains
 				if ((p->server_name_mode==KSR_TLS_SNM_INCDOM
 							|| p->server_name_mode==KSR_TLS_SNM_SUBDOM)
 						&& (p->server_name.len<sname->len)) {
-					dotpos = sname->len - p->server_name.len;
+					dotpos = sname->len - p->server_name.len - 1;
 					if(sname->s[dotpos] == '.'
 							&& strncasecmp(p->server_name.s,
 									sname->s + dotpos + 1,
--- a/src/modules/tm/README
+++ b/src/modules/tm/README
@@ -148,7 +148,8 @@ Daniel-Constantin Mierla
         6. Event Routes
 
               6.1. event_route[tm:branch-failure]
-              6.2. event_route[tm:local-response]
+              6.2. event_route[tm:local-request]
+              6.3. event_route[tm:local-response]
 
         7. TM Module API
 
@@ -265,7 +266,8 @@ Daniel-Constantin Mierla
    1.93. t_is_retr_async_reply usage
    1.94. t_uac_send usage
    1.95. event_route[tm:branch-failure] usage
-   1.96. event_route[tm:local-response] usage
+   1.96. event_route[tm:local-request] usage
+   1.97. event_route[tm:local-response] usage
 
 Chapter 1. Admin Guide
 
@@ -395,7 +397,8 @@ Chapter 1. Admin Guide
    6. Event Routes
 
         6.1. event_route[tm:branch-failure]
-        6.2. event_route[tm:local-response]
+        6.2. event_route[tm:local-request]
+        6.3. event_route[tm:local-response]
 
    7. TM Module API
 
@@ -2946,7 +2949,8 @@ t_uac_send("OPTIONS", "sip:alice@kamaili
 6. Event Routes
 
    6.1. event_route[tm:branch-failure]
-   6.2. event_route[tm:local-response]
+   6.2. event_route[tm:local-request]
+   6.3. event_route[tm:local-response]
 
 6.1.  event_route[tm:branch-failure]
 
@@ -2971,12 +2975,25 @@ event_route[tm:branch-failure:myroute] {
 }
 ...
 
-6.2.  event_route[tm:local-response]
+6.2.  event_route[tm:local-request]
+
+   Executed after the tm module has sent a local generated, transaction
+   stateful request.
+
+   Example 1.96. event_route[tm:local-request] usage
+...
+event_route [tm:local-request] {
+    xlog("L_INFO", "Routing locally generated $rm to $ru\n");
+    t_set_fr(10000, 10000);
+}
+...
+
+6.3.  event_route[tm:local-response]
 
    Executed after the tm module has sent a local generated, transaction
    stateful response.
 
-   Example 1.96. event_route[tm:local-response] usage
+   Example 1.97. event_route[tm:local-response] usage
 ...
 event_route[tm:local-response] {
     xlog("tm:local-response replied locally\n");
--- a/src/modules/tm/doc/event_routes.xml
+++ b/src/modules/tm/doc/event_routes.xml
@@ -39,6 +39,25 @@ event_route[tm:branch-failure:myroute] {
 	    </programlisting>
 	</example>
     </section>
+	<section id="tm.e.local-request">
+		<title>
+			<function moreinfo="none">event_route[tm:local-request]</function>
+		</title>
+		<para>
+			Executed after the tm module has sent a local generated, transaction stateful request.
+		</para>
+		<example>
+			<title><function>event_route[tm:local-request]</function> usage</title>
+			<programlisting  format="linespecific">
+...
+event_route [tm:local-request] {
+    xlog("L_INFO", "Routing locally generated $rm to $ru\n");
+    t_set_fr(10000, 10000);
+}
+...
+			</programlisting>
+		</example>
+	</section>
 	<section id="tm.e.local-response">
 		<title>
 			<function moreinfo="none">event_route[tm:local-response]</function>
--- a/src/modules/tm/t_fwd.c
+++ b/src/modules/tm/t_fwd.c
@@ -199,7 +199,7 @@ static int prepare_new_uac( struct cell
 		i_req->add_rm = dup_lump_list(i_req->add_rm);
 		if (unlikely(i_req->add_rm==0)){
 			ret=E_OUT_OF_MEM;
-			goto error04;
+			goto error05;
 		}
 	}
 	if (unlikely(i_req->body_lumps)){
@@ -593,12 +593,15 @@ error03:
 	/* Delete the duplicated lump lists, this will also delete
 	 * all lumps created here, such as lumps created in per-branch
 	 * routing sections, Via, and Content-Length headers created in
-	 * build_req_buf_from_sip_req
+	 * build_req_buf_from_sip_req().
 	 */
+	free_duped_lump_list(i_req->body_lumps);
+
 error04:
 	free_duped_lump_list(i_req->add_rm);
-	free_duped_lump_list(i_req->body_lumps);
-	/* Restore the lists from backups */
+
+error05:
+	/* Restore the lists from backups. */
 	i_req->add_rm = add_rm_backup;
 	i_req->body_lumps = body_lumps_backup;
 
--- a/src/modules/tm/uac.c
+++ b/src/modules/tm/uac.c
@@ -589,7 +589,8 @@ error2:
 	if (is_ack) {
 		free_cell(new_cell);
 	} else {
-		if(atomic_get_int(&new_cell->ref_count)==0) {
+		if((new_cell->next_c == 0 && new_cell->prev_c == 0)
+				|| (atomic_get_int(&new_cell->ref_count)==0)) {
 			free_cell(new_cell);
 		} else {
 			UNREF_FREE(new_cell, 0);
--- a/src/modules/tm/ut.h
+++ b/src/modules/tm/ut.h
@@ -296,6 +296,7 @@ inline static struct dest_info *uri2dst2
 												dst->proto, 0);
 			if (dst->send_sock){
 				dst->to=to;
+				dst->send_flags.f |= SND_F_FORCE_SOCKET;
 				return dst; /* found a good one */
 			}
 		}while(dns_srv_handle_next(dns_h, err));
@@ -317,6 +318,8 @@ inline static struct dest_info *uri2dst2
 			proto2a(dst->proto), su2a(&dst->to, sizeof(dst->to)));
 		/* ser_error = E_NO_SOCKET;*/
 		/* try to continue */
+	} else {
+		dst->send_flags.f |= SND_F_FORCE_SOCKET;
 	}
 	return dst;
 }
--- a/src/modules/topoh/topoh_mod.c
+++ b/src/modules/topoh/topoh_mod.c
@@ -411,6 +411,7 @@ int th_msg_sent(sr_event_param_t *evp)
 	int direction;
 	int dialog;
 	int local;
+	str nbuf = STR_NULL;
 
 	obuf = (str*)evp->data;
 
@@ -497,7 +498,15 @@ int th_msg_sent(sr_event_param_t *evp)
 	}
 
 ready:
-	obuf->s = th_msg_update(&msg, (unsigned int*)&obuf->len);
+	nbuf.s = th_msg_update(&msg, (unsigned int*)&nbuf.len);
+	if(nbuf.s!=NULL) {
+		LM_DBG("new outbound buffer generated\n");
+		pkg_free(obuf->s);
+		obuf->s = nbuf.s;
+		obuf->len = nbuf.len;
+	} else {
+		LM_ERR("failed to generate new outbound buffer\n");
+	}
 
 done:
 	free_sip_msg(&msg);
--- a/src/modules/topos/README
+++ b/src/modules/topos/README
@@ -197,7 +197,11 @@ modparam("topos", "branch_expire", 300)
 
 3.6. dialog_expire (int)
 
-   Interval in seconds after which the dialog records are deleted.
+   Interval in seconds after which the dialog records are deleted. Keep in
+   mind that the module does not update the dialog timestamp after the
+   initial call setup on re-INVITEs or other in-dialog messages. So set a
+   large enough value (according your longest call duration) to prevent
+   problems in re-writing messages.
 
    Default value is 10800 (3 hours).
 
--- a/src/modules/topos/doc/topos_admin.xml
+++ b/src/modules/topos/doc/topos_admin.xml
@@ -192,6 +192,10 @@ modparam("topos", "branch_expire", 300)
 		<title><varname>dialog_expire</varname> (int)</title>
 		<para>
 			Interval in seconds after which the dialog records are deleted.
+			Keep in mind that the module does not update the dialog timestamp
+			after the initial call setup on re-INVITEs or other in-dialog
+			messages. So set a large enough value (according your longest call
+			duration) to prevent problems in re-writing messages.
 		</para>
 		<para>
 		<emphasis>
--- a/src/modules/topos/topos_mod.c
+++ b/src/modules/topos/topos_mod.c
@@ -390,6 +390,7 @@ int tps_msg_sent(sr_event_param_t *evp)
 	str *obuf;
 	int dialog;
 	int local;
+	str nbuf = STR_NULL;
 
 	obuf = (str*)evp->data;
 
@@ -443,7 +444,15 @@ int tps_msg_sent(sr_event_param_t *evp)
 		tps_response_sent(&msg);
 	}
 
-	obuf->s = tps_msg_update(&msg, (unsigned int*)&obuf->len);
+	nbuf.s = tps_msg_update(&msg, (unsigned int*)&nbuf.len);
+	if(nbuf.s!=NULL) {
+		LM_DBG("new outbound buffer generated\n");
+		pkg_free(obuf->s);
+		obuf->s = nbuf.s;
+		obuf->len = nbuf.len;
+	} else {
+		LM_ERR("failed to generate new outbound buffer\n");
+	}
 
 done:
 	free_sip_msg(&msg);
--- a/src/modules/topos_redis/topos_redis_storage.c
+++ b/src/modules/topos_redis/topos_redis_storage.c
@@ -727,6 +727,7 @@ int tps_redis_load_branch(sip_msg_t *msg
 	memset(argv, 0, TPS_REDIS_NR_KEYS * sizeof(char*));
 	memset(argvlen, 0, TPS_REDIS_NR_KEYS * sizeof(size_t));
 	argc = 0;
+	memset(&id, 0, sizeof(tps_data_t));
 
 	if(mode==0) {
 		/* load same transaction using Via branch */
@@ -737,7 +738,6 @@ int tps_redis_load_branch(sip_msg_t *msg
 			LM_ERR("failed to load the INVITE branch value\n");
 			return -1;
 		}
-		memset(&id, 0, sizeof(tps_data_t));
 		xvbranch1 = &id.x_vbranch1;
 	}
 	if(xvbranch1->len<=0 || xvbranch1->s==NULL) {
--- a/src/modules/uac/README
+++ b/src/modules/uac/README
@@ -403,8 +403,9 @@ modparam("uac","credential","username:do
    This can be used if the realm upstream will be using is not known in
    advance.
 
-   If you define it, you also need to define “auth_username_avp” (???) and
-   “auth_username_avp” (???).
+   If you define it, you also need to define “auth_username_avp”
+   (Section 3.10, “auth_username_avp (string)”) and “auth_password_avp”
+   (Section 3.11, “auth_password_avp (string)”).
 
    Example 1.9. Set auth_realm_avp parameter
 ...
@@ -416,8 +417,9 @@ modparam("uac","auth_realm_avp","$avp(i:
    The definition of an AVP that might contain the username to be used to
    perform authentication.
 
-   If you define it, you also need to define “auth_realm_avp” (???) and
-   “auth_username_avp” (???).
+   If you define it, you also need to define “auth_realm_avp”
+   (Section 3.9, “auth_realm_avp (string)”) and “auth_password_avp”
+   (Section 3.11, “auth_password_avp (string)”).
 
    Example 1.10. Set auth_username_avp parameter
 ...
@@ -429,8 +431,9 @@ modparam("uac","auth_username_avp","$avp
    The definition of an AVP that might contain the password to be used to
    perform authentication.
 
-   If you define it, you also need to define “auth_password_avp” (???) and
-   “auth_username_avp” (???).
+   If you define it, you also need to define “auth_realm_avp”
+   (Section 3.9, “auth_realm_avp (string)”) and “auth_username_avp”
+   (Section 3.10, “auth_username_avp (string)”).
 
    Example 1.11. Set auth_password_avp parameter
 ...
@@ -810,7 +813,7 @@ if(uac_reg_request_to("$fU", 0))
 failure_route[REMOTE_AUTH] {
         if ($T_reply_code == 401 or $T_reply_code == 407) {
                 xlog("L_NOTICE", "Remote asked for authentication");
-                uac_auth()
+                uac_auth();
         }
 }
 ...
@@ -934,6 +937,7 @@ event_route[uac:reply] {
    Example 1.36. uac.reg_info usage
 ...
    kamcmd uac.reg_info l_uuid account123
+   kamcmd uac.reg_info l_uuid s:12345678
 ...
 
 8.3.  uac.reg_enable
@@ -947,6 +951,7 @@ event_route[uac:reply] {
    Example 1.37. uac.reg_enable usage
 ...
    kamcmd uac.reg_enable l_uuid account123
+   kamcmd uac.reg_enable l_uuid s:12345678
 ...
 
 8.4.  uac.reg_disable
@@ -960,6 +965,7 @@ event_route[uac:reply] {
    Example 1.38. uac.reg_disable usage
 ...
    kamcmd uac.reg_disable l_uuid account123
+   kamcmd uac.reg_disable l_uuid s:12345678
 ...
 
 8.5.  uac.reg_reload
@@ -980,6 +986,7 @@ event_route[uac:reply] {
    Example 1.40. uac.reg_refresh usage
 ...
    kamcmd uac.reg_refresh account123
+   kamcmd uac.reg_refresh s:12345678
 ...
 
 8.7.  uac.reg_active
--- a/src/modules/uac/doc/uac_admin.xml
+++ b/src/modules/uac/doc/uac_admin.xml
@@ -326,9 +326,9 @@ modparam("uac","credential","username:do
 			<para><emphasis>
 				If you define it, you also need to define
 				<quote>auth_username_avp</quote>
-				(<xref linkend="uac.p.auth-username-avp-id"/>) and
-				<quote>auth_username_avp</quote>
-				(<xref linkend="uac.p.auth-password-avp-id"/>).
+				(<xref linkend="uac.p.auth_username_avp"/>) and
+				<quote>auth_password_avp</quote>
+				(<xref linkend="uac.p.auth_password_avp"/>).
 			</emphasis></para>
 			<example>
 				<title>Set <varname>auth_realm_avp</varname> parameter</title>
@@ -348,9 +348,9 @@ modparam("uac","auth_realm_avp","$avp(i:
 			<para><emphasis>
 				If you define it, you also need to define
 				<quote>auth_realm_avp</quote>
-				(<xref linkend="uac.p.auth-realm-avp-id"/>) and
-				<quote>auth_username_avp</quote>
-				(<xref linkend="uac.p.auth-password-avp-id"/>).
+				(<xref linkend="uac.p.auth_realm_avp"/>) and
+				<quote>auth_password_avp</quote>
+				(<xref linkend="uac.p.auth_password_avp"/>).
 			</emphasis></para>
 			<example>
 				<title>Set <varname>auth_username_avp</varname> parameter</title>
@@ -369,10 +369,10 @@ modparam("uac","auth_username_avp","$avp
 			</para>
 			<para><emphasis>
 				If you define it, you also need to define
-				<quote>auth_password_avp</quote>
-				(<xref linkend="uac.p.auth-password-avp-id"/>) and
+				<quote>auth_realm_avp</quote>
+				(<xref linkend="uac.p.auth_realm_avp"/>) and
 				<quote>auth_username_avp</quote>
-				(<xref linkend="uac.p.auth-password-avp-id"/>).
+				(<xref linkend="uac.p.auth_username_avp"/>).
 			</emphasis></para>
 			<example>
 				<title>Set <varname>auth_password_avp</varname> parameter</title>
@@ -925,7 +925,7 @@ if(uac_reg_request_to("$fU", 0))
 failure_route[REMOTE_AUTH] {
 	if ($T_reply_code == 401 or $T_reply_code == 407) {
 		xlog("L_NOTICE", "Remote asked for authentication");
-		uac_auth()
+		uac_auth();
 	}
 }
 ...
@@ -1113,6 +1113,7 @@ event_route[uac:reply] {
 			<programlisting format="linespecific">
 ...
    kamcmd uac.reg_info l_uuid account123
+   kamcmd uac.reg_info l_uuid s:12345678
 ...
 			</programlisting>
 		</example>
@@ -1134,6 +1135,7 @@ event_route[uac:reply] {
 			<programlisting format="linespecific">
 ...
    kamcmd uac.reg_enable l_uuid account123
+   kamcmd uac.reg_enable l_uuid s:12345678
 ...
 			</programlisting>
 		</example>
@@ -1155,6 +1157,7 @@ event_route[uac:reply] {
 			<programlisting format="linespecific">
 ...
    kamcmd uac.reg_disable l_uuid account123
+   kamcmd uac.reg_disable l_uuid s:12345678
 ...
 			</programlisting>
 		</example>
@@ -1191,6 +1194,7 @@ event_route[uac:reply] {
 			<programlisting format="linespecific">
 ...
    kamcmd uac.reg_refresh account123
+   kamcmd uac.reg_refresh s:12345678
 ...
 			</programlisting>
 		</example>
--- a/src/modules/uac/replace.c
+++ b/src/modules/uac/replace.c
@@ -622,6 +622,7 @@ int restore_uri( struct sip_msg *msg, st
 		}
 		old_body = (struct to_body*) msg->to->parsed;
 		flag = FL_USE_UAC_TO;
+		LM_DBG("replacing in To header\n");
 	} else {
 		/* replace the FROM URI */
 		if ( parse_from_header(msg)<0 ) {
@@ -630,6 +631,7 @@ int restore_uri( struct sip_msg *msg, st
 		}
 		old_body = (struct to_body*) msg->from->parsed;
 		flag = FL_USE_UAC_FROM;
+		LM_DBG("replacing in From header\n");
 	}
 
 	if(restore_avp->s) {
--- a/src/modules/uac/uac.c
+++ b/src/modules/uac/uac.c
@@ -382,6 +382,7 @@ static int child_init(int rank)
 
 		kam_srand(getpid() * 17 +  time(0));
 		uac_reg_load_db();
+		LM_DBG("run initial uac registration routine\n");
 		uac_reg_timer(0);
 		for(;;){
 			/* update the local config framework structures */
--- a/src/modules/uac/uac_reg.c
+++ b/src/modules/uac/uac_reg.c
@@ -579,6 +579,8 @@ int reg_ht_add(reg_uac_t *reg)
 	reg_ht_add_byuuid(nr);
 	counter_inc(regtotal);
 
+	LM_DBG("added uuid: %.*s - l_user: %.*s\n", nr->l_uuid.len, nr->l_uuid.s,
+			nr->l_username.len, nr->l_username.s);
 	return 0;
 }
 
--- a/src/modules/userblacklist/README
+++ b/src/modules/userblacklist/README
@@ -7,8 +7,6 @@ Henning Westerholt
    1&1 Internet AG
    <henning.westerholt@1und1.de>
 
-Edited by
-
 Pawel Kuzak
 
    1&1 Internet AG
@@ -89,7 +87,7 @@ Pawel Kuzak
    1.13. Set globalblacklist_whitelist_col parameter
    1.14. Set globalblacklist_description_col parameter
    1.15. check_user_blacklist usage
-   1.16. check_user_blacklist usage
+   1.16. check_user_whitelist usage
    1.17. check_blacklist usage
    1.18. check_whitelist usage
    1.19. userblacklist.reload_blacklist usage
@@ -407,7 +405,7 @@ table)
    are optional, the defaults are used if they are omitted. The number
    parameter can be used to check for example against the from URI user.
 
-   Example 1.16. check_user_blacklist usage
+   Example 1.16. check_user_whitelist usage
 ...
 $avp(i:80) = $rU;
 # rewrite the R-URI
--- a/src/modules/userblacklist/doc/userblacklist_admin.xml
+++ b/src/modules/userblacklist/doc/userblacklist_admin.xml
@@ -324,7 +324,7 @@ if (!check_user_blacklist("$avp(i:80)",
 		parameter can be used to check for example against the from URI user.
 	    </para>
 	<example>
-		<title><function>check_user_blacklist</function> usage</title>
+		<title><function>check_user_whitelist</function> usage</title>
 		<programlisting format="linespecific">
 ...
 $avp(i:80) = $rU;
--- a/src/modules/usrloc/README
+++ b/src/modules/usrloc/README
@@ -12,12 +12,8 @@ Edited by
 
 Jan Janak
 
-Edited by
-
 Bogdan-Andrei Iancu
 
-Edited by
-
 Carsten Bock
 
    ng-voice GmbH
@@ -44,7 +40,7 @@ Carsten Bock
 
         3. Parameters
 
-              3.1. nat_bflag (integer)
+              3.1. nat_bflag (int)
               3.2. user_column (string)
               3.3. domain_column (string)
               3.4. contact_column (string)
@@ -65,17 +61,17 @@ Carsten Bock
               3.19. connection_id_column (string)
               3.20. keepalive_column (string)
               3.21. partition_column (string)
-              3.22. use_domain (integer)
-              3.23. desc_time_order (integer)
-              3.24. timer_interval (integer)
+              3.22. use_domain (int)
+              3.23. desc_time_order (int)
+              3.24. timer_interval (int)
               3.25. db_url (string)
-              3.26. db_mode (integer)
-              3.27. db_load (integer)
-              3.28. db_insert_update (integer)
-              3.29. matching_mode (integer)
-              3.30. cseq_delay (integer)
-              3.31. fetch_rows (integer)
-              3.32. hash_size (integer)
+              3.26. db_mode (int)
+              3.27. db_load (int)
+              3.28. db_insert_update (int)
+              3.29. matching_mode (int)
+              3.30. cseq_delay (int)
+              3.31. fetch_rows (int)
+              3.32. hash_size (int)
               3.33. preload (string)
               3.34. db_update_as_insert (int)
               3.35. db_check_update (int)
@@ -91,7 +87,7 @@ Carsten Bock
               3.45. db_timer_clean (int)
               3.46. rm_expired_delay (int)
               3.47. server_id_filter (int)
-              3.48. version_table (integer)
+              3.48. version_table (int)
 
         4. RPC Commands
 
@@ -203,7 +199,7 @@ Chapter 1. Admin Guide
 
    3. Parameters
 
-        3.1. nat_bflag (integer)
+        3.1. nat_bflag (int)
         3.2. user_column (string)
         3.3. domain_column (string)
         3.4. contact_column (string)
@@ -224,17 +220,17 @@ Chapter 1. Admin Guide
         3.19. connection_id_column (string)
         3.20. keepalive_column (string)
         3.21. partition_column (string)
-        3.22. use_domain (integer)
-        3.23. desc_time_order (integer)
-        3.24. timer_interval (integer)
+        3.22. use_domain (int)
+        3.23. desc_time_order (int)
+        3.24. timer_interval (int)
         3.25. db_url (string)
-        3.26. db_mode (integer)
-        3.27. db_load (integer)
-        3.28. db_insert_update (integer)
-        3.29. matching_mode (integer)
-        3.30. cseq_delay (integer)
-        3.31. fetch_rows (integer)
-        3.32. hash_size (integer)
+        3.26. db_mode (int)
+        3.27. db_load (int)
+        3.28. db_insert_update (int)
+        3.29. matching_mode (int)
+        3.30. cseq_delay (int)
+        3.31. fetch_rows (int)
+        3.32. hash_size (int)
         3.33. preload (string)
         3.34. db_update_as_insert (int)
         3.35. db_check_update (int)
@@ -250,7 +246,7 @@ Chapter 1. Admin Guide
         3.45. db_timer_clean (int)
         3.46. rm_expired_delay (int)
         3.47. server_id_filter (int)
-        3.48. version_table (integer)
+        3.48. version_table (int)
 
    4. RPC Commands
 
@@ -310,7 +306,7 @@ Chapter 1. Admin Guide
 
    To find out how to control/select the contact matching algorithm,
    please see the module parameter matching_mode - Section 3.29,
-   “matching_mode (integer)”.
+   “matching_mode (int)”.
 
 2. Dependencies
 
@@ -330,7 +326,7 @@ Chapter 1. Admin Guide
 
 3. Parameters
 
-   3.1. nat_bflag (integer)
+   3.1. nat_bflag (int)
    3.2. user_column (string)
    3.3. domain_column (string)
    3.4. contact_column (string)
@@ -351,17 +347,17 @@ Chapter 1. Admin Guide
    3.19. connection_id_column (string)
    3.20. keepalive_column (string)
    3.21. partition_column (string)
-   3.22. use_domain (integer)
-   3.23. desc_time_order (integer)
-   3.24. timer_interval (integer)
+   3.22. use_domain (int)
+   3.23. desc_time_order (int)
+   3.24. timer_interval (int)
    3.25. db_url (string)
-   3.26. db_mode (integer)
-   3.27. db_load (integer)
-   3.28. db_insert_update (integer)
-   3.29. matching_mode (integer)
-   3.30. cseq_delay (integer)
-   3.31. fetch_rows (integer)
-   3.32. hash_size (integer)
+   3.26. db_mode (int)
+   3.27. db_load (int)
+   3.28. db_insert_update (int)
+   3.29. matching_mode (int)
+   3.30. cseq_delay (int)
+   3.31. fetch_rows (int)
+   3.32. hash_size (int)
    3.33. preload (string)
    3.34. db_update_as_insert (int)
    3.35. db_check_update (int)
@@ -377,9 +373,9 @@ Chapter 1. Admin Guide
    3.45. db_timer_clean (int)
    3.46. rm_expired_delay (int)
    3.47. server_id_filter (int)
-   3.48. version_table (integer)
+   3.48. version_table (int)
 
-3.1. nat_bflag (integer)
+3.1. nat_bflag (int)
 
    The index of the branch flag to be used as NAT marker (if the contact
    is or not natted). This is a branch flag and it will be imported and
@@ -616,7 +612,7 @@ modparam("usrloc", "keepalive_column", "
 modparam("usrloc", "partition_column", "part")
 ...
 
-3.22. use_domain (integer)
+3.22. use_domain (int)
 
    If the domain part of the user should be also saved and used for
    identifying the user (along with the username part). Useful in multi
@@ -629,7 +625,7 @@ modparam("usrloc", "partition_column", "
 modparam("usrloc", "use_domain", 1)
 ...
 
-3.23. desc_time_order (integer)
+3.23. desc_time_order (int)
 
    If the user's contacts should be kept timestamp ordered; otherwise the
    contact will be ordered based on q value. Non 0 value means true.
@@ -641,7 +637,7 @@ modparam("usrloc", "use_domain", 1)
 modparam("usrloc", "desc_time_order", 1)
 ...
 
-3.24. timer_interval (integer)
+3.24. timer_interval (int)
 
    Number of seconds between two timer runs. The module uses a timer to
    delete expired contacts, synchronize with database and other tasks,
@@ -665,7 +661,7 @@ modparam("usrloc", "timer_interval", 120
 modparam("usrloc", "db_url", "dbdriver://username:password@dbhost/dbname")
 ...
 
-3.26. db_mode (integer)
+3.26. db_mode (int)
 
    The usrloc module can utilize a database for persistent contact
    storage. If a database is used, the location database (contacts) will
@@ -716,7 +712,7 @@ Warning
 modparam("usrloc", "db_mode", 2)
 ...
 
-3.27. db_load (integer)
+3.27. db_load (int)
 
    Determine if the usrloc module should load contacts from the database
    storage during module initialization A value of 0 disable the loading
@@ -726,10 +722,10 @@ modparam("usrloc", "db_mode", 2)
 
    Example 1.27. Set db_load parameter
 ...
-modparam("usrloc", "db_load", "0")
+modparam("usrloc", "db_load", 0)
 ...
 
-3.28. db_insert_update (integer)
+3.28. db_insert_update (int)
 
    Determine if the usrloc module should do an update when a duplicate key
    is found while inserting A value of 1 will activate update on duplicate
@@ -739,13 +735,13 @@ modparam("usrloc", "db_load", "0")
 
    Example 1.28. Set db_insert_update parameter
 ...
-modparam("usrloc", "db_insert_update", "1")
+modparam("usrloc", "db_insert_update", 1)
 ...
 
-3.29. matching_mode (integer)
+3.29. matching_mode (int)
 
-   What contact matching algorithm to be used. Refer to section
-   Section 1.1, “Contact matching” for the description of the algorithms.
+   What contact matching algorithm to be used. Refer to section ??? for
+   the description of the algorithms.
 
    The parameter may take the following values:
      * 0 - CONTACT ONLY based matching algorithm.
@@ -763,7 +759,7 @@ modparam("usrloc", "db_insert_update", "
 modparam("usrloc", "matching_mode", 1)
 ...
 
-3.30. cseq_delay (integer)
+3.30. cseq_delay (int)
 
    Delay (in seconds) for accepting as retransmissions register requests
    with same Call-ID and Cseq. The delay is calculated starting from the
@@ -782,7 +778,7 @@ modparam("usrloc", "matching_mode", 1)
 modparam("usrloc", "cseq_delay", 5)
 ...
 
-3.31. fetch_rows (integer)
+3.31. fetch_rows (int)
 
    The number of the rows to be fetched at once from database when loading
    the location records. This value can be used to tune the load time at
@@ -796,7 +792,7 @@ modparam("usrloc", "cseq_delay", 5)
 modparam("usrloc", "fetch_rows", 3000)
 ...
 
-3.32. hash_size (integer)
+3.32. hash_size (int)
 
    The number of entries of the hash table used by usrloc to store the
    location records is 2^hash_size. For hash_size=4, the number of slots
@@ -1019,7 +1015,7 @@ modparam("usrloc", "rm_expired_delay", 3
 modparam("usrloc", "server_id_filter", 1)
 ...
 
-3.48. version_table (integer)
+3.48. version_table (int)
 
    If set to 0, the module will skip checking the version for location
    table.
--- a/src/modules/usrloc/doc/usrloc_admin.xml
+++ b/src/modules/usrloc/doc/usrloc_admin.xml
@@ -20,7 +20,7 @@
 		provides access to the table for  other modules. The module exports no
 		functions that can  be used directly from routing scripts.
 	</para>
-		<section id="contact-matching-algs">
+		<section id="usrloc.o.contact-matching-algs">
 		<title>Contact matching</title>
 		<para>
 		How the contacts are matched (for the same AOR - Address of Record) is an
@@ -112,7 +112,7 @@
 	<section>
 	<title>Parameters</title>
 	<section id="usrloc.p.nat_bflag">
-		<title><varname>nat_bflag</varname> (integer)</title>
+		<title><varname>nat_bflag</varname> (int)</title>
 		<para>
 		The index of the branch flag to be used as NAT marker (if the contact
 		is or not natted). This is a branch flag and it will be imported and
@@ -537,7 +537,7 @@ modparam("usrloc", "partition_column", "
 	</section>
 
 	<section id="usrloc.p.use_domain">
-		<title><varname>use_domain</varname> (integer)</title>
+		<title><varname>use_domain</varname> (int)</title>
 		<para>
 		If the domain part of the user should be also saved and used for
 		identifying the user (along with the username part). Useful in
@@ -559,7 +559,7 @@ modparam("usrloc", "use_domain", 1)
 	</section>
 
 	<section id="usrloc.p.desc_time_order">
-		<title><varname>desc_time_order</varname> (integer)</title>
+		<title><varname>desc_time_order</varname> (int)</title>
 		<para>
 		If the user's contacts should be kept timestamp ordered; otherwise the
 		contact will be ordered based on q value.
@@ -581,7 +581,7 @@ modparam("usrloc", "desc_time_order", 1)
 	</section>
 
 	<section id="usrloc.p.timer_interval">
-		<title><varname>timer_interval</varname> (integer)</title>
+		<title><varname>timer_interval</varname> (int)</title>
 		<para>
 		Number of seconds between two timer runs. The module uses a timer to
 		delete expired contacts, synchronize with database and other tasks,
@@ -623,7 +623,7 @@ modparam("usrloc", "db_url", "&exampledb
 	</section>
 
 	<section id="usrloc.p.db_mode">
-		<title><varname>db_mode</varname> (integer)</title>
+		<title><varname>db_mode</varname> (int)</title>
 		<para>
 		The usrloc module can utilize a database for persistent contact storage.
 		If a database is used, the location database (contacts)  will survive
@@ -708,7 +708,7 @@ modparam("usrloc", "db_mode", 2)
 	</section>
 
 	<section id="usrloc.p.db_load">
-		<title><varname>db_load</varname> (integer)</title>
+		<title><varname>db_load</varname> (int)</title>
 		<para>
 		Determine if the usrloc module should load contacts from the database storage during module initialization
 		A value of 0 disable the loading from the database, this parameter is ignored if db_mode 4 is set
@@ -722,14 +722,14 @@ modparam("usrloc", "db_mode", 2)
 		<title>Set <varname>db_load</varname> parameter</title>
 		<programlisting format="linespecific">
 ...
-modparam("usrloc", "db_load", "0")
+modparam("usrloc", "db_load", 0)
 ...
 		</programlisting>
 		</example>
 	</section>
 
 	<section id="usrloc.p.db_insert_update">
-		<title><varname>db_insert_update</varname> (integer)</title>
+		<title><varname>db_insert_update</varname> (int)</title>
 		<para>
 		Determine if the usrloc module should do an update when a duplicate key is found while inserting
 		A value of 1 will activate update on duplicate key
@@ -743,14 +743,14 @@ modparam("usrloc", "db_load", "0")
 		<title>Set <varname>db_insert_update</varname> parameter</title>
 		<programlisting format="linespecific">
 ...
-modparam("usrloc", "db_insert_update", "1")
+modparam("usrloc", "db_insert_update", 1)
 ...
 		</programlisting>
 		</example>
 	</section>
 
 	<section id="usrloc.p.matching_mode">
-		<title><varname>matching_mode</varname> (integer)</title>
+		<title><varname>matching_mode</varname> (int)</title>
 		<para>
 		What contact matching algorithm to be used. Refer to section
 		<xref linkend="contact-matching-algs"/> for the description of the
@@ -800,7 +800,7 @@ modparam("usrloc", "matching_mode", 1)
 	</section>
 
 	<section id="usrloc.p.cseq_delay">
-		<title><varname>cseq_delay</varname> (integer)</title>
+		<title><varname>cseq_delay</varname> (int)</title>
 		<para>
 		Delay (in seconds) for accepting as retransmissions register requests
 		with same Call-ID and Cseq. The delay is calculated starting from the
@@ -830,7 +830,7 @@ modparam("usrloc", "cseq_delay", 5)
 	</section>
 
 	<section id="usrloc.p.fetch_rows">
-		<title><varname>fetch_rows</varname> (integer)</title>
+		<title><varname>fetch_rows</varname> (int)</title>
 		<para>
 		The number of the rows to be fetched at once from database
 		when loading the location records. This value can be used
@@ -854,7 +854,7 @@ modparam("usrloc", "fetch_rows", 3000)
 	</section>
 
 	<section id="usrloc.p.hash_size">
-		<title><varname>hash_size</varname> (integer)</title>
+		<title><varname>hash_size</varname> (int)</title>
 		<para>
 		The number of entries of the hash table used by usrloc to store the
 		location records is 2^hash_size. For hash_size=4, the number of slots
@@ -1221,7 +1221,7 @@ modparam("usrloc", "server_id_filter", 1
 	</section>
 
 	<section id="usrloc.p.version_table">
-		<title><varname>version_table</varname> (integer)</title>
+		<title><varname>version_table</varname> (int)</title>
 		<para>
 		If set to 0, the module will skip checking the version
 		for location table.
--- a/src/modules/usrloc/ucontact.h
+++ b/src/modules/usrloc/ucontact.h
@@ -169,4 +169,13 @@ int uldb_delete_attrs(str* _dname, str *
  */
 int uldb_insert_attrs(str *_dname, str *_user, str *_domain,
         str *_ruid, sr_xavp_t *_xhead);
+
+/*!
+ * \brief Set the value for cloning the xavp list to contact structure
+ * \param v - the value to be set
+ */
+void ul_set_xavp_contact_clone(int v);
+
+int uldb_delete_attrs_ruid(str* _dname, str *_ruid);
+
 #endif
--- a/src/modules/usrloc/udomain.c
+++ b/src/modules/usrloc/udomain.c
@@ -83,7 +83,7 @@ int new_udomain(str* _n, int _s, udomain
 #ifdef STATISTICS
 	char *name;
 #endif
-	
+
 	/* Must be always in shared memory, since
 	 * the cache is accessed from timer which
 	 * lives in a separate process
@@ -150,7 +150,7 @@ error0:
 void free_udomain(udomain_t* _d)
 {
 	int i;
-	
+
 	if (_d->table) {
 		for(i = 0; i < _d->size; i++) {
 			deinit_slot(_d->table + i);
@@ -215,7 +215,7 @@ void print_udomain(FILE* _f, udomain_t*
 /*!
  * \brief Convert database values into ucontact_info
  *
- * Convert database values into ucontact_info, 
+ * Convert database values into ucontact_info,
  * expects 12 rows (contact, expirs, q, callid, cseq, flags,
  * ua, received, path, socket, methods, last_modified)
  * \param vals database values
@@ -294,7 +294,7 @@ static inline ucontact_info_t* dbrow2inf
 		received.len = strlen(received.s);
 	}
 	ci.received = received;
-	
+
 	path.s  = (char*)VAL_STRING(vals+9);
 		if (VAL_NULL(vals+9) || !path.s || !path.s[0]) {
 			path.len = 0;
@@ -309,7 +309,7 @@ static inline ucontact_info_t* dbrow2inf
 	if (VAL_NULL(vals+10) || p==0 || p[0]==0){
 		ci.sock = 0;
 	} else {
-		if (parse_phostport( p, &host.s, &host.len, 
+		if (parse_phostport( p, &host.s, &host.len,
 		&port, &proto)!=0) {
 			LM_ERR("bad socket <%s>\n", p);
 			return 0;
@@ -509,7 +509,6 @@ int preload_udomain(db1_con_t* _c, udoma
 				}
 			}
 
-		
 			lock_udomain(_d, &user);
 			if (get_urecord(_d, &user, &r) > 0) {
 				if (mem_insert_urecord(_d, &user, &r) < 0) {
@@ -657,7 +656,7 @@ urecord_t* db_load_urecord(db1_con_t* _c
 					_aor->len, _aor->s, _d->name->s);
 			continue;
 		}
-		
+
 		if ( r==0 )
 			get_static_urecord( _d, _aor, &r);
 
@@ -910,6 +909,9 @@ int udomain_contact_expired_cb(db1_con_t
 	int n;
 	urecord_t* r;
 	ucontact_t* c;
+#define RUIDBUF_SIZE 128
+	char ruidbuf[RUIDBUF_SIZE];
+	str ruid;
 
 	if (db_mode!=DB_ONLY) {
 		return 0;
@@ -948,13 +950,13 @@ int udomain_contact_expired_cb(db1_con_t
 	UL_DB_EXPIRES_SET(&query_vals[1], 0);
 
 	if (ul_db_srvid != 0) {
-                query_cols[2] = &srv_id_col;
-                query_ops[2] = OP_EQ;
-                query_vals[2].type = DB1_INT;
-                query_vals[2].nul = 0;
-                query_vals[2].val.int_val = server_id;
-                key_num = 3;
-        }
+		query_cols[2] = &srv_id_col;
+		query_ops[2] = OP_EQ;
+		query_vals[2].type = DB1_INT;
+		query_vals[2].nul = 0;
+		query_vals[2].val.int_val = server_id;
+		key_num = 3;
+	}
 
 	if (ul_dbf.use_table(_c, _d->name) < 0) {
 		LM_ERR("sql use_table failed\n");
@@ -985,8 +987,8 @@ int udomain_contact_expired_cb(db1_con_t
 
 	if (RES_ROW_N(res) == 0) {
 		LM_DBG("no rows to be contact expired\n");
-                ul_dbf.free_result(_c, res);
-                return 0;
+		ul_dbf.free_result(_c, res);
+		return 0;
 	}
 
 	n = 0;
@@ -1011,14 +1013,11 @@ int udomain_contact_expired_cb(db1_con_t
 			}
 
 			lock_udomain(_d, &user);
-			if (get_urecord(_d, &user, &r) > 0) {
-				LM_ERR("failed to get a record\n");
-				unlock_udomain(_d, &user);
-				goto error;
-			}
+			get_static_urecord(_d, &user, &r);
 
 			if ( (c=mem_insert_ucontact(r, &contact, ci)) == 0) {
-				LM_ERR("inserting contact failed\n");
+				LM_ERR("inserting temporary contact failed for %.*s\n",
+						user.len, user.s);
 				release_urecord(r);
 				unlock_udomain(_d, &user);
 				goto error;
@@ -1029,8 +1028,25 @@ int udomain_contact_expired_cb(db1_con_t
 				run_ul_callbacks( UL_CONTACT_EXPIRE, c);
 			}
 			c->state = CS_SYNC;
+			ruid.len = 0;
+			if(c->ruid.len > 0 && ul_xavp_contact_name.s != NULL) {
+				/* clone ruid to delete attributes out of lock */
+				if(c->ruid.len < RUIDBUF_SIZE - 2) {
+					memcpy(ruidbuf, c->ruid.s, c->ruid.len);
+					ruidbuf[c->ruid.len] = '\0';
+					ruid.s = ruidbuf;
+					ruid.len = c->ruid.len;
+				} else {
+					LM_ERR("ruid is too long %d for %.*s\n", c->ruid.len,
+							user.len, user.s);
+				}
+			}
 			release_urecord(r);
 			unlock_udomain(_d, &user);
+			if(ruid.len > 0 && ul_xavp_contact_name.s != NULL) {
+				/* delete attributes by ruid */
+				uldb_delete_attrs_ruid(_d->name, &ruid);
+			}
 		}
 
 		if (DB_CAPABILITY(ul_dbf, DB_CAP_FETCH)) {
@@ -1059,7 +1075,7 @@ error:
 
 
 /*!
- * \brief Timer function to cleanup expired contacts, db_mode: DB_ONLY 
+ * \brief Timer function to cleanup expired contacts, db_mode: DB_ONLY
  *   and for WRITE_BACK, WRITE_THROUGH on config param
  * \param _d cleaned domain
  * \return 0 on success, -1 on failure
@@ -1097,7 +1113,7 @@ int db_timer_udomain(udomain_t* _d)
 		LM_ERR("use_table failed\n");
 		return -1;
 	}
-	
+
 	if (ul_dbf.delete(ul_dbh, keys, ops, vals, key_num) < 0) {
 		LM_ERR("failed to delete from table %s\n",_d->name->s);
 		return -1;
@@ -1131,7 +1147,7 @@ int testdb_udomain(db1_con_t* con, udoma
 	VAL_TYPE(val) = DB1_STRING;
 	VAL_NULL(val) = 0;
 	VAL_STRING(val) = "dummy_user";
-	
+
 	VAL_TYPE(val+1) = DB1_STRING;
 	VAL_NULL(val+1) = 0;
 	VAL_STRING(val+1) = "dummy_domain";
@@ -1157,7 +1173,7 @@ int testdb_udomain(db1_con_t* con, udoma
 int mem_insert_urecord(udomain_t* _d, str* _aor, struct urecord** _r)
 {
 	int sl;
-	
+
 	if (new_urecord(_d->name, _aor, _r) < 0) {
 		LM_ERR("creating urecord failed\n");
 		return -1;
--- a/src/modules/usrloc/ul_rpc.c
+++ b/src/modules/usrloc/ul_rpc.c
@@ -421,6 +421,7 @@ static void ul_rpc_lookup(rpc_t* rpc, vo
 
 	if (rpc->add(ctx, "{", &th) < 0)
 	{
+		release_urecord(rec);
 		unlock_udomain(dom, &aor);
 		rpc->fault(ctx, 500, "Internal error creating outer rpc");
 		return;
@@ -429,6 +430,7 @@ static void ul_rpc_lookup(rpc_t* rpc, vo
 				"AoR", &aor,
 				"Contacts", &ih)<0)
 	{
+		release_urecord(rec);
 		unlock_udomain(dom, &aor);
 		rpc->fault(ctx, 500, "Internal error creating aor struct");
 		return;
@@ -439,12 +441,13 @@ static void ul_rpc_lookup(rpc_t* rpc, vo
 		if (VALID_CONTACT( con, act_time)) {
 			rpl_tree++;
 			if (rpc_dump_contact(rpc, ctx, ih, con) == -1) {
+				release_urecord(rec);
 				unlock_udomain(dom, &aor);
 				return;
 			}
 		}
 	}
-
+	release_urecord(rec);
 	unlock_udomain( dom, &aor);
 
 	if (rpl_tree==0) {
@@ -533,17 +536,20 @@ static void ul_rpc_rm_contact(rpc_t* rpc
 
 	ret = get_ucontact( rec, &contact, &rpc_ul_cid, &rpc_ul_path, RPC_UL_CSEQ+1, &con);
 	if (ret < 0) {
+		release_urecord(rec);
 		unlock_udomain( dom, &aor);
 		rpc->fault(ctx, 500, "Internal error (can't get contact)");
 		return;
 	}
 	if (ret > 0) {
+		release_urecord(rec);
 		unlock_udomain( dom, &aor);
 		rpc->fault(ctx, 404, "Contact not found");
 		return;
 	}
 
 	if (delete_ucontact(rec, con) < 0) {
+		release_urecord(rec);
 		unlock_udomain( dom, &aor);
 		rpc->fault(ctx, 500, "Internal error (can't delete contact)");
 		return;
--- a/src/modules/usrloc/urecord.c
+++ b/src/modules/usrloc/urecord.c
@@ -94,7 +94,7 @@ void free_urecord(urecord_t* _r)
 		_r->contacts = _r->contacts->next;
 		free_ucontact(ptr);
 	}
-	
+
 	/* if mem cache is not used, the urecord struct is static*/
 	if (db_mode!=DB_ONLY) {
 		if (_r->aor.s) shm_free(_r->aor.s);
@@ -117,7 +117,7 @@ void print_urecord(FILE* _f, urecord_t*
 	fprintf(_f, "aor    : '%.*s'\n", _r->aor.len, ZSW(_r->aor.s));
 	fprintf(_f, "aorhash: '%u'\n", (unsigned)_r->aorhash);
 	fprintf(_f, "slot:    '%d'\n", _r->aorhash&(_r->slot->d->size-1));
-	
+
 	if (_r->contacts) {
 		ptr = _r->contacts;
 		while(ptr) {
@@ -201,7 +201,7 @@ void mem_remove_ucontact(urecord_t* _r,
 			_c->next->prev = 0;
 		}
 	}
-}	
+}
 
 
 /*!
@@ -534,7 +534,7 @@ int db_delete_urecord_by_ruid(str *_tabl
 	}
 
 	if (ul_dbf.affected_rows(ul_dbh) == 0) {
-	        return -2;
+		return -2;
 	}
 
 	return 0;
@@ -653,12 +653,12 @@ int delete_ucontact(urecord_t* _r, struc
 
 int delete_urecord_by_ruid(udomain_t* _d, str *_ruid)
 {
-    if (db_mode != DB_ONLY) {
-	LM_ERR("delete_urecord_by_ruid currently available only in db_mode=3\n");
-	return -1;
-    }
+	if (db_mode != DB_ONLY) {
+		LM_ERR("delete_urecord_by_ruid currently available only in db_mode=3\n");
+		return -1;
+	}
 
-    return db_delete_urecord_by_ruid(_d->name, _ruid);
+	return db_delete_urecord_by_ruid(_d->name, _ruid);
 }
 
 
@@ -674,7 +674,7 @@ static inline struct ucontact* contact_m
 		if ((_c->len == ptr->c.len) && !memcmp(_c->s, ptr->c.s, _c->len)) {
 			return ptr;
 		}
-		
+
 		ptr = ptr->next;
 	}
 	return 0;
@@ -698,30 +698,29 @@ static inline struct ucontact* contact_c
 		) {
 			return ptr;
 		}
-		
+
 		ptr = ptr->next;
 	}
 	return 0;
 }
 
- /*!
-+ * \brief Match a contact record to a contact string and path
-+ * \param ptr contact record
-+ * \param _c contact string
-+ * \param _path path
-+ * \return ptr on successfull match, 0 when they not match
-+ */
+/*!
+ * \brief Match a contact record to a contact string and path
+ * \param ptr contact record
+ * \param _c contact string
+ * \param _path path
+ * \return ptr on successfull match, 0 when they not match
+ */
 static inline struct ucontact* contact_path_match( ucontact_t* ptr, str* _c, str *_path)
 {
 	/* if no path is preset (in REGISTER request) or use_path is not configured
-	   in registrar module, default to contact_match() */
+	 * in registrar module, default to contact_match() */
 	if( _path == NULL) return contact_match(ptr, _c);
 
 	while(ptr) {
 		if ( (_c->len==ptr->c.len) && (_path->len==ptr->path.len)
-		&& !memcmp(_c->s, ptr->c.s, _c->len)
-		&& !memcmp(_path->s, ptr->path.s, _path->len)
-		) {
+			&& !memcmp(_c->s, ptr->c.s, _c->len)
+			&& !memcmp(_path->s, ptr->path.s, _path->len) ) {
 			return ptr;
 		}
 
@@ -744,7 +743,7 @@ static inline struct ucontact* contact_m
 		if ((_callid->len == ptr->callid.len) && !memcmp(_callid->s, ptr->callid.s, _callid->len)) {
 			return ptr;
 		}
-		
+
 		ptr = ptr->next;
 	}
 	return 0;
@@ -759,7 +758,7 @@ static inline struct ucontact* contact_m
  * \param _path path
  * \param _cseq CSEQ number
  * \param _co found contact
- * \return 0 - found, 1 - not found, -1 - invalid found, 
+ * \return 0 - found, 1 - not found, -1 - invalid found,
  * -2 - found, but to be skipped (same cseq)
  */
 int get_ucontact(urecord_t* _r, str* _c, str* _callid, str* _path, int _cseq,
@@ -818,7 +817,7 @@ int get_ucontact_by_instance(urecord_t*
 	ucontact_t* ptr;
 	str i1;
 	str i2;
-	
+
 	if (_ci->instance.s == NULL || _ci->instance.len <= 0) {
 		return get_ucontact(_r, _c, _ci->callid, _ci->path, _ci->cseq, _co);
 	}
@@ -843,7 +842,7 @@ int get_ucontact_by_instance(urecord_t*
 				return 0;
 			}
 		}
-		
+
 		ptr = ptr->next;
 	}
 	return 1;
--- a/src/modules/usrloc/usrloc_mod.c
+++ b/src/modules/usrloc/usrloc_mod.c
@@ -377,8 +377,11 @@ static int mod_init(void)
 	if (handle_lost_tcp && db_mode == DB_ONLY)
 		LM_WARN("handle_lost_tcp option makes nothing in DB_ONLY mode\n");
 
-	init_flag = 1;
+	if(db_mode != DB_ONLY) {
+		ul_set_xavp_contact_clone(1);
+	}
 
+	init_flag = 1;
 	return 0;
 }
 
--- a/src/modules/xcap_server/xcap_misc.c
+++ b/src/modules/xcap_server/xcap_misc.c
@@ -436,8 +436,8 @@ int xcaps_xpath_set(str *inbuf, str *xpa
 {
 	xmlDocPtr doc = NULL;
 	xmlDocPtr newnode = NULL;
-	xmlXPathContextPtr xpathCtx = NULL; 
-	xmlXPathObjectPtr xpathObj = NULL; 
+	xmlXPathContextPtr xpathCtx = NULL;
+	xmlXPathObjectPtr xpathObj = NULL;
 	xmlNodeSetPtr nodes;
 	const xmlChar* value = NULL;
 	xmlChar *xmem = NULL;
@@ -466,7 +466,7 @@ int xcaps_xpath_set(str *inbuf, str *xpa
 		LM_ERR("unable to create new XPath context\n");
 		goto error;
 	}
-	
+
 	/* Evaluate xpath expression */
 	xpathObj = xmlXPathEvalExpression(
 					(const xmlChar*)xpaths->s, xpathCtx);
@@ -488,6 +488,7 @@ int xcaps_xpath_set(str *inbuf, str *xpa
 			goto done;
 		/* evaluate xpath expression for parrent node */
 		*p = 0;
+		xmlXPathFreeObject(xpathObj);
 		xpathObj = xmlXPathEvalExpression(
 					(const xmlChar*)xpaths->s, xpathCtx);
 		if(xpathObj == NULL)
@@ -525,7 +526,7 @@ int xcaps_xpath_set(str *inbuf, str *xpa
 		size = nodes->nodeNr;
 		if(val!=NULL)
 			value = (const xmlChar*)val->s;
-    
+
 	/*
 	 * NOTE: the nodes are processed in reverse order, i.e. reverse document
 	 *       order because xmlNodeSetContent can actually free up descendant
@@ -561,7 +562,7 @@ int xcaps_xpath_set(str *inbuf, str *xpa
 		 * This can be exercised by running
 		 *       valgrind xpath2 test3.xml '//discarded' discarded
 		 * There is 2 ways around it:
-		 *   - make a copy of the pointers to the nodes from the result set 
+		 *   - make a copy of the pointers to the nodes from the result set
 		 *     then call xmlXPathFreeObject() and then modify the nodes
 		 * or
 		 *   - remove the reference to the modified nodes from the node set
@@ -599,22 +600,16 @@ int xcaps_xpath_set(str *inbuf, str *xpa
 
 done:
 	if(xpathObj!=NULL) xmlXPathFreeObject(xpathObj);
-	if(xpathCtx!=NULL) xmlXPathFreeContext(xpathCtx); 
+	if(xpathCtx!=NULL) xmlXPathFreeContext(xpathCtx);
 	if(doc!=NULL) xmlFreeDoc(doc);
 	if(newnode!=NULL) xmlFreeDoc(newnode);
-	xpathObj = NULL;
-	xpathCtx = NULL; 
-	doc = NULL; 
 	return 0;
 
 error:
 	if(xpathObj!=NULL) xmlXPathFreeObject(xpathObj);
-	if(xpathCtx!=NULL) xmlXPathFreeContext(xpathCtx); 
+	if(xpathCtx!=NULL) xmlXPathFreeContext(xpathCtx);
 	if(doc!=NULL) xmlFreeDoc(doc);
 	if(newnode!=NULL) xmlFreeDoc(newnode);
-	xpathObj = NULL;
-	xpathCtx = NULL; 
-	doc = NULL; 
 	outbuf->s =   NULL;
 	outbuf->len = 0;
 	return -1;
--- a/src/modules/xmlrpc/http.c
+++ b/src/modules/xmlrpc/http.c
@@ -67,6 +67,7 @@ static int insert_fake_via(sip_msg_t* ms
 		LM_ERR("out of pkg memory\n");
 		goto error;
 	}
+	memset(vb, 0, sizeof(struct via_body));
 
 	msg->h_via1 = pkg_malloc(sizeof(hdr_field_t));
 	if (!msg->h_via1) {
@@ -74,7 +75,6 @@ static int insert_fake_via(sip_msg_t* ms
 		goto error;
 	}
 	memset(msg->h_via1, 0, sizeof(hdr_field_t));
-	memset(vb, 0, sizeof(struct via_body));
 
 	/* FIXME: The code below would break if the VIA prefix
 	 * gets changed in config.h
@@ -121,10 +121,12 @@ static int insert_fake_via(sip_msg_t* ms
 error:
 	if (vb) {
 		free_via_list(vb);
-		pkg_free(vb);
 	}
 
-	if (msg->h_via1) pkg_free(msg->h_via1);
+	if (msg->h_via1) {
+		pkg_free(msg->h_via1);
+		msg->h_via1 = 0;
+	}
 	return -1;
 }
 
--- a/utils/kamcmd/README
+++ b/utils/kamcmd/README
@@ -40,7 +40,7 @@ Options:
     -h          Help message
 address:
     [proto:]name[:port]   where proto is one of tcp, udp, unixs, unix or unixd
-                          e.g.:  tcp:localhost:2048 , unixs:/tmp/ser_ctl
+                          e.g.:  tcp:localhost:2049 , unixs:/tmp/ser_ctl
                           If the protocol is not specified, unixs will be
                           used if name is a filesystem path and udp if not.
                           "unixs" or "unix" stand for unix stream sockets
@@ -141,12 +141,12 @@ $ kamcmd cfg.cfg_set_int_now debug 5 # t
 $ kamcmd # enters interactive mode
 
 Using a tcp socket
-(assumes modparam("ctl", "binrpc", "tcp:localhost:2048") in kamailio.cfg)
+(assumes modparam("ctl", "binrpc", "tcp:localhost:2049") in kamailio.cfg)
 
-$ kamcmd -s tcp:localhost:2048 core.version
+$ kamcmd -s tcp:localhost:2049 core.version
 Server: Kamailio (3.3.2 (i386/linux))
 
-$ kamcmd -s tcp:localhost:2048 SRV _sip._udp.iptel.org
+$ kamcmd -s tcp:localhost:2049 SRV _sip._udp.iptel.org
     name: _sip._udp.iptel.org
     type: SRV
     size (bytes): 104
@@ -161,7 +161,7 @@ $ kamcmd -s tcp:localhost:2048 SRV _sip.
     rr expires in (s): 67693
     rr error flags: 0
 
-kamcmd -s tcp:127.0.0.1:2048  # enters interactive mode over tcp
+kamcmd -s tcp:127.0.0.1:2049  # enters interactive mode over tcp
 
 For more examples see utils/kamcmd/EXAMPLES
  [http://git.sip-router.org/cgi-bin/gitweb.cgi?p=sip-router;a=blob;f=utils/kamcmd/EXAMPLES].
--- a/utils/kamcmd/kamcmd.c
+++ b/utils/kamcmd/kamcmd.c
@@ -103,7 +103,7 @@ Options:\n\
     -h          This help message\n\
 address:\n\
     [proto:]name[:port]   where proto is one of tcp, udp, unixs or unixd\n\
-                          e.g.:  tcp:localhost:2048 , unixs:/tmp/kamailio_ctl\n\
+                          e.g.:  tcp:localhost:2049 , unixs:/tmp/kamailio_ctl\n\
 cmd:\n\
     method  [arg1 [arg2...]]\n\
 arg:\n\
--- a/utils/kamctl/kamctl
+++ b/utils/kamctl/kamctl
@@ -11,7 +11,11 @@ PATH=$PATH:/usr/local/sbin/
 
 # for testing only, please don't enable this in production environments
 # as this introduce security risks
-TEST="false"
+if [ -z "$KAMCTL_TEST" ]; then
+	TEST="false"
+else
+	TEST="true"
+fi
 
 ### include config files
 
--- a/utils/kamctl/kamctl.base
+++ b/utils/kamctl/kamctl.base
@@ -649,7 +649,7 @@ in SIP_DOMAIN"
 
 # check the parameter if it is a valid address of record (user@domain)
 check_aor() {
-	echo "$1" | $EGREP "^$USERNAME_RE@.*\..*" >/dev/null
+	echo "$1" | $EGREP "^$USERNAME_RE@.+" >/dev/null
 	if [ $? -ne 0 ] ; then
 		echo "error: invalid AoR: $1" > /dev/stderr
 		exit 1
@@ -658,7 +658,7 @@ check_aor() {
 
 # check the parameter if it is a valid address of record (user@domain)
 is_aor() {
-	echo "$1" | $EGREP "^$USERNAME_RE@.*\..*" >/dev/null
+	echo "$1" | $EGREP "^$USERNAME_RE@.+" >/dev/null
 	if [ $? -ne 0 ] ; then
 		false
 	else
@@ -668,7 +668,7 @@ is_aor() {
 
 # check the parameter if it is a valid SIP address of record (sip:user@domain)
 check_sipaor() {
-	echo "$1" | $EGREP "^sip(s)?:$USERNAME_RE@.*\..*" >/dev/null
+	echo "$1" | $EGREP "^sip(s)?:$USERNAME_RE@.+" >/dev/null
 	if [ $? -ne 0 ] ; then
 		echo "error: invalid SIP AoR: $1" > /dev/stderr
 		exit 1
@@ -679,7 +679,7 @@ check_sipaor() {
 # quite simplified now -- it captures just very basic
 # errors
 check_uri() {
-	echo "$1" | $EGREP "^sip(s)?:($USERNAME_RE@)?.*\..*"  > /dev/null
+	echo "$1" | $EGREP "^sip(s)?:($USERNAME_RE@)?.+"  > /dev/null
 	if [ $? -ne 0 ] ; then
 		echo "error: invalid SIP URI: $1" > /dev/stderr
 		exit 1
--- a/utils/kamctl/kamdbctl.base
+++ b/utils/kamctl/kamdbctl.base
@@ -205,16 +205,11 @@ merr() {
 #
 get_answer ()
 {
-    value=$1
-    question=$2
-    if [ "${value}" = "ask" ]; then
-        echo -n "$question"
-        read ANSWER
-    else
-        ANSWER=${value}
-    fi
-    ANSWER=${ANSWER:0:1}
-    ANSWER=${ANSWER/Y/y}
-    ANSWER=${ANSWER/N/n}
+	value=$1
+	question=$2
+	if [ "${value}" = "ask" ]; then
+		echo -n "$question"
+		read value
+	fi
+	ANSWER=$(echo ${value} | grep -o -e '[YyNn]' | sed -e 's/Y/y/' -e 's/N/n/')
 }
-
--- /dev/null
+++ b/utils/pdbt/debian/pdb-server.init.d
@@ -0,0 +1,48 @@
+#! /bin/sh
+
+PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
+DAEMON=/usr/bin/pdb_server
+NAME=pdb_server
+DESC=pdb_server
+PIDFILE=/var/run/pdb_server.pid
+
+test -x $DAEMON || exit 0
+
+# Include pdb_server defaults if available
+if [ -f /etc/default/pdb_server ] ; then
+        . /etc/default/pdb_server
+fi
+
+# Include pdb_server config if available
+if [ -f /etc/pdb_server.conf ] ; then
+        . /etc/pdb_server.conf
+fi
+
+set -e
+
+case "$1" in
+  start)
+        echo -n "Starting $DESC: "
+        start-stop-daemon --start --background --make-pidfile --pidfile $PIDFILE -c $PDBUSER -g $PDBGROUP --exec $DAEMON -- -d -m "$MMAPFILE" -i "$BINDADDR" -p "$BINDPORT"
+        echo "."
+        ;;
+  stop)
+        echo -n "Stopping $DESC: "
+        # start-stop-daemon --stop --pidfile $PIDFILE --exec $DAEMON
+        if pgrep -x $NAME &> /dev/null; then killall $NAME; fi
+        rm -f $PIDFILE
+        echo "$NAME."
+        ;;
+  restart|force-reload)
+        if pgrep -x $NAME &> /dev/null; then killall $NAME; fi
+        rm -f $PIDFILE
+        start-stop-daemon --start --background --make-pidfile --pidfile $PIDFILE -c $PDBUSER -g $PDBGROUP --exec $DAEMON -- -d -m "$MMAPFILE" -i "$BINDADDR" -p "$BINDPORT"
+        ;;
+  *)
+        N=/etc/init.d/$NAME
+        echo "Usage: $N {start|stop|restart|force-reload}" >&2
+        exit 1
+        ;;
+esac
+
+exit 0
--- /dev/null
+++ b/src/modules/ims_usrloc_scscf/doc/Makefile
@@ -0,0 +1,4 @@
+docs = ims_usrloc_scscf.xml
+
+docbook_dir = ../../../../doc/docbook
+include $(docbook_dir)/Makefile.module
--- /dev/null
+++ b/src/modules/ims_usrloc_scscf/doc/ims_usrloc_scscf.xml
@@ -0,0 +1,62 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../../doc/docbook/entities.xml">
+%docentities;
+]>
+<book>
+  <bookinfo>
+    <title>IMS Usrloc SCSCF Module</title>
+
+    <productname class="trade">&kamailioname;</productname>
+
+    <authorgroup>
+      <author>
+        <firstname>Jason Penton</firstname>
+
+        <surname/>
+
+        <affiliation>
+          <orgname>Smile Communications</orgname>
+        </affiliation>
+
+        <address>
+          <email>jason.penton@smilecoms.com</email>
+        </address>
+      </author>
+
+      <editor>
+        <firstname>Richard</firstname>
+
+        <surname>Good</surname>
+
+        <affiliation>
+          <orgname>Smile Communications</orgname>
+        </affiliation>
+
+        <address>
+          <email>richard.good@smilecoms.com</email>
+        </address>
+      </editor>
+      
+      <editor>
+        <firstname>Yasin</firstname>
+        <surname>Caner</surname>
+      </editor>
+    </authorgroup>
+
+    <copyright>
+      <year>2012</year>
+      <holder>Smile Communications</holder>
+    </copyright>
+  </bookinfo>
+
+  <toc/>
+
+  <xi:include href="ims_usrloc_scscf_admin.xml"
+    xmlns:xi="http://www.w3.org/2001/XInclude"/>
+
+    <xi:include href="ims_usrloc_scscf_faq.xml"
+      xmlns:xi="http://www.w3.org/2001/XInclude"/>
+    </book>
--- /dev/null
+++ b/src/modules/ims_usrloc_scscf/doc/ims_usrloc_scscf_admin.xml
@@ -0,0 +1,340 @@
+<?xml version="1.0" encoding="ISO-8859-1"?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../../doc/docbook/entities.xml">
+%docentities;
+]>
+<!-- Module User's Guide -->
+<chapter>
+  <title>&adminguide;</title>
+
+  <section>
+    <title>Overview</title>
+    <para>This module serves as a storage engine for SCSCF contacts, much like the standard Kamailio module that is usrloc, is a storage engine for standard SIP contacts.</para>
+  </section>
+  <section>
+    <title>Dependencies</title>
+    <section>
+      <title>&kamailio; Modules</title>
+      <para>The following modules must be loaded before this module:
+      <itemizedlist>
+          <listitem>
+            <para><emphasis>TM</emphasis></para>
+          </listitem>
+          <listitem>
+            <para><emphasis>Presence</emphasis></para>
+          </listitem>
+          <listitem>
+            <para><emphasis>IMS dialog</emphasis></para>
+          </listitem>
+        </itemizedlist>
+      </para>
+    </section>
+  </section>
+  <section>
+    <title>Parameters</title>
+    <section id="ims_usrloc_scscf.p.db_url">
+      <title><varname>db_url</varname> (string)</title>
+      <para>database <acronym>URL</acronym> for storing impu/contacts records</para>
+      <example>
+        <title>Set <varname>db_url</varname>parameter</title>
+        <programlisting format="linespecific">
+        modparam("ims_usrloc_scscf", "db_url", "mysql//username:password@localhost/scscf")
+        </programlisting>
+      </example>
+    </section>
+
+    <section id="ims_usrloc_scscf.p.db_mode">
+      <title><varname>db_mode</varname> (string)</title>
+      <para>This is the database mode to be used for the SCSCF usrloc data persistent storage. Currently this module supports the Write-Back scheme only.</para>
+      <itemizedlist>
+  		<listitem>
+  			<para>
+  			0 - This disables database completely. Only memory will be used.
+  			Contacts will not survive restart.
+  			</para>
+  		</listitem>
+  		<listitem>
+  			<para>
+  			1 - Write-Backend scheme. All changes are made to memory and database synchronization is done in the timer
+  			</para>
+  		</listitem>
+  		</itemizedlist>
+      <para><emphasis> Default value is 0. </emphasis></para>
+      <example>
+        <title>Set <varname>db_mode</varname>(int)</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "db_mode", 1)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.maxcontact">
+      <title>maxcontact (int)</title>
+      <para>The parameter can be used to limit the number of contact for each impu</para>
+      <para><emphasis>Default value is 0(max)</emphasis></para>
+      <example>
+        <title>Set <varname>maxcontact</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "maxcontact", 10)
+        </programlisting>
+       </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.maxcontact_3gpp">
+      <title>maxcontact_3gpp (int)</title>
+      <para>The parameter can be used to limit the number of 3GPP contact for each impu</para>
+      <para><emphasis> Default value is 0.(max) </emphasis></para>
+      <example>
+        <title>Set <varname>maxcontact_3gpp</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "maxcontact_3gpp", 0)
+        </programlisting>
+       </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.maxcontact_behaviour">
+      <title>maxcontact_behaviour (int)</title>
+      <para>Behaviour of usrloc , after impu reach max contacts limit.</para>
+      <itemizedlist>
+  		<listitem>
+  			<para>
+  			0 - Disabled
+  			</para>
+  		</listitem>
+  		<listitem>
+  			<para>
+  			1 - Reject after reaching limit.
+  			</para>
+  		</listitem>
+      <listitem>
+  			<para>
+  			2 - Overwrite
+  			</para>
+  		</listitem>
+  		</itemizedlist>
+      <para><emphasis> Default value is 0. </emphasis></para>
+      <example>
+        <title>Set <varname>maxcontact_behaviour</varname>
+        parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "maxcontact_behaviour", 2)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.max_subscribes">
+      <title>max_subscribes(int)</title>
+      <para>Max number of subscribes allowed per watcher for each IMPU </para>
+      <para><emphasis> Default value is 0. </emphasis></para>
+      <example>
+        <title>Set <varname>subscription_expires_range</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "max_subscribes", 2)
+        </programlisting>
+      </example>
+     </section>
+    <section id="ims_usrloc_scscf.p.sub_dialog_hash_size">
+      <title>sub_dialog_hash_size(int)</title>
+      <para>Subscriber dialog hash table size</para>
+      <para><emphasis> Default value is 10. </emphasis></para>
+      <example>
+        <title>Set<varname>sub_dialog_hash_size</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "sub_dialog_hash_size", 512)
+      </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.timer_procs">
+      <title>timer_procs(int)</title>
+      <para>process number of handling registeration </para>
+      <para><emphasis> Default value is 0 </emphasis></para>
+      <example>
+        <title>Set<varname>timer_procs</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "timer_procs", 5)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.timer_interval">
+      <title>timer_interval (int)</title>
+      <para>Number of seconds between two timer runs. The module uses a timer to delete expired contacts,
+         synchronize with database and other tasks, that need to be run periodically</para>
+      <para><emphasis> Default value is 90  </emphasis></para>
+      <example>
+        <title>Set <varname>timer_interval</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "timer_interval", 120)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.desc_time_order">
+      <title>desc_time_order (int)</title>
+      <para>If the user's contacts should be kept timestamp ordered; otherwise the contact will be ordered based on q value. Non 0 value means true.</para>
+      <para><emphasis> Default value is timestamp ordering not enabled  </emphasis></para>
+      <example>
+        <title>Set <varname>desc_time_order</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "desc_time_order", 1)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.matching_mode">
+      <title>matching_mode (int)</title>
+      <para>What contact matching algorithm to be used.</para>
+      <itemizedlist>
+  		<listitem>
+  			<para>
+  			0 - Contact Only matching
+  			</para>
+  		</listitem>
+  		<listitem>
+  			<para>
+  			1 - Contact and Callid Matching
+  			</para>
+  		</listitem>
+      <listitem>
+  			<para>
+  			2 - Contact and Path header matching
+  			</para>
+  		</listitem>
+      <listitem>
+        <para>
+        3 - Only contact IP and Port Matching
+        </para>
+      </listitem>
+  		</itemizedlist>
+      <para><emphasis> Default value is 0. </emphasis></para>
+      <example>
+        <title>Set <varname>matching_mode</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "matching_mode", 0)
+       </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.cseq_delay">
+      <title>cseq_delay (int)</title>
+      <para>Delay (in seconds) for accepting as retransmissions register requests with same Call-ID and Cseq.</para>
+      <para><emphasis> Default value is 20. </emphasis></para>
+      <example>
+        <title>Set <varname>scscf_name</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "cseq_delay", 20)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.fetch_rows">
+      <title>fetch_rows(int)</title>
+      <para>The number of the rows to be fetched at once from database when loading the location records.</para>
+      <para><emphasis> Default value is 2000. </emphasis></para>
+      <example>
+        <title>Set <varname>fetch_rows</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "fetch_rows", 3000)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.hash_size">
+      <title>hash_size (string)</title>
+      <para>The number of entries of the hash table used by usrloc </para>
+      <para><emphasis> Default value 512</emphasis></para>
+      <example>
+        <title>Set <varname>hash_size</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "hash_size", 512)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.subs_hash_size">
+      <title>subs_hash_size (int)</title>
+      <para>The number of entries of the hash table used by usrloc to store the ims subscribe records</para>
+      <para><emphasis> Default value 512</emphasis></para>
+      <example>
+        <title>Set <varname>subs_hash_size</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "subs_hash_size", 512)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.contacts_hash_size">
+      <title>contacts_hash_size (integer)</title>
+      <para>The number of entries of the hash table used by usrloc to store the contact records</para>
+      <para><emphasis> Default value is 512</emphasis></para>
+      <example>
+        <title>Set <varname>contacts_hash_size</varname>parameter</title>
+        <programlisting format="linespecific">...
+        modparam("ims_usrloc_scscf", "contacts_hash_size", 512)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.nat_bflag">
+      <title>nat_bflag (integer)</title>
+      <para>NAT marker to handle natted registration</para>
+      <para><emphasis> Default value is 0 </emphasis></para>
+      <example>
+        <title>Set <varname>nat_bflag</varname>parameter</title>
+        <programlisting format="linespecific">
+        modparam("ims_usrloc_scscf", "nat_bflag", 3)
+       </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.contact_delete_delay">
+      <title>contact_delete_delay (int)</title>
+      <para>If contact is put into delay delete state ,this is how long we delay before deleting </para>
+      <para><emphasis> Default value is 30</emphasis></para>
+      <example>
+        <title>Set <varname>contact_delete_delay</varname>parameter</title>
+        <programlisting format="linespecific">
+        modparam("ims_usrloc_scscf", "contact_delete_delay", 32)
+	     </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.support_wildcardPSI">
+      <title>support_wildcardPSI (int)</title>
+      <para>Wildcard Public-Service-Identity (RFC5002). it will be actived by setting  1  </para>
+      <para><emphasis> Default value is 0.(disabled) </emphasis></para>
+      <example>
+        <title>Set <varname>support_wildcardPSI</varname> parameter</title>
+        <programlisting format="linespecific">
+        modparam("ims_usrloc_scscf", "support_wildcardPSI", 0)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.unreg_validity">
+      <title>unreg_validity (int)</title>
+      <para>Default validity time in seconds for unregister assignment to SCSCF </para>
+      <para><emphasis> Default value is 1800 </emphasis></para>
+      <example>
+        <title>Set <varname>unreg_validity</varname> parameter</title>
+        <programlisting format="linespecific">
+        modparam("ims_usrloc_scscf", "unreg_validity", 0)
+        </programlisting>
+      </example>
+    </section>
+    <section id="ims_usrloc_scscf.p.user_data_xsd">
+      <title>user_data_xsd (string)</title>
+      <para> </para>
+      <para><emphasis> Default value is 1800 </emphasis></para>
+      <example>
+        <title>Set <varname>unreg_validity</varname> parameter</title>
+        <programlisting format="linespecific">
+        modparam("ims_usrloc_scscf", "user_data_xsd", "/usr/local/etc/kamailio/CxDataType_Rel6.xsd")
+        </programlisting>
+      </example>
+    </section>
+  </section>
+
+  <section>
+    <title>RPC Commands</title>
+    <para>Exported RPC commands.</para>
+    <section id="ims_usrloc_scscf.r.status">
+      <title>ulscscf.status</title>
+      <para></para>
+    </section>
+    <section id="ims_usrloc_scscf.r.showimpu">
+      <title>ulscscf.showimpu</title>
+      <para></para>
+    </section>
+    <section id="ims_usrloc_scscf.r.snapshot">
+      <title>ulscscf.snapshot</title>
+      <para></para>
+    </section>
+  </section>
+</chapter>
--- /dev/null
+++ b/src/modules/ims_usrloc_scscf/doc/ims_usrloc_scscf_faq.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding='ISO-8859-1'?>
+<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
+"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
+<!-- Include general documentation entities -->
+<!ENTITY % docentities SYSTEM "../../../../doc/docbook/entities.xml">
+%docentities;
+]>
+<!-- Module FAQ -->
+<chapter>
+	<title>&faqguide;</title>
+	<qandaset defaultlabel="number">
+	<qandaentry>
+		<question>
+		<para>Where can I find more about &kamailio;?</para>
+		</question>
+		<answer>
+		<para>
+			Take a look at &kamailiohomelink;.
+		</para>
+		</answer>
+	</qandaentry>
+	<qandaentry>
+		<question>
+		<para>Where can I post a question about this module?</para>
+		</question>
+		<answer>
+		<para>
+			First at all check if your question was already answered on one of
+			our mailing lists:
+		</para>
+		<itemizedlist>
+			<listitem>
+			<para>User Mailing List - &kamailiouserslink;</para>
+			</listitem>
+			<listitem>
+			<para>Developer Mailing List - &kamailiodevlink;</para>
+			</listitem>
+		</itemizedlist>
+		<para>
+			E-mails regarding any stable &kamailio; release should be sent to
+			&kamailiousersmail; and e-mails regarding development versions
+			should be sent to &kamailiodevmail;.
+		</para>
+		</answer>
+	</qandaentry>
+	<qandaentry>
+		<question>
+		<para>How can I report a bug?</para>
+		</question>
+		<answer>
+		<para>
+			Please follow the guidelines provided at:
+			&kamailiobugslink;.
+		</para>
+		</answer>
+	</qandaentry>
+	</qandaset>
+</chapter>
