From: Victor Seva <linuxmaniac@torreviejawireless.org>
Date: Tue, 16 Jun 2020 09:31:55 +0200
Subject: sca: clang format code

---
 src/modules/sca/sca.c            |  171 ++++---
 src/modules/sca/sca.h            |    6 +-
 src/modules/sca/sca_appearance.c |  531 ++++++++++----------
 src/modules/sca/sca_appearance.h |   66 +--
 src/modules/sca/sca_call_info.c  | 1024 ++++++++++++++++++++------------------
 src/modules/sca/sca_call_info.h  |   36 +-
 src/modules/sca/sca_common.h     |   36 +-
 src/modules/sca/sca_db.c         |  164 +++---
 src/modules/sca/sca_db.h         |   32 +-
 src/modules/sca/sca_dialog.c     |   41 +-
 src/modules/sca/sca_dialog.h     |   11 +-
 src/modules/sca/sca_event.c      |   22 +-
 src/modules/sca/sca_event.h      |    6 +-
 src/modules/sca/sca_hash.c       |   71 ++-
 src/modules/sca/sca_hash.h       |   23 +-
 src/modules/sca/sca_notify.c     |  151 +++---
 src/modules/sca/sca_reply.c      |   16 +-
 src/modules/sca/sca_rpc.c        |  197 ++++----
 src/modules/sca/sca_subscribe.c  |  771 ++++++++++++++--------------
 src/modules/sca/sca_subscribe.h  |   39 +-
 src/modules/sca/sca_util.c       |  157 +++---
 src/modules/sca/sca_util.h       |    3 +-
 22 files changed, 1864 insertions(+), 1710 deletions(-)

diff --git a/src/modules/sca/sca.c b/src/modules/sca/sca.c
index dba9ff0..07dac39 100644
--- a/src/modules/sca/sca.c
+++ b/src/modules/sca/sca.c
@@ -60,9 +60,9 @@ sca_mod *sca = NULL;
 /*
  * EXTERNAL API
  */
-db_func_t dbf;	// db api
+db_func_t dbf;		 // db api
 struct tm_binds tmb; // tm functions for sending messages
-sl_api_t slb; // sl callback, function for getting to-tag
+sl_api_t slb;		 // sl callback, function for getting to-tag
 
 /*
  * PROTOTYPES
@@ -71,10 +71,10 @@ static int sca_mod_init(void);
 static int sca_child_init(int);
 static void sca_mod_destroy(void);
 static int sca_set_config(sca_mod *);
-static int sca_call_info_update_0_f(sip_msg_t* msg, char*, char*);
-static int sca_call_info_update_1_f(sip_msg_t* msg, char*, char*);
-static int sca_call_info_update_2_f(sip_msg_t* msg, char*, char*);
-static int sca_call_info_update_3_f(sip_msg_t* msg, char*, char*, char *);
+static int sca_call_info_update_0_f(sip_msg_t *msg, char *, char *);
+static int sca_call_info_update_1_f(sip_msg_t *msg, char *, char *);
+static int sca_call_info_update_2_f(sip_msg_t *msg, char *, char *);
+static int sca_call_info_update_3_f(sip_msg_t *msg, char *, char *, char *);
 int fixup_ciu(void **, int);
 int fixup_free_ciu(void **param, int param_no);
 
@@ -84,16 +84,18 @@ int fixup_free_ciu(void **param, int param_no);
 static cmd_export_t cmds[] = {
 		{"sca_handle_subscribe", (cmd_function)sca_handle_subscribe, 0, NULL, 0,
 				REQUEST_ROUTE},
-		{"sca_call_info_update", (cmd_function)sca_call_info_update_0_f, 0, NULL, 0,
-				REQUEST_ROUTE | FAILURE_ROUTE | ONREPLY_ROUTE},
+		{"sca_call_info_update", (cmd_function)sca_call_info_update_0_f, 0,
+				NULL, 0, REQUEST_ROUTE | FAILURE_ROUTE | ONREPLY_ROUTE},
 		{"sca_call_info_update", (cmd_function)sca_call_info_update_1_f, 1,
-			fixup_ciu, fixup_free_ciu, REQUEST_ROUTE | FAILURE_ROUTE | ONREPLY_ROUTE},
+				fixup_ciu, fixup_free_ciu,
+				REQUEST_ROUTE | FAILURE_ROUTE | ONREPLY_ROUTE},
 		{"sca_call_info_update", (cmd_function)sca_call_info_update_2_f, 2,
-			fixup_ciu, fixup_free_ciu, REQUEST_ROUTE | FAILURE_ROUTE | ONREPLY_ROUTE},
+				fixup_ciu, fixup_free_ciu,
+				REQUEST_ROUTE | FAILURE_ROUTE | ONREPLY_ROUTE},
 		{"sca_call_info_update", (cmd_function)sca_call_info_update_3_f, 3,
-			fixup_ciu, fixup_free_ciu, REQUEST_ROUTE | FAILURE_ROUTE | ONREPLY_ROUTE},
-		{ 0, 0, 0, 0, 0, 0 }
-};
+				fixup_ciu, fixup_free_ciu,
+				REQUEST_ROUTE | FAILURE_ROUTE | ONREPLY_ROUTE},
+		{0, 0, 0, 0, 0, 0}};
 
 /*
  * EXPORTED RPC INTERFACE
@@ -158,6 +160,7 @@ static param_export_t params[] = {
 /*
  * MODULE EXPORTS
  */
+/* clang-format off */
 struct module_exports exports= {
 	"sca",           /* module name */
 	DEFAULT_DLFLAGS, /* dlopen flags */
@@ -170,6 +173,7 @@ struct module_exports exports= {
 	sca_child_init,  /* per-child init function */
 	sca_mod_destroy  /* module destroy function */
 };
+/* clang-format on */
 
 static int sca_bind_sl(sca_mod *scam, sl_api_t *sl_api)
 {
@@ -178,16 +182,17 @@ static int sca_bind_sl(sca_mod *scam, sl_api_t *sl_api)
 	assert(scam != NULL);
 	assert(sl_api != NULL);
 
-	if (sl_load_api(sl_api) != 0) {
-		LM_ERR("Failed to initialize required sl API. Check if the \"sl\" module is loaded.\n");
+	if(sl_load_api(sl_api) != 0) {
+		LM_ERR("Failed to initialize required sl API. Check if the \"sl\" "
+			   "module is loaded.\n");
 		return (-1);
 	}
 	scam->sl_api = sl_api;
 
 	sl_cbe.type = SLCB_REPLY_READY;
-	sl_cbe.cbf = (sl_cbf_f) sca_call_info_sl_reply_cb;
+	sl_cbe.cbf = (sl_cbf_f)sca_call_info_sl_reply_cb;
 
-	if (scam->sl_api->register_cb(&sl_cbe) < 0) {
+	if(scam->sl_api->register_cb(&sl_cbe) < 0) {
 		LM_ERR("Failed to register sl reply callback\n");
 		return (-1);
 	}
@@ -200,13 +205,14 @@ static int sca_bind_srdb1(sca_mod *scam, db_func_t *db_api)
 	db1_con_t *db_con = NULL;
 	int rc = -1;
 
-	if (db_bind_mod(scam->cfg->db_url, db_api) != 0) {
-		LM_ERR("Failed to initialize required DB API - %.*s\n", STR_FMT(scam->cfg->db_url));
+	if(db_bind_mod(scam->cfg->db_url, db_api) != 0) {
+		LM_ERR("Failed to initialize required DB API - %.*s\n",
+				STR_FMT(scam->cfg->db_url));
 		goto done;
 	}
 	scam->db_api = db_api;
 
-	if (!DB_CAPABILITY((*db_api), DB_CAP_ALL)) {
+	if(!DB_CAPABILITY((*db_api), DB_CAP_ALL)) {
 		LM_ERR("Selected database %.*s lacks required capabilities\n",
 				STR_FMT(scam->cfg->db_url));
 		goto done;
@@ -214,14 +220,15 @@ static int sca_bind_srdb1(sca_mod *scam, db_func_t *db_api)
 
 	// ensure database exists and table schemas are correct
 	db_con = db_api->init(scam->cfg->db_url);
-	if (db_con == NULL) {
+	if(db_con == NULL) {
 		LM_ERR("sca_bind_srdb1: failed to connect to DB %.*s\n",
 				STR_FMT(scam->cfg->db_url));
 		goto done;
 	}
 
-	if (db_check_table_version(db_api, db_con, scam->cfg->subs_table,
-			SCA_DB_SUBSCRIPTIONS_TABLE_VERSION) < 0) {
+	if(db_check_table_version(db_api, db_con, scam->cfg->subs_table,
+			   SCA_DB_SUBSCRIPTIONS_TABLE_VERSION)
+			< 0) {
 		str tmp = *scam->cfg->subs_table;
 		DB_TABLE_VERSION_ERROR(tmp);
 		goto done;
@@ -230,7 +237,8 @@ static int sca_bind_srdb1(sca_mod *scam, db_func_t *db_api)
 	// DB and tables are OK, close DB handle. reopen in each child.
 	rc = 0;
 
-	done: if (db_con != NULL) {
+done:
+	if(db_con != NULL) {
 		db_api->close(db_con);
 		db_con = NULL;
 	}
@@ -240,36 +248,36 @@ static int sca_bind_srdb1(sca_mod *scam, db_func_t *db_api)
 
 static int sca_set_config(sca_mod *scam)
 {
-	scam->cfg = (sca_config *) shm_malloc(sizeof(sca_config));
-	if (scam->cfg == NULL) {
+	scam->cfg = (sca_config *)shm_malloc(sizeof(sca_config));
+	if(scam->cfg == NULL) {
 		LM_ERR("Failed to shm_malloc module configuration\n");
 		return (-1);
 	}
 	memset(scam->cfg, 0, sizeof(sca_config));
 
-	if (outbound_proxy.s) {
+	if(outbound_proxy.s) {
 		scam->cfg->outbound_proxy = &outbound_proxy;
 	}
 
-	if (!db_url.s || db_url.len <= 0) {
+	if(!db_url.s || db_url.len <= 0) {
 		LM_ERR("sca_set_config: db_url must be set!\n");
 		return (-1);
 	}
 	scam->cfg->db_url = &db_url;
 
-	if (!db_subs_table.s || db_subs_table.len <= 0) {
+	if(!db_subs_table.s || db_subs_table.len <= 0) {
 		LM_ERR("sca_set_config: subs_table must be set!\n");
 		return (-1);
 	}
 	scam->cfg->subs_table = &db_subs_table;
 
-	if (!db_state_table.s || db_state_table.len <= 0) {
+	if(!db_state_table.s || db_state_table.len <= 0) {
 		LM_ERR("sca_set_config: state_table must be set!\n");
 		return (-1);
 	}
 	scam->cfg->state_table = &db_state_table;
 
-	if (hash_table_size > 0) {
+	if(hash_table_size > 0) {
 		scam->cfg->hash_table_size = 1 << hash_table_size;
 	} else {
 		scam->cfg->hash_table_size = 512;
@@ -285,7 +293,7 @@ static int sca_set_config(sca_mod *scam)
 	}
 	scam->cfg->onhold_bflag = onhold_bflag;
 
-	if (server_address.s) {
+	if(server_address.s) {
 		scam->cfg->server_address = &server_address;
 	}
 
@@ -294,24 +302,26 @@ static int sca_set_config(sca_mod *scam)
 
 static int sca_child_init(int rank)
 {
-	if (rank == PROC_INIT || rank == PROC_TCP_MAIN) {
+	if(rank == PROC_INIT || rank == PROC_TCP_MAIN) {
 		return (0);
 	}
 
-	if (rank == PROC_MAIN) {
-		if (fork_dummy_timer(PROC_TIMER, "SCA DB SYNC PROCESS", 0, // we don't need sockets, just writing to DB
-		sca_subscription_db_update_timer, // timer cb
-		NULL, // parameter passed to callback
-		sca->cfg->db_update_interval) < 0) {
+	if(rank == PROC_MAIN) {
+		if(fork_dummy_timer(PROC_TIMER, "SCA DB SYNC PROCESS",
+				   0, // we don't need sockets, just writing to DB
+				   sca_subscription_db_update_timer, // timer cb
+				   NULL, // parameter passed to callback
+				   sca->cfg->db_update_interval)
+				< 0) {
 			LM_ERR("sca_child_init: failed to register subscription DB "
-					"sync timer process\n");
+				   "sync timer process\n");
 			return (-1);
 		}
 
 		return (0);
 	}
 
-	if (sca->db_api == NULL || sca->db_api->init == NULL) {
+	if(sca->db_api == NULL || sca->db_api->init == NULL) {
 		LM_CRIT("sca_child_init: DB API not loaded!\n");
 		return (-1);
 	}
@@ -321,45 +331,47 @@ static int sca_child_init(int rank)
 
 static int sca_mod_init(void)
 {
-	sca = (sca_mod *) shm_malloc(sizeof(sca_mod));
-	if (sca == NULL) {
+	sca = (sca_mod *)shm_malloc(sizeof(sca_mod));
+	if(sca == NULL) {
 		LM_ERR("Failed to shm_malloc module object\n");
 		return (-1);
 	}
 	memset(sca, 0, sizeof(sca_mod));
 
-	if (sca_set_config(sca) != 0) {
+	if(sca_set_config(sca) != 0) {
 		LM_ERR("Failed to set configuration\n");
 		goto error;
 	}
 
-	if (rpc_register_array(sca_rpc) != 0) {
+	if(rpc_register_array(sca_rpc) != 0) {
 		LM_ERR("Failed to register RPC commands\n");
 		goto error;
 	}
 
-	if (sca_bind_srdb1(sca, &dbf) != 0) {
+	if(sca_bind_srdb1(sca, &dbf) != 0) {
 		LM_ERR("Failed to initialize required DB API\n");
 		goto error;
 	}
 
-	if (load_tm_api(&tmb) != 0) {
-		LM_ERR("Failed to initialize required tm API. Check that the \"tm\" module is loaded before this module.\n");
+	if(load_tm_api(&tmb) != 0) {
+		LM_ERR("Failed to initialize required tm API. Check that the \"tm\" "
+			   "module is loaded before this module.\n");
 		goto error;
 	}
 	sca->tm_api = &tmb;
 
-	if (sca_bind_sl(sca, &slb) != 0) {
-		LM_ERR("Failed to initialize required sl API. Check that the \"sl\" module is loaded before this module.\n");
+	if(sca_bind_sl(sca, &slb) != 0) {
+		LM_ERR("Failed to initialize required sl API. Check that the \"sl\" "
+			   "module is loaded before this module.\n");
 		goto error;
 	}
 
-	if (sca_hash_table_create(&sca->subscriptions, sca->cfg->hash_table_size)
+	if(sca_hash_table_create(&sca->subscriptions, sca->cfg->hash_table_size)
 			!= 0) {
 		LM_ERR("Failed to create subscriptions hash table\n");
 		goto error;
 	}
-	if (sca_hash_table_create(&sca->appearances, sca->cfg->hash_table_size)
+	if(sca_hash_table_create(&sca->appearances, sca->cfg->hash_table_size)
 			!= 0) {
 		LM_ERR("Failed to create appearances hash table\n");
 		goto error;
@@ -369,8 +381,8 @@ static int sca_mod_init(void)
 
 	register_timer(sca_subscription_purge_expired, sca,
 			sca->cfg->purge_expired_interval);
-	register_timer(sca_appearance_purge_stale, sca,
-			sca->cfg->purge_expired_interval);
+	register_timer(
+			sca_appearance_purge_stale, sca, sca->cfg->purge_expired_interval);
 
 	// register separate timer process to write subscriptions to DB.
 	// move to 3.3+ timer API (register_basic_timer) at some point.
@@ -381,14 +393,15 @@ static int sca_mod_init(void)
 
 	return (0);
 
-	error: if (sca != NULL) {
-		if (sca->cfg != NULL) {
+error:
+	if(sca != NULL) {
+		if(sca->cfg != NULL) {
 			shm_free(sca->cfg);
 		}
-		if (sca->subscriptions != NULL) {
+		if(sca->subscriptions != NULL) {
 			sca_hash_table_free(sca->subscriptions);
 		}
-		if (sca->appearances != NULL) {
+		if(sca->appearances != NULL) {
 			sca_hash_table_free(sca->appearances);
 		}
 		shm_free(sca);
@@ -400,75 +413,73 @@ static int sca_mod_init(void)
 
 void sca_mod_destroy(void)
 {
-	if (sca == 0)
+	if(sca == 0)
 		return;
 
 	// write back to the DB to retain most current subscription info
-	if (sca_subscription_db_update() != 0) {
-		if (sca && sca->cfg && sca->cfg->db_url) {
+	if(sca_subscription_db_update() != 0) {
+		if(sca && sca->cfg && sca->cfg->db_url) {
 			LM_ERR("sca_mod_destroy: failed to save current subscriptions \n"
-					"in DB %.*s", STR_FMT(sca->cfg->db_url));
+				   "in DB %.*s",
+					STR_FMT(sca->cfg->db_url));
 		}
 	}
 
 	sca_db_disconnect();
 }
 
-static int sca_call_info_update_0_f(sip_msg_t* msg, char* p1, char* p2)
+static int sca_call_info_update_0_f(sip_msg_t *msg, char *p1, char *p2)
 {
 	return sca_call_info_update(msg, SCA_CALL_INFO_SHARED_BOTH, NULL, NULL);
 }
 
-static int sca_call_info_update_1_f(sip_msg_t* msg, char* p1, char* p2)
+static int sca_call_info_update_1_f(sip_msg_t *msg, char *p1, char *p2)
 {
 	int update_mask = SCA_CALL_INFO_SHARED_BOTH;
 
-	if (get_int_fparam(&update_mask, msg, (fparam_t *) p1) < 0) {
+	if(get_int_fparam(&update_mask, msg, (fparam_t *)p1) < 0) {
 		LM_ERR("sca_call_info_update: argument 1: bad value "
-				"(integer expected)\n");
+			   "(integer expected)\n");
 		return (-1);
 	}
 
 	return sca_call_info_update(msg, update_mask, NULL, NULL);
 }
 
-static int sca_call_info_update_2_f(sip_msg_t* msg, char* p1, char* p2)
+static int sca_call_info_update_2_f(sip_msg_t *msg, char *p1, char *p2)
 {
 	str uri_to = STR_NULL;
 	int update_mask = SCA_CALL_INFO_SHARED_BOTH;
 
-	if (get_int_fparam(&update_mask, msg, (fparam_t *) p1) < 0) {
+	if(get_int_fparam(&update_mask, msg, (fparam_t *)p1) < 0) {
 		LM_ERR("sca_call_info_update: argument 1: bad value "
-				"(integer expected)\n");
+			   "(integer expected)\n");
 		return (-1);
 	}
-	if(get_str_fparam(&uri_to, msg, (gparam_p)p2)!=0)
-	{
+	if(get_str_fparam(&uri_to, msg, (gparam_p)p2) != 0) {
 		LM_ERR("unable to get value from param pvar_to\n");
 		return -1;
 	}
 	return sca_call_info_update(msg, update_mask, &uri_to, NULL);
 }
 
-static int sca_call_info_update_3_f(sip_msg_t* msg,
-	char* p1, char* p2, char * p3)
+static int sca_call_info_update_3_f(
+		sip_msg_t *msg, char *p1, char *p2, char *p3)
 {
 	str uri_to = STR_NULL;
 	str uri_from = STR_NULL;
 	int update_mask = SCA_CALL_INFO_SHARED_BOTH;
 
-	if (get_int_fparam(&update_mask, msg, (fparam_t *) p1) < 0) {
+	if(get_int_fparam(&update_mask, msg, (fparam_t *)p1) < 0) {
 		LM_ERR("sca_call_info_update: argument 1: bad value "
-				"(integer expected)\n");
+			   "(integer expected)\n");
 		return (-1);
 	}
-	if(get_str_fparam(&uri_to, msg, (gparam_p)p2)!=0)
-	{
+	if(get_str_fparam(&uri_to, msg, (gparam_p)p2) != 0) {
 		LM_ERR("unable to get value from param pvar_to\n");
 		return -1;
 	}
-	if(get_str_fparam(&uri_from, msg, (gparam_p)p3)!=0)
-	{
+	if(get_str_fparam(&uri_from, msg, (gparam_p)p3) != 0) {
 		LM_ERR("unable to get value from param pvar_from\n");
 		return -1;
 	}
@@ -490,7 +501,7 @@ int ki_sca_call_info_update_turi(sip_msg_t *msg, int umask, str *sto)
 
 int fixup_ciu(void **param, int param_no)
 {
-	switch (param_no) {
+	switch(param_no) {
 		case 1:
 			return fixup_var_int_1(param, param_no);
 		case 2:
@@ -503,7 +514,7 @@ int fixup_ciu(void **param, int param_no)
 
 int fixup_free_ciu(void **param, int param_no)
 {
-	switch (param_no) {
+	switch(param_no) {
 		case 1:
 			return 0;
 		case 2:
diff --git a/src/modules/sca/sca.h b/src/modules/sca/sca.h
index 04d3c1e..cceae17 100644
--- a/src/modules/sca/sca.h
+++ b/src/modules/sca/sca.h
@@ -27,7 +27,8 @@
 #ifndef SCA_H
 #define SCA_H
 
-struct _sca_config {
+struct _sca_config
+{
 	str *outbound_proxy;
 	str *db_url;
 	str *subs_table;
@@ -42,7 +43,8 @@ struct _sca_config {
 };
 typedef struct _sca_config sca_config;
 
-struct _sca_mod {
+struct _sca_mod
+{
 	sca_config *cfg;
 	sca_hash_table *subscriptions;
 	sca_hash_table *appearances;
diff --git a/src/modules/sca/sca_appearance.c b/src/modules/sca/sca_appearance.c
index 9d94890..78ee5d8 100644
--- a/src/modules/sca/sca_appearance.c
+++ b/src/modules/sca/sca_appearance.c
@@ -37,7 +37,8 @@ const str SCA_APPEARANCE_STATE_STR_PROGRESSING = STR_STATIC_INIT("progressing");
 const str SCA_APPEARANCE_STATE_STR_ALERTING = STR_STATIC_INIT("alerting");
 const str SCA_APPEARANCE_STATE_STR_ACTIVE = STR_STATIC_INIT("active");
 const str SCA_APPEARANCE_STATE_STR_HELD = STR_STATIC_INIT("held");
-const str SCA_APPEARANCE_STATE_STR_HELD_PRIVATE = STR_STATIC_INIT("held-private");
+const str SCA_APPEARANCE_STATE_STR_HELD_PRIVATE =
+		STR_STATIC_INIT("held-private");
 const str SCA_APPEARANCE_STATE_STR_UNKNOWN = STR_STATIC_INIT("unknown");
 
 // STR_ACTIVE is repeated, once for ACTIVE_PENDING, once for ACTIVE
@@ -59,7 +60,7 @@ void sca_appearance_state_to_str(int state, str *state_str)
 {
 	assert(state_str != NULL);
 
-	if (state >= SCA_APPEARANCE_STATE_NAME_COUNT || state < 0) {
+	if(state >= SCA_APPEARANCE_STATE_NAME_COUNT || state < 0) {
 		state_str->len = SCA_APPEARANCE_STATE_STR_UNKNOWN.len;
 		state_str->s = SCA_APPEARANCE_STATE_STR_UNKNOWN.s;
 
@@ -76,12 +77,12 @@ int sca_appearance_state_from_str(str *state_str)
 
 	assert(state_str != NULL);
 
-	for (state = 0; state < SCA_APPEARANCE_STATE_NAME_COUNT; state++) {
-		if (SCA_STR_EQ(state_str, state_names[state])) {
+	for(state = 0; state < SCA_APPEARANCE_STATE_NAME_COUNT; state++) {
+		if(SCA_STR_EQ(state_str, state_names[state])) {
 			break;
 		}
 	}
-	if (state >= SCA_APPEARANCE_STATE_NAME_COUNT) {
+	if(state >= SCA_APPEARANCE_STATE_NAME_COUNT) {
 		state = SCA_APPEARANCE_STATE_UNKNOWN;
 	}
 
@@ -95,16 +96,16 @@ sca_appearance *sca_appearance_create(int appearance_index, str *owner_uri)
 	// we use multiple shm_malloc calls here because uri, owner,
 	// dialog and callee are mutable. could also shm_malloc a big
 	// block and divide it among the strs....
-	new_appearance = (sca_appearance *) shm_malloc(sizeof(sca_appearance));
-	if (new_appearance == NULL) {
+	new_appearance = (sca_appearance *)shm_malloc(sizeof(sca_appearance));
+	if(new_appearance == NULL) {
 		LM_ERR("Failed to shm_malloc new sca_appearance for %.*s, index %d\n",
 				STR_FMT(owner_uri), appearance_index);
 		goto error;
 	}
 	memset(new_appearance, 0, sizeof(sca_appearance));
 
-	new_appearance->owner.s = (char *) shm_malloc(owner_uri->len);
-	if (new_appearance->owner.s == NULL) {
+	new_appearance->owner.s = (char *)shm_malloc(owner_uri->len);
+	if(new_appearance->owner.s == NULL) {
 		LM_ERR("Failed to shm_malloc space for owner %.*s, index %d\n",
 				STR_FMT(owner_uri), appearance_index);
 		goto error;
@@ -113,14 +114,15 @@ sca_appearance *sca_appearance_create(int appearance_index, str *owner_uri)
 
 	new_appearance->index = appearance_index;
 	new_appearance->times.ctime = time(NULL);
-	sca_appearance_update_state_unsafe(new_appearance,
-			SCA_APPEARANCE_STATE_IDLE);
+	sca_appearance_update_state_unsafe(
+			new_appearance, SCA_APPEARANCE_STATE_IDLE);
 	new_appearance->next = NULL;
 
 	return (new_appearance);
 
-	error: if (new_appearance != NULL) {
-		if (!SCA_STR_EMPTY(&new_appearance->owner)) {
+error:
+	if(new_appearance != NULL) {
+		if(!SCA_STR_EMPTY(&new_appearance->owner)) {
 			shm_free(new_appearance->owner.s);
 		}
 		shm_free(new_appearance);
@@ -130,24 +132,24 @@ sca_appearance *sca_appearance_create(int appearance_index, str *owner_uri)
 
 void sca_appearance_free(sca_appearance *appearance)
 {
-	if (appearance != NULL) {
-		if (appearance->owner.s != NULL) {
+	if(appearance != NULL) {
+		if(appearance->owner.s != NULL) {
 			shm_free(appearance->owner.s);
 		}
-		if (appearance->uri.s != NULL) {
+		if(appearance->uri.s != NULL) {
 			shm_free(appearance->uri.s);
 		}
-		if (appearance->dialog.id.s != NULL) {
+		if(appearance->dialog.id.s != NULL) {
 			shm_free(appearance->dialog.id.s);
 		}
 
-		if (appearance->prev_owner.s != NULL) {
+		if(appearance->prev_owner.s != NULL) {
 			shm_free(appearance->prev_owner.s);
 		}
-		if (appearance->prev_callee.s != NULL) {
+		if(appearance->prev_callee.s != NULL) {
 			shm_free(appearance->prev_callee.s);
 		}
-		if (appearance->prev_dialog.id.s != NULL) {
+		if(appearance->prev_dialog.id.s != NULL) {
 			shm_free(appearance->prev_dialog.id.s);
 		}
 		shm_free(appearance);
@@ -170,9 +172,9 @@ static int sca_appearance_list_next_available_index_unsafe(
 
 	assert(app_list != NULL);
 
-	for (app_cur = app_list->appearances; app_cur != NULL;
+	for(app_cur = app_list->appearances; app_cur != NULL;
 			app_cur = app_cur->next, idx++) {
-		if (idx < app_cur->index) {
+		if(idx < app_cur->index) {
 			break;
 		}
 	}
@@ -186,15 +188,15 @@ static sca_appearance_list *sca_appearance_list_create(sca_mod *scam, str *aor)
 	int len;
 
 	len = sizeof(sca_appearance_list) + aor->len;
-	app_list = (sca_appearance_list *) shm_malloc(len);
-	if (app_list == NULL) {
+	app_list = (sca_appearance_list *)shm_malloc(len);
+	if(app_list == NULL) {
 		LM_ERR("Failed to shm_malloc sca_appearance_list for %.*s\n",
 				STR_FMT(aor));
 		return (NULL);
 	}
 	memset(app_list, 0, sizeof(sca_appearance_list));
 	len = sizeof(sca_appearance_list);
-	app_list->aor.s = (char *) app_list + len;
+	app_list->aor.s = (char *)app_list + len;
 	SCA_STR_COPY(&app_list->aor, aor);
 
 	return (app_list);
@@ -206,8 +208,8 @@ sca_appearance_list *sca_appearance_list_for_line(sca_mod *scam, str *aor)
 	return (NULL);
 }
 
-void sca_appearance_list_insert_appearance(sca_appearance_list *app_list,
-		sca_appearance *app)
+void sca_appearance_list_insert_appearance(
+		sca_appearance_list *app_list, sca_appearance *app)
 {
 	sca_appearance **cur;
 
@@ -216,8 +218,8 @@ void sca_appearance_list_insert_appearance(sca_appearance_list *app_list,
 
 	app->appearance_list = app_list;
 
-	for (cur = &app_list->appearances; *cur != NULL; cur = &(*cur)->next) {
-		if (app->index < (*cur)->index) {
+	for(cur = &app_list->appearances; *cur != NULL; cur = &(*cur)->next) {
+		if(app->index < (*cur)->index) {
 			break;
 		}
 	}
@@ -225,8 +227,8 @@ void sca_appearance_list_insert_appearance(sca_appearance_list *app_list,
 	*cur = app;
 }
 
-sca_appearance *sca_appearance_list_unlink_index(sca_appearance_list *app_list,
-		int idx)
+sca_appearance *sca_appearance_list_unlink_index(
+		sca_appearance_list *app_list, int idx)
 {
 	sca_appearance *app = NULL;
 	sca_appearance **cur;
@@ -234,8 +236,8 @@ sca_appearance *sca_appearance_list_unlink_index(sca_appearance_list *app_list,
 	assert(app_list != NULL);
 	assert(idx > 0);
 
-	for (cur = &app_list->appearances; *cur != NULL; cur = &(*cur)->next) {
-		if ((*cur)->index == idx) {
+	for(cur = &app_list->appearances; *cur != NULL; cur = &(*cur)->next) {
+		if((*cur)->index == idx) {
 			app = *cur;
 			app->appearance_list = NULL;
 			*cur = (*cur)->next;
@@ -243,15 +245,15 @@ sca_appearance *sca_appearance_list_unlink_index(sca_appearance_list *app_list,
 		}
 	}
 
-	if (app == NULL) {
+	if(app == NULL) {
 		LM_ERR("Tried to remove inactive %.*s appearance at index %d\n",
 				STR_FMT(&app_list->aor), idx);
 	}
 	return (app);
 }
 
-int sca_appearance_list_unlink_appearance(sca_appearance_list *app_list,
-		sca_appearance **app)
+int sca_appearance_list_unlink_appearance(
+		sca_appearance_list *app_list, sca_appearance **app)
 {
 	sca_appearance **cur;
 	int rc = 0;
@@ -259,8 +261,8 @@ int sca_appearance_list_unlink_appearance(sca_appearance_list *app_list,
 	assert(app_list != NULL);
 	assert(app != NULL && *app != NULL);
 
-	for (cur = &app_list->appearances; *cur != NULL; cur = &(*cur)->next) {
-		if (*cur == *app) {
+	for(cur = &app_list->appearances; *cur != NULL; cur = &(*cur)->next) {
+		if(*cur == *app) {
 			*cur = (*cur)->next;
 			(*app)->appearance_list = NULL;
 			(*app)->next = NULL;
@@ -272,44 +274,45 @@ int sca_appearance_list_unlink_appearance(sca_appearance_list *app_list,
 	return (rc);
 }
 
-int sca_appearance_list_aor_cmp(str *aor, void *cmp_value) {
-	sca_appearance_list *app_list = (sca_appearance_list *) cmp_value;
+int sca_appearance_list_aor_cmp(str *aor, void *cmp_value)
+{
+	sca_appearance_list *app_list = (sca_appearance_list *)cmp_value;
 	int cmp;
 
-	if ((cmp = aor->len - app_list->aor.len) != 0) {
+	if((cmp = aor->len - app_list->aor.len) != 0) {
 		return (cmp);
 	}
 
 	return (memcmp(aor->s, app_list->aor.s, aor->len));
 }
 
-void sca_appearance_list_print(void *value) {
-	sca_appearance_list *app_list = (sca_appearance_list *) value;
+void sca_appearance_list_print(void *value)
+{
+	sca_appearance_list *app_list = (sca_appearance_list *)value;
 	sca_appearance *app;
 	str state_str = STR_NULL;
 
 	LM_INFO("Appearance state for AoR %.*s:\n", STR_FMT(&app_list->aor));
 
-	for (app = app_list->appearances; app != NULL; app = app->next) {
+	for(app = app_list->appearances; app != NULL; app = app->next) {
 		sca_appearance_state_to_str(app->state, &state_str);
 		LM_INFO("index: %d, state: %.*s, uri: %.*s, owner: %.*s, "
 				"callee: %.*s, dialog: %.*s;%.*s;%.*s\n",
-				app->index, STR_FMT(&state_str),
-				STR_FMT(&app->uri), STR_FMT(&app->owner),
-				STR_FMT(&app->callee), STR_FMT(&app->dialog.call_id),
-				STR_FMT(&app->dialog.from_tag),
+				app->index, STR_FMT(&state_str), STR_FMT(&app->uri),
+				STR_FMT(&app->owner), STR_FMT(&app->callee),
+				STR_FMT(&app->dialog.call_id), STR_FMT(&app->dialog.from_tag),
 				STR_FMT(&app->dialog.to_tag));
 	}
 }
 
 void sca_appearance_list_free(void *value)
 {
-	sca_appearance_list *app_list = (sca_appearance_list *) value;
+	sca_appearance_list *app_list = (sca_appearance_list *)value;
 	sca_appearance *app, *app_tmp;
 
 	LM_DBG("Freeing appearance list for AoR %.*s\n", STR_FMT(&app_list->aor));
 
-	for (app = app_list->appearances; app != NULL; app = app_tmp) {
+	for(app = app_list->appearances; app != NULL; app = app_tmp) {
 		app_tmp = app->next;
 		shm_free(app);
 	}
@@ -324,28 +327,31 @@ int sca_appearance_register(sca_mod *scam, str *aor)
 	assert(scam != NULL);
 	assert(aor != NULL);
 
-	if (sca_uri_is_shared_appearance(scam, aor)) {
+	if(sca_uri_is_shared_appearance(scam, aor)) {
 		// we've already registered
 		rc = 0;
 		goto done;
 	}
 
 	app_list = sca_appearance_list_create(scam, aor);
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		goto done;
 	}
 
-	if (sca_hash_table_kv_insert(scam->appearances, aor, app_list,
-			sca_appearance_list_aor_cmp, sca_appearance_list_print,
-			sca_appearance_list_free) < 0) {
+	if(sca_hash_table_kv_insert(scam->appearances, aor, app_list,
+			   sca_appearance_list_aor_cmp, sca_appearance_list_print,
+			   sca_appearance_list_free)
+			< 0) {
 		LM_ERR("sca_appearance_register: failed to insert appearance list "
-				"for %.*s\n", STR_FMT(aor));
+			   "for %.*s\n",
+				STR_FMT(aor));
 		goto done;
 	}
 
 	rc = 1;
 
-	done: return (rc);
+done:
+	return (rc);
 }
 
 int sca_appearance_unregister(sca_mod *scam, str *aor)
@@ -355,8 +361,8 @@ int sca_appearance_unregister(sca_mod *scam, str *aor)
 	assert(scam != NULL);
 	assert(aor != NULL);
 
-	if (sca_uri_is_shared_appearance(scam, aor)) {
-		if ((rc = sca_hash_table_kv_delete(scam->appearances, aor)) == 0) {
+	if(sca_uri_is_shared_appearance(scam, aor)) {
+		if((rc = sca_hash_table_kv_delete(scam->appearances, aor)) == 0) {
 			rc = 1;
 			LM_INFO("unregistered SCA AoR %.*s\n", STR_FMT(aor));
 		}
@@ -376,22 +382,23 @@ sca_appearance *sca_appearance_seize_index_unsafe(sca_mod *scam, str *aor,
 	slot = sca_hash_table_slot_for_index(scam->appearances, slot_idx);
 
 	app_list = sca_hash_table_slot_kv_find_unsafe(slot, aor);
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		LM_ERR("sca_appearance_seize_index_unsafe: no appearance list for "
-				"%.*s\n", STR_FMT(aor));
+			   "%.*s\n",
+				STR_FMT(aor));
 		goto done;
 	}
 
-	if (app_idx <= 0) {
+	if(app_idx <= 0) {
 		app_idx = sca_appearance_list_next_available_index_unsafe(app_list);
 	}
 
-	for (app = app_list->appearances; app != NULL; app = app->next) {
-		if (app->index >= app_idx) {
+	for(app = app_list->appearances; app != NULL; app = app->next) {
+		if(app->index >= app_idx) {
 			break;
 		}
 	}
-	if (app != NULL && app->index == app_idx) {
+	if(app != NULL && app->index == app_idx) {
 		// attempt to seize in-use appearance-index
 		error = SCA_APPEARANCE_ERR_INDEX_UNAVAILABLE;
 		app = NULL;
@@ -399,7 +406,7 @@ sca_appearance *sca_appearance_seize_index_unsafe(sca_mod *scam, str *aor,
 	}
 
 	app = sca_appearance_create(app_idx, owner_uri);
-	if (app == NULL) {
+	if(app == NULL) {
 		LM_ERR("Failed to create new appearance for %.*s at index %d\n",
 				STR_FMT(owner_uri), app_idx);
 		error = SCA_APPEARANCE_ERR_MALLOC;
@@ -409,14 +416,16 @@ sca_appearance *sca_appearance_seize_index_unsafe(sca_mod *scam, str *aor,
 	sca_appearance_list_insert_appearance(app_list, app);
 	error = SCA_APPEARANCE_OK;
 
-	done: if (seize_error) {
+done:
+	if(seize_error) {
 		*seize_error = error;
 	}
 
 	return (app);
 }
 
-int sca_appearance_seize_index(sca_mod *scam, str *aor, int idx, str *owner_uri) {
+int sca_appearance_seize_index(sca_mod *scam, str *aor, int idx, str *owner_uri)
+{
 	sca_appearance *app;
 	int slot_idx;
 	int app_idx = -1;
@@ -425,23 +434,23 @@ int sca_appearance_seize_index(sca_mod *scam, str *aor, int idx, str *owner_uri)
 	slot_idx = sca_hash_table_index_for_key(scam->appearances, aor);
 	sca_hash_table_lock_index(scam->appearances, slot_idx);
 
-	app = sca_appearance_seize_index_unsafe(scam, aor, owner_uri, idx, slot_idx,
-			&error);
-	if (app != NULL) {
+	app = sca_appearance_seize_index_unsafe(
+			scam, aor, owner_uri, idx, slot_idx, &error);
+	if(app != NULL) {
 		app_idx = app->index;
 	}
 
 	sca_hash_table_unlock_index(scam->appearances, slot_idx);
 
-	if (error == SCA_APPEARANCE_ERR_INDEX_UNAVAILABLE) {
+	if(error == SCA_APPEARANCE_ERR_INDEX_UNAVAILABLE) {
 		app_idx = SCA_APPEARANCE_INDEX_UNAVAILABLE;
 	}
 
 	return (app_idx);
 }
 
-sca_appearance *sca_appearance_seize_next_available_unsafe(sca_mod *scam,
-		str *aor, str *owner_uri, int slot_idx)
+sca_appearance *sca_appearance_seize_next_available_unsafe(
+		sca_mod *scam, str *aor, str *owner_uri, int slot_idx)
 {
 	sca_appearance_list *app_list;
 	sca_appearance *app = NULL;
@@ -451,17 +460,17 @@ sca_appearance *sca_appearance_seize_next_available_unsafe(sca_mod *scam,
 	slot = sca_hash_table_slot_for_index(scam->appearances, slot_idx);
 
 	app_list = sca_hash_table_slot_kv_find_unsafe(slot, aor);
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		app_list = sca_appearance_list_create(scam, aor);
-		if (app_list == NULL) {
+		if(app_list == NULL) {
 			goto done;
 		}
 
-		if (sca_hash_table_slot_kv_insert_unsafe(slot, app_list,
-				sca_appearance_list_aor_cmp, sca_appearance_list_print,
-				sca_appearance_list_free) < 0) {
-			LM_ERR("Failed to insert appearance list for %.*s\n",
-					STR_FMT(aor));
+		if(sca_hash_table_slot_kv_insert_unsafe(slot, app_list,
+				   sca_appearance_list_aor_cmp, sca_appearance_list_print,
+				   sca_appearance_list_free)
+				< 0) {
+			LM_ERR("Failed to insert appearance list for %.*s\n", STR_FMT(aor));
 			goto done;
 		}
 	}
@@ -471,7 +480,7 @@ sca_appearance *sca_appearance_seize_next_available_unsafe(sca_mod *scam,
 	// XXX check idx > any configured max appearance index
 
 	app = sca_appearance_create(idx, owner_uri);
-	if (app == NULL) {
+	if(app == NULL) {
 		LM_ERR("Failed to create new appearance for %.*s at index %d\n",
 				STR_FMT(owner_uri), idx);
 		goto done;
@@ -480,11 +489,12 @@ sca_appearance *sca_appearance_seize_next_available_unsafe(sca_mod *scam,
 
 	sca_appearance_list_insert_appearance(app_list, app);
 
-	done: return (app);
+done:
+	return (app);
 }
 
-int sca_appearance_seize_next_available_index(sca_mod *scam, str *aor,
-		str *owner_uri)
+int sca_appearance_seize_next_available_index(
+		sca_mod *scam, str *aor, str *owner_uri)
 {
 	sca_appearance *app;
 	int slot_idx;
@@ -493,9 +503,9 @@ int sca_appearance_seize_next_available_index(sca_mod *scam, str *aor,
 	slot_idx = sca_hash_table_index_for_key(scam->appearances, aor);
 	sca_hash_table_lock_index(scam->appearances, slot_idx);
 
-	app = sca_appearance_seize_next_available_unsafe(scam, aor, owner_uri,
-			slot_idx);
-	if (app != NULL) {
+	app = sca_appearance_seize_next_available_unsafe(
+			scam, aor, owner_uri, slot_idx);
+	if(app != NULL) {
 		idx = app->index;
 	}
 
@@ -517,25 +527,26 @@ int sca_appearance_update_owner_unsafe(sca_appearance *app, str *owner)
 	assert(app != NULL);
 	assert(owner != NULL);
 
-	if (!SCA_STR_EMPTY(&app->owner)) {
-		if (app->prev_owner.s != NULL) {
+	if(!SCA_STR_EMPTY(&app->owner)) {
+		if(app->prev_owner.s != NULL) {
 			shm_free(app->prev_owner.s);
 		}
 		app->prev_owner.s = app->owner.s;
 		app->prev_owner.len = app->owner.len;
 	}
 
-	app->owner.s = (char *) shm_malloc(owner->len);
-	if (app->owner.s == NULL) {
+	app->owner.s = (char *)shm_malloc(owner->len);
+	if(app->owner.s == NULL) {
 		LM_ERR("sca_appearance_update_owner_unsafe: shm_malloc for new "
-				"owner %.*s failed: out of memory\n", STR_FMT(owner));
+			   "owner %.*s failed: out of memory\n",
+				STR_FMT(owner));
 		goto error;
 	}
 	SCA_STR_COPY(&app->owner, owner);
 
 	return (1);
 
-	error:
+error:
 	// restore owner
 	app->owner.s = app->prev_owner.s;
 	app->owner.len = app->prev_owner.len;
@@ -549,25 +560,26 @@ int sca_appearance_update_callee_unsafe(sca_appearance *app, str *callee)
 	assert(app != NULL);
 	assert(callee != NULL);
 
-	if (!SCA_STR_EMPTY(&app->callee)) {
-		if (app->prev_callee.s != NULL) {
+	if(!SCA_STR_EMPTY(&app->callee)) {
+		if(app->prev_callee.s != NULL) {
 			shm_free(app->prev_callee.s);
 		}
 		app->prev_callee.s = app->callee.s;
 		app->prev_callee.len = app->callee.len;
 	}
 
-	app->callee.s = (char *) shm_malloc(callee->len);
-	if (app->callee.s == NULL) {
+	app->callee.s = (char *)shm_malloc(callee->len);
+	if(app->callee.s == NULL) {
 		LM_ERR("sca_appearance_update_owner_unsafe: shm_malloc for new "
-				"callee %.*s failed: out of memory\n", STR_FMT(callee));
+			   "callee %.*s failed: out of memory\n",
+				STR_FMT(callee));
 		goto error;
 	}
 	SCA_STR_COPY(&app->callee, callee);
 
 	return (1);
 
-	error:
+error:
 	// restore callee
 	app->callee.s = app->prev_callee.s;
 	app->callee.len = app->prev_callee.len;
@@ -575,8 +587,8 @@ int sca_appearance_update_callee_unsafe(sca_appearance *app, str *callee)
 
 	return (-1);
 }
-int sca_appearance_update_dialog_unsafe(sca_appearance *app, str *call_id,
-		str *from_tag, str *to_tag)
+int sca_appearance_update_dialog_unsafe(
+		sca_appearance *app, str *call_id, str *from_tag, str *to_tag)
 {
 	int len;
 
@@ -584,8 +596,8 @@ int sca_appearance_update_dialog_unsafe(sca_appearance *app, str *call_id,
 	assert(call_id != NULL);
 	assert(from_tag != NULL);
 
-	if (!SCA_STR_EMPTY(&app->dialog.id)) {
-		if (app->prev_dialog.id.s != NULL) {
+	if(!SCA_STR_EMPTY(&app->dialog.id)) {
+		if(app->prev_dialog.id.s != NULL) {
 			shm_free(app->prev_dialog.id.s);
 		}
 		app->prev_dialog.id.s = app->dialog.id.s;
@@ -602,14 +614,14 @@ int sca_appearance_update_dialog_unsafe(sca_appearance *app, str *call_id,
 	}
 
 	len = call_id->len + from_tag->len;
-	if (!SCA_STR_EMPTY(to_tag)) {
+	if(!SCA_STR_EMPTY(to_tag)) {
 		len += to_tag->len;
 	}
 
-	app->dialog.id.s = (char *) shm_malloc(len);
-	if (app->dialog.id.s == NULL) {
+	app->dialog.id.s = (char *)shm_malloc(len);
+	if(app->dialog.id.s == NULL) {
 		LM_ERR("sca_appearance_update_dialog_unsafe: shm_malloc new dialog "
-				"failed: out of memory\n");
+			   "failed: out of memory\n");
 		goto error;
 	}
 	SCA_STR_COPY(&app->dialog.id, call_id);
@@ -626,7 +638,7 @@ int sca_appearance_update_dialog_unsafe(sca_appearance *app, str *call_id,
 
 	return (1);
 
-	error:
+error:
 	// restore dialog
 	app->prev_dialog.id.s = app->dialog.id.s;
 	app->prev_dialog.id.len = app->dialog.id.len;
@@ -651,12 +663,12 @@ int sca_appearance_update_unsafe(sca_appearance *app, int state, str *display,
 	int rc = SCA_APPEARANCE_OK;
 	int len;
 
-	if (state != SCA_APPEARANCE_STATE_UNKNOWN) {
+	if(state != SCA_APPEARANCE_STATE_UNKNOWN) {
 		sca_appearance_update_state_unsafe(app, state);
 	}
 
-	if (!SCA_STR_EMPTY(uri)) {
-		if (!SCA_STR_EMPTY(&app->uri)) {
+	if(!SCA_STR_EMPTY(uri)) {
+		if(!SCA_STR_EMPTY(&app->uri)) {
 			// the uri str's s member is shm_malloc'd separately
 			shm_free(app->uri.s);
 			memset(&app->uri, 0, sizeof(str));
@@ -664,20 +676,20 @@ int sca_appearance_update_unsafe(sca_appearance *app, int state, str *display,
 
 		// +2 for left & right carets surrounding URI
 		len = uri->len + 2;
-		if (!SCA_STR_EMPTY(display)) {
+		if(!SCA_STR_EMPTY(display)) {
 			// cheaper to scan string than shm_malloc 2x display?
 			len += sca_uri_display_escapes_count(display);
 			// +1 for space between display & uri
 			len += display->len + 1;
 		}
-		app->uri.s = (char *) shm_malloc(len);
-		if (app->uri.s == NULL) {
+		app->uri.s = (char *)shm_malloc(len);
+		if(app->uri.s == NULL) {
 			LM_ERR("shm_malloc %d bytes returned NULL\n", uri->len);
 			rc = SCA_APPEARANCE_ERR_MALLOC;
 			goto done;
 		}
 
-		if (!SCA_STR_EMPTY(display)) {
+		if(!SCA_STR_EMPTY(display)) {
 			// copy escaped display information...
 			app->uri.len = escape_common(app->uri.s, display->s, display->len);
 
@@ -695,16 +707,16 @@ int sca_appearance_update_unsafe(sca_appearance *app, int state, str *display,
 		app->uri.len++;
 	}
 
-	if (!SCA_DIALOG_EMPTY(dialog)) {
-		if (!SCA_STR_EQ(&dialog->id, &app->dialog.id)) {
-			if (app->dialog.id.s != NULL) {
+	if(!SCA_DIALOG_EMPTY(dialog)) {
+		if(!SCA_STR_EQ(&dialog->id, &app->dialog.id)) {
+			if(app->dialog.id.s != NULL) {
 				shm_free(app->dialog.id.s);
 			}
 
-			app->dialog.id.s = (char *) shm_malloc(dialog->id.len);
-			if (app->dialog.id.s == NULL) {
+			app->dialog.id.s = (char *)shm_malloc(dialog->id.len);
+			if(app->dialog.id.s == NULL) {
 				LM_ERR("sca_appearance_update_unsafe: shm_malloc dialog id "
-						"failed: out of shared memory\n");
+					   "failed: out of shared memory\n");
 				// XXX this seems bad enough to abort...
 				return (-1);
 			}
@@ -716,9 +728,9 @@ int sca_appearance_update_unsafe(sca_appearance *app, int state, str *display,
 			app->dialog.from_tag.s = app->dialog.id.s + dialog->call_id.len;
 			app->dialog.from_tag.len = dialog->from_tag.len;
 
-			if (!SCA_STR_EMPTY(&dialog->to_tag)) {
+			if(!SCA_STR_EMPTY(&dialog->to_tag)) {
 				app->dialog.to_tag.s = app->dialog.id.s + dialog->call_id.len
-						+ dialog->from_tag.len;
+									   + dialog->from_tag.len;
 				app->dialog.to_tag.len = dialog->to_tag.len;
 			} else {
 				app->dialog.to_tag.s = NULL;
@@ -728,39 +740,40 @@ int sca_appearance_update_unsafe(sca_appearance *app, int state, str *display,
 	}
 
 	// NOTE these two blocks could be condensed and inlined
-	if (!SCA_STR_EMPTY(owner)) {
-		if (!SCA_STR_EQ(&app->owner, owner)) {
-			if (app->owner.s != NULL) {
+	if(!SCA_STR_EMPTY(owner)) {
+		if(!SCA_STR_EQ(&app->owner, owner)) {
+			if(app->owner.s != NULL) {
 				shm_free(app->owner.s);
 			}
 
-			app->owner.s = (char *) shm_malloc(owner->len);
-			if (app->owner.s == NULL) {
+			app->owner.s = (char *)shm_malloc(owner->len);
+			if(app->owner.s == NULL) {
 				LM_ERR("sca_appearance_update_unsafe: shm_malloc "
-						"appearance owner URI failed: out of shared memory\n");
+					   "appearance owner URI failed: out of shared memory\n");
 				return (-1);
 			}
 			SCA_STR_COPY(&app->owner, owner);
 		}
 	}
 
-	if (!SCA_STR_EMPTY(callee)) {
-		if (!SCA_STR_EQ(&app->callee, callee)) {
-			if (app->callee.s != NULL) {
+	if(!SCA_STR_EMPTY(callee)) {
+		if(!SCA_STR_EQ(&app->callee, callee)) {
+			if(app->callee.s != NULL) {
 				shm_free(app->callee.s);
 			}
 
-			app->callee.s = (char *) shm_malloc(callee->len);
-			if (app->callee.s == NULL) {
+			app->callee.s = (char *)shm_malloc(callee->len);
+			if(app->callee.s == NULL) {
 				LM_ERR("sca_appearance_update_unsafe: shm_malloc "
-						"appearance callee URI failed: out of shared memory\n");
+					   "appearance callee URI failed: out of shared memory\n");
 				return (-1);
 			}
 			SCA_STR_COPY(&app->callee, callee);
 		}
 	}
 
-	done: return (rc);
+done:
+	return (rc);
 }
 
 int sca_uri_is_shared_appearance(sca_mod *scam, str *aor)
@@ -776,7 +789,7 @@ int sca_uri_is_shared_appearance(sca_mod *scam, str *aor)
 	app_list = sca_hash_table_slot_kv_find_unsafe(slot, aor);
 	sca_hash_table_unlock_index(scam->appearances, slot_idx);
 
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		return (0);
 	}
 
@@ -789,7 +802,7 @@ int sca_uri_lock_shared_appearance(sca_mod *scam, str *aor)
 	sca_appearance_list *app_list;
 	int slot_idx;
 
-	if (SCA_STR_EMPTY(aor)) {
+	if(SCA_STR_EMPTY(aor)) {
 		return (-1);
 	}
 
@@ -799,7 +812,7 @@ int sca_uri_lock_shared_appearance(sca_mod *scam, str *aor)
 	sca_hash_table_lock_index(scam->appearances, slot_idx);
 	app_list = sca_hash_table_slot_kv_find_unsafe(slot, aor);
 
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		sca_hash_table_unlock_index(scam->appearances, slot_idx);
 		slot_idx = -1;
 	}
@@ -814,7 +827,7 @@ int sca_uri_lock_if_shared_appearance(sca_mod *scam, str *aor, int *slot_idx)
 
 	assert(slot_idx != NULL);
 
-	if (SCA_STR_EMPTY(aor)) {
+	if(SCA_STR_EMPTY(aor)) {
 		*slot_idx = -1;
 		return (0);
 	}
@@ -825,7 +838,7 @@ int sca_uri_lock_if_shared_appearance(sca_mod *scam, str *aor, int *slot_idx)
 	sca_hash_table_lock_index(scam->appearances, *slot_idx);
 	app_list = sca_hash_table_slot_kv_find_unsafe(slot, aor);
 
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		sca_hash_table_unlock_index(scam->appearances, *slot_idx);
 		*slot_idx = -1;
 
@@ -849,25 +862,24 @@ int sca_appearance_state_for_index(sca_mod *scam, str *aor, int idx)
 	sca_hash_table_lock_index(scam->appearances, slot_idx);
 
 	app_list = sca_hash_table_slot_kv_find_unsafe(slot, aor);
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		LM_DBG("%.*s has no in-use appearances\n", STR_FMT(aor));
 		goto done;
 	}
 
-	for (app = app_list->appearances; app != NULL; app = app->next) {
-		if (app->index == idx) {
+	for(app = app_list->appearances; app != NULL; app = app->next) {
+		if(app->index == idx) {
 			break;
 		}
 	}
-	if (app == NULL) {
-		LM_WARN("%.*s appearance-index %d is not in use\n",
-				STR_FMT(aor), idx);
+	if(app == NULL) {
+		LM_WARN("%.*s appearance-index %d is not in use\n", STR_FMT(aor), idx);
 		goto done;
 	}
 
 	state = app->state;
 
-	done:
+done:
 	sca_hash_table_unlock_index(scam->appearances, slot_idx);
 
 	return (state);
@@ -892,36 +904,36 @@ int sca_appearance_update_index(sca_mod *scam, str *aor, int idx, int state,
 	sca_appearance_state_to_str(state, &state_str);
 
 	app_list = sca_hash_table_slot_kv_find_unsafe(slot, aor);
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		LM_WARN("Cannot update %.*s index %d to state %.*s: %.*s has no "
-				"in-use appearances\n", STR_FMT(aor), idx,
-				STR_FMT(&state_str), STR_FMT(aor));
+				"in-use appearances\n",
+				STR_FMT(aor), idx, STR_FMT(&state_str), STR_FMT(aor));
 		rc = SCA_APPEARANCE_ERR_NOT_IN_USE;
 		goto done;
 	}
 
-	for (app = app_list->appearances; app != NULL; app = app->next) {
-		if (app->index == idx) {
+	for(app = app_list->appearances; app != NULL; app = app->next) {
+		if(app->index == idx) {
 			break;
-		} else if (idx == 0) {
-			if (SCA_STR_EQ(&dialog->id, &app->dialog.id)) {
+		} else if(idx == 0) {
+			if(SCA_STR_EQ(&dialog->id, &app->dialog.id)) {
 				break;
 			}
 		}
 	}
-	if (app == NULL) {
+	if(app == NULL) {
 		LM_WARN("Cannot update %.*s index %d to %.*s: index %d not in use\n",
 				STR_FMT(aor), idx, STR_FMT(&state_str), idx);
 		rc = SCA_APPEARANCE_ERR_INDEX_INVALID;
 		goto done;
 	}
 
-	if (state != SCA_APPEARANCE_STATE_UNKNOWN && app->state != state) {
+	if(state != SCA_APPEARANCE_STATE_UNKNOWN && app->state != state) {
 		sca_appearance_update_state_unsafe(app, state);
 	}
 
-	if (!SCA_STR_EMPTY(uri)) {
-		if (!SCA_STR_EMPTY(&app->uri)) {
+	if(!SCA_STR_EMPTY(uri)) {
+		if(!SCA_STR_EMPTY(&app->uri)) {
 			// the uri str's s member is shm_malloc'd separately
 			shm_free(app->uri.s);
 			memset(&app->uri, 0, sizeof(str));
@@ -929,22 +941,22 @@ int sca_appearance_update_index(sca_mod *scam, str *aor, int idx, int state,
 
 		// +2 for left & right carets surrounding URI
 		len = uri->len + 2;
-		if (!SCA_STR_EMPTY(display)) {
+		if(!SCA_STR_EMPTY(display)) {
 			// cheaper to scan string than shm_malloc 2x display?
 			len += sca_uri_display_escapes_count(display);
 			// +1 for space between display & uri
 			len += display->len + 1;
 		}
-		app->uri.s = (char *) shm_malloc(len);
-		if (app->uri.s == NULL) {
+		app->uri.s = (char *)shm_malloc(len);
+		if(app->uri.s == NULL) {
 			LM_ERR("Failed to update %.*s index %d uri to %.*s: "
-					"shm_malloc %d bytes returned NULL\n",
+				   "shm_malloc %d bytes returned NULL\n",
 					STR_FMT(aor), idx, STR_FMT(uri), uri->len);
 			rc = SCA_APPEARANCE_ERR_MALLOC;
 			goto done;
 		}
 
-		if (!SCA_STR_EMPTY(display)) {
+		if(!SCA_STR_EMPTY(display)) {
 			// copy escaped display information...
 			app->uri.len = escape_common(app->uri.s, display->s, display->len);
 
@@ -962,13 +974,13 @@ int sca_appearance_update_index(sca_mod *scam, str *aor, int idx, int state,
 		app->uri.len++;
 	}
 
-	if (!SCA_DIALOG_EMPTY(dialog)) {
-		if (!SCA_STR_EQ(&dialog->id, &app->dialog.id)) {
-			if (app->dialog.id.s != NULL) {
+	if(!SCA_DIALOG_EMPTY(dialog)) {
+		if(!SCA_STR_EQ(&dialog->id, &app->dialog.id)) {
+			if(app->dialog.id.s != NULL) {
 				shm_free(app->dialog.id.s);
 			}
 
-			app->dialog.id.s = (char *) shm_malloc(dialog->id.len);
+			app->dialog.id.s = (char *)shm_malloc(dialog->id.len);
 			SCA_STR_COPY(&app->dialog.id, &dialog->id);
 
 			app->dialog.call_id.s = app->dialog.id.s;
@@ -977,9 +989,9 @@ int sca_appearance_update_index(sca_mod *scam, str *aor, int idx, int state,
 			app->dialog.from_tag.s = app->dialog.id.s + dialog->call_id.len;
 			app->dialog.from_tag.len = dialog->from_tag.len;
 
-			if (!SCA_STR_EMPTY(&dialog->to_tag)) {
+			if(!SCA_STR_EMPTY(&dialog->to_tag)) {
 				app->dialog.to_tag.s = app->dialog.id.s + dialog->call_id.len
-						+ dialog->from_tag.len;
+									   + dialog->from_tag.len;
 				app->dialog.to_tag.len = dialog->to_tag.len;
 			} else {
 				app->dialog.to_tag.s = NULL;
@@ -990,7 +1002,7 @@ int sca_appearance_update_index(sca_mod *scam, str *aor, int idx, int state,
 
 	rc = SCA_APPEARANCE_OK;
 
-	done:
+done:
 	sca_hash_table_unlock_index(scam->appearances, slot_idx);
 
 	return (rc);
@@ -1011,20 +1023,20 @@ int sca_appearance_release_index(sca_mod *scam, str *aor, int idx)
 	sca_hash_table_lock_index(scam->appearances, slot_idx);
 
 	app_list = NULL;
-	for (ent = slot->entries; ent != NULL; ent = ent->next) {
-		if (ent->compare(aor, ent->value) == 0) {
-			app_list = (sca_appearance_list *) ent->value;
+	for(ent = slot->entries; ent != NULL; ent = ent->next) {
+		if(ent->compare(aor, ent->value) == 0) {
+			app_list = (sca_appearance_list *)ent->value;
 			break;
 		}
 	}
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		LM_ERR("No appearances for %.*s\n", STR_FMT(aor));
 		rc = SCA_APPEARANCE_ERR_NOT_IN_USE;
 		goto done;
 	}
 
 	app = sca_appearance_list_unlink_index(app_list, idx);
-	if (app == NULL) {
+	if(app == NULL) {
 		LM_ERR("Failed to unlink %.*s appearance-index %d: invalid index\n",
 				STR_FMT(aor), idx);
 		rc = SCA_APPEARANCE_ERR_INDEX_INVALID;
@@ -1034,13 +1046,14 @@ int sca_appearance_release_index(sca_mod *scam, str *aor, int idx)
 
 	rc = SCA_APPEARANCE_OK;
 
-	done:
+done:
 	sca_hash_table_unlock_index(scam->appearances, slot_idx);
 
 	return (rc);
 }
 
-int sca_appearance_owner_release_all(str *aor, str *owner) {
+int sca_appearance_owner_release_all(str *aor, str *owner)
+{
 	sca_appearance_list *app_list = NULL;
 	sca_appearance *app, **cur_app, **tmp_app;
 	sca_hash_slot *slot;
@@ -1051,26 +1064,25 @@ int sca_appearance_owner_release_all(str *aor, str *owner) {
 	slot_idx = sca_uri_lock_shared_appearance(sca, aor);
 	slot = sca_hash_table_slot_for_index(sca->appearances, slot_idx);
 
-	for (ent = slot->entries; ent != NULL; ent = ent->next) {
-		if (ent->compare(aor, ent->value) == 0) {
-			app_list = (sca_appearance_list *) ent->value;
+	for(ent = slot->entries; ent != NULL; ent = ent->next) {
+		if(ent->compare(aor, ent->value) == 0) {
+			app_list = (sca_appearance_list *)ent->value;
 			break;
 		}
 	}
 
 	released = 0;
 
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		LM_DBG("sca_appearance_owner_release_all: No appearances for %.*s\n",
 				STR_FMT(aor));
 		goto done;
 	}
 
-	for (cur_app = &app_list->appearances; *cur_app != NULL; cur_app =
-			tmp_app) {
+	for(cur_app = &app_list->appearances; *cur_app != NULL; cur_app = tmp_app) {
 		tmp_app = &(*cur_app)->next;
 
-		if (!SCA_STR_EQ(owner, &(*cur_app)->owner)) {
+		if(!SCA_STR_EQ(owner, &(*cur_app)->owner)) {
 			continue;
 		}
 
@@ -1078,21 +1090,22 @@ int sca_appearance_owner_release_all(str *aor, str *owner) {
 		*cur_app = (*cur_app)->next;
 		tmp_app = cur_app;
 
-		if (app) {
+		if(app) {
 			sca_appearance_free(app);
 			released++;
 		}
 	}
 
-	done: if (slot_idx >= 0) {
+done:
+	if(slot_idx >= 0) {
 		sca_hash_table_unlock_index(sca->appearances, slot_idx);
 	}
 
 	return (released);
 }
 
-sca_appearance *sca_appearance_for_index_unsafe(sca_mod *scam, str *aor,
-		int app_idx, int slot_idx)
+sca_appearance *sca_appearance_for_index_unsafe(
+		sca_mod *scam, str *aor, int app_idx, int slot_idx)
 {
 	sca_appearance_list *app_list;
 	sca_appearance *app = NULL;
@@ -1102,19 +1115,19 @@ sca_appearance *sca_appearance_for_index_unsafe(sca_mod *scam, str *aor,
 	slot = sca_hash_table_slot_for_index(scam->appearances, slot_idx);
 
 	app_list = NULL;
-	for (ent = slot->entries; ent != NULL; ent = ent->next) {
-		if (ent->compare(aor, ent->value) == 0) {
-			app_list = (sca_appearance_list *) ent->value;
+	for(ent = slot->entries; ent != NULL; ent = ent->next) {
+		if(ent->compare(aor, ent->value) == 0) {
+			app_list = (sca_appearance_list *)ent->value;
 			break;
 		}
 	}
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		LM_ERR("No appearances for %.*s\n", STR_FMT(aor));
 		return (NULL);
 	}
 
-	for (app = app_list->appearances; app != NULL; app = app->next) {
-		if (app->index == app_idx) {
+	for(app = app_list->appearances; app != NULL; app = app->next) {
+		if(app->index == app_idx) {
 			break;
 		}
 	}
@@ -1122,8 +1135,8 @@ sca_appearance *sca_appearance_for_index_unsafe(sca_mod *scam, str *aor,
 	return (app);
 }
 
-sca_appearance *sca_appearance_for_dialog_unsafe(sca_mod *scam, str *aor,
-		sca_dialog *dialog, int slot_idx)
+sca_appearance *sca_appearance_for_dialog_unsafe(
+		sca_mod *scam, str *aor, sca_dialog *dialog, int slot_idx)
 {
 	sca_appearance_list *app_list;
 	sca_appearance *app = NULL;
@@ -1133,24 +1146,24 @@ sca_appearance *sca_appearance_for_dialog_unsafe(sca_mod *scam, str *aor,
 	slot = sca_hash_table_slot_for_index(scam->appearances, slot_idx);
 
 	app_list = NULL;
-	for (ent = slot->entries; ent != NULL; ent = ent->next) {
-		if (ent->compare(aor, ent->value) == 0) {
-			app_list = (sca_appearance_list *) ent->value;
+	for(ent = slot->entries; ent != NULL; ent = ent->next) {
+		if(ent->compare(aor, ent->value) == 0) {
+			app_list = (sca_appearance_list *)ent->value;
 			break;
 		}
 	}
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		LM_ERR("No appearances for %.*s\n", STR_FMT(aor));
 		return (NULL);
 	}
 
-	for (app = app_list->appearances; app != NULL; app = app->next) {
-		if (SCA_STR_EQ(&app->dialog.call_id, &dialog->call_id) &&
-		SCA_STR_EQ(&app->dialog.from_tag, &dialog->from_tag)) {
+	for(app = app_list->appearances; app != NULL; app = app->next) {
+		if(SCA_STR_EQ(&app->dialog.call_id, &dialog->call_id)
+				&& SCA_STR_EQ(&app->dialog.from_tag, &dialog->from_tag)) {
 #ifdef notdef
-			if (!SCA_STR_EMPTY(&app->dialog.to_tag) &&
-					!SCA_STR_EMPTY(&dialog->to_tag) &&
-					!SCA_STR_EQ(&app->dialog.to_tag, &dialog->to_tag)) {
+			if(!SCA_STR_EMPTY(&app->dialog.to_tag)
+					&& !SCA_STR_EMPTY(&dialog->to_tag)
+					&& !SCA_STR_EQ(&app->dialog.to_tag, &dialog->to_tag)) {
 				continue;
 			}
 #endif // notdef
@@ -1168,18 +1181,19 @@ sca_appearance *sca_appearance_for_tags_unsafe(sca_mod *scam, str *aor,
 	char dlg_buf[1024];
 
 	dialog.id.s = dlg_buf;
-	if (sca_dialog_build_from_tags(&dialog, sizeof(dlg_buf), call_id, from_tag,
-			to_tag) < 0) {
+	if(sca_dialog_build_from_tags(
+			   &dialog, sizeof(dlg_buf), call_id, from_tag, to_tag)
+			< 0) {
 		LM_ERR("sca_appearance_for_tags_unsafe: failed to build dialog "
-				"from tags\n");
+			   "from tags\n");
 		return (NULL);
 	}
 
 	return (sca_appearance_for_dialog_unsafe(scam, aor, &dialog, slot_idx));
 }
 
-sca_appearance *sca_appearance_unlink_by_tags(sca_mod *scam, str *aor,
-		str *call_id, str *from_tag, str *to_tag)
+sca_appearance *sca_appearance_unlink_by_tags(
+		sca_mod *scam, str *aor, str *call_id, str *from_tag, str *to_tag)
 {
 	sca_appearance *app = NULL, *unl_app;
 	int slot_idx = -1;
@@ -1187,25 +1201,28 @@ sca_appearance *sca_appearance_unlink_by_tags(sca_mod *scam, str *aor,
 	slot_idx = sca_hash_table_index_for_key(scam->appearances, aor);
 	sca_hash_table_lock_index(scam->appearances, slot_idx);
 
-	app = sca_appearance_for_tags_unsafe(scam, aor, call_id, from_tag, to_tag,
-			slot_idx);
-	if (app == NULL) {
+	app = sca_appearance_for_tags_unsafe(
+			scam, aor, call_id, from_tag, to_tag, slot_idx);
+	if(app == NULL) {
 		LM_ERR("sca_appearance_unlink_by_tags: no appearances found for %.*s "
-				"with dialog %.*s;%.*s;%.*s\n", STR_FMT(aor),
-				STR_FMT(call_id), STR_FMT(from_tag), STR_FMT(to_tag));
+			   "with dialog %.*s;%.*s;%.*s\n",
+				STR_FMT(aor), STR_FMT(call_id), STR_FMT(from_tag),
+				STR_FMT(to_tag));
 		goto done;
 	}
 
-	unl_app = sca_appearance_list_unlink_index(app->appearance_list,
-			app->index);
-	if (unl_app == NULL || unl_app != app) {
+	unl_app =
+			sca_appearance_list_unlink_index(app->appearance_list, app->index);
+	if(unl_app == NULL || unl_app != app) {
 		LM_ERR("sca_appearance_unlink_by_tags: failed to unlink %.*s "
-				"appearance-index %d\n", STR_FMT(aor), app->index);
+			   "appearance-index %d\n",
+				STR_FMT(aor), app->index);
 		app = NULL;
 		goto done;
 	}
 
-	done: if (slot_idx >= 0) {
+done:
+	if(slot_idx >= 0) {
 		sca_hash_table_unlock_index(scam->appearances, slot_idx);
 	}
 
@@ -1214,12 +1231,13 @@ sca_appearance *sca_appearance_unlink_by_tags(sca_mod *scam, str *aor,
 
 void sca_appearance_purge_stale(unsigned int ticks, void *param)
 {
-	struct notify_list {
+	struct notify_list
+	{
 		struct notify_list *next;
 		str aor;
 	};
 
-	sca_mod *scam = (sca_mod *) param;
+	sca_mod *scam = (sca_mod *)param;
 	sca_hash_table *ht;
 	sca_hash_entry *ent;
 	sca_appearance_list *app_list;
@@ -1237,36 +1255,36 @@ void sca_appearance_purge_stale(unsigned int ticks, void *param)
 	now = time(NULL);
 
 	ht = scam->appearances;
-	for (i = 0; i < ht->size; i++) {
+	for(i = 0; i < ht->size; i++) {
 		sca_hash_table_lock_index(ht, i);
 
-		for (ent = ht->slots[i].entries; ent != NULL; ent = ent->next) {
-			app_list = (sca_appearance_list *) ent->value;
-			if (app_list == NULL) {
+		for(ent = ht->slots[i].entries; ent != NULL; ent = ent->next) {
+			app_list = (sca_appearance_list *)ent->value;
+			if(app_list == NULL) {
 				continue;
 			}
 
 			unlinked = 0;
 
-			for (cur_app = &app_list->appearances; *cur_app != NULL; cur_app =
-					tmp_app) {
+			for(cur_app = &app_list->appearances; *cur_app != NULL;
+					cur_app = tmp_app) {
 				tmp_app = &(*cur_app)->next;
 
-				switch ((*cur_app)->state) {
-				case SCA_APPEARANCE_STATE_ACTIVE_PENDING:
-					ttl = SCA_APPEARANCE_STATE_PENDING_TTL;
-					break;
+				switch((*cur_app)->state) {
+					case SCA_APPEARANCE_STATE_ACTIVE_PENDING:
+						ttl = SCA_APPEARANCE_STATE_PENDING_TTL;
+						break;
 
-				case SCA_APPEARANCE_STATE_SEIZED:
-					ttl = SCA_APPEARANCE_STATE_SEIZED_TTL;
-					break;
+					case SCA_APPEARANCE_STATE_SEIZED:
+						ttl = SCA_APPEARANCE_STATE_SEIZED_TTL;
+						break;
 
-				default:
-					// XXX for now just skip other appearances
-					ttl = now + 60;
-					break;
+					default:
+						// XXX for now just skip other appearances
+						ttl = now + 60;
+						break;
 				}
-				if ((now - (*cur_app)->times.mtime) < ttl) {
+				if((now - (*cur_app)->times.mtime) < ttl) {
 					continue;
 				}
 
@@ -1275,11 +1293,11 @@ void sca_appearance_purge_stale(unsigned int ticks, void *param)
 				*cur_app = (*cur_app)->next;
 				tmp_app = cur_app;
 
-				if (app) {
+				if(app) {
 					sca_appearance_free(app);
 				}
 
-				if (unlinked) {
+				if(unlinked) {
 					// we've already added this AoR to the NOTIFY list
 					continue;
 				}
@@ -1288,19 +1306,19 @@ void sca_appearance_purge_stale(unsigned int ticks, void *param)
 
 				// can't notify while slot is locked. make a list of AoRs to
 				// notify after unlocking.
-				tmp_nl = (struct notify_list *) pkg_malloc(
+				tmp_nl = (struct notify_list *)pkg_malloc(
 						sizeof(struct notify_list));
-				if (tmp_nl == NULL) {
+				if(tmp_nl == NULL) {
 					LM_ERR("sca_appearance_purge_stale: failed to pkg_malloc "
-							"notify list entry for %.*s\n",
+						   "notify list entry for %.*s\n",
 							STR_FMT(&app_list->aor));
 					continue;
 				}
 
-				tmp_nl->aor.s = (char *) pkg_malloc(app_list->aor.len);
-				if (tmp_nl->aor.s == NULL) {
+				tmp_nl->aor.s = (char *)pkg_malloc(app_list->aor.len);
+				if(tmp_nl->aor.s == NULL) {
 					LM_ERR("sca_appearance_purge_stale: failed to pkg_malloc "
-							"space for copy of %.*s\n",
+						   "space for copy of %.*s\n",
 							STR_FMT(&app_list->aor));
 					pkg_free(tmp_nl);
 					continue;
@@ -1315,20 +1333,21 @@ void sca_appearance_purge_stale(unsigned int ticks, void *param)
 
 		sca_hash_table_unlock_index(ht, i);
 
-		for (; notify_list != NULL; notify_list = tmp_nl) {
+		for(; notify_list != NULL; notify_list = tmp_nl) {
 			tmp_nl = notify_list->next;
 
 			LM_INFO("sca_appearance_purge_stale: notifying %.*s call-info "
-					"subscribers\n", STR_FMT(&notify_list->aor));
+					"subscribers\n",
+					STR_FMT(&notify_list->aor));
 
-			if (sca_notify_call_info_subscribers(scam, &notify_list->aor) < 0) {
+			if(sca_notify_call_info_subscribers(scam, &notify_list->aor) < 0) {
 				LM_ERR("sca_appearance_purge_stale: failed to send "
-						"call-info NOTIFY %.*s subscribers\n",
+					   "call-info NOTIFY %.*s subscribers\n",
 						STR_FMT(&notify_list->aor));
 				// fall through, free memory anyway
 			}
 
-			if (notify_list->aor.s) {
+			if(notify_list->aor.s) {
 				pkg_free(notify_list->aor.s);
 			}
 			pkg_free(notify_list);
diff --git a/src/modules/sca/sca_appearance.h b/src/modules/sca/sca_appearance.h
index 8579494..bd94e14 100644
--- a/src/modules/sca/sca_appearance.h
+++ b/src/modules/sca/sca_appearance.h
@@ -24,7 +24,8 @@
 
 #include "sca_dialog.h"
 
-enum {
+enum
+{
 	SCA_APPEARANCE_STATE_IDLE = 0,
 	SCA_APPEARANCE_STATE_SEIZED,
 	SCA_APPEARANCE_STATE_PROGRESSING,
@@ -36,17 +37,20 @@ enum {
 	SCA_APPEARANCE_STATE_UNKNOWN = 0xff,
 };
 
-#define sca_appearance_is_held(app1) \
-	((app1) && ((app1)->state == SCA_APPEARANCE_STATE_HELD || \
-			(app1)->state == SCA_APPEARANCE_STATE_HELD_PRIVATE))
+#define sca_appearance_is_held(app1)                       \
+	((app1)                                                \
+			&& ((app1)->state == SCA_APPEARANCE_STATE_HELD \
+					|| (app1)->state == SCA_APPEARANCE_STATE_HELD_PRIVATE))
 
-enum {
+enum
+{
 	SCA_APPEARANCE_FLAG_DEFAULT = 0,
 	SCA_APPEARANCE_FLAG_OWNER_PENDING = (1 << 0),
 	SCA_APPEARANCE_FLAG_CALLEE_PENDING = (1 << 1),
 };
 
-enum {
+enum
+{
 	SCA_APPEARANCE_OK = 0,
 	SCA_APPEARANCE_ERR_NOT_IN_USE = 0x1001,
 	SCA_APPEARANCE_ERR_INDEX_INVALID = 0x1002,
@@ -54,7 +58,7 @@ enum {
 	SCA_APPEARANCE_ERR_MALLOC = 0x1008,
 	SCA_APPEARANCE_ERR_UNKNOWN = 0x1f00,
 };
-#define SCA_APPEARANCE_INDEX_UNAVAILABLE	-2
+#define SCA_APPEARANCE_INDEX_UNAVAILABLE -2
 
 /*
  * maximum lifetime of an active, pending appearance.
@@ -62,7 +66,8 @@ enum {
  * ACK. on receipt of the caller's ACK, we promote
  * the SCA callee's state to active.
  */
-enum {
+enum
+{
 	// Polycoms aggressively resubscribe line-seizes, give them time
 	SCA_APPEARANCE_STATE_SEIZED_TTL = 120,
 
@@ -82,7 +87,8 @@ extern const str SCA_APPEARANCE_STATE_STR_ACTIVE;
 extern const str SCA_APPEARANCE_STATE_STR_HELD;
 extern const str SCA_APPEARANCE_STATE_STR_HELD_PRIVATE;
 
-struct _sca_appearance_times {
+struct _sca_appearance_times
+{
 	// time of appearance creation
 	time_t ctime;
 
@@ -95,7 +101,8 @@ struct _sca_appearance_times {
 typedef struct _sca_appearance_times sca_appearance_times;
 
 struct _sca_appearance_list;
-struct _sca_appearance {
+struct _sca_appearance
+{
 	int index;
 	int state;
 	str uri;
@@ -116,7 +123,8 @@ struct _sca_appearance {
 };
 typedef struct _sca_appearance sca_appearance;
 
-struct _sca_appearance_list {
+struct _sca_appearance_list
+{
 	str aor;
 	int appearance_count;
 	sca_appearance *appearances;
@@ -126,38 +134,38 @@ typedef struct _sca_appearance_list sca_appearance_list;
 void sca_appearance_state_to_str(int, str *);
 int sca_appearance_state_from_str(str *);
 
-sca_appearance *sca_appearance_seize_index_unsafe(sca_mod *, str *, str *, int,
-		int, int *);
+sca_appearance *sca_appearance_seize_index_unsafe(
+		sca_mod *, str *, str *, int, int, int *);
 int sca_appearance_seize_index(sca_mod *, str *, int, str *);
 int sca_appearance_seize_next_available_index(sca_mod *, str *, str *);
-sca_appearance *sca_appearance_seize_next_available_unsafe(sca_mod *, str *,
-		str *, int);
+sca_appearance *sca_appearance_seize_next_available_unsafe(
+		sca_mod *, str *, str *, int);
 void sca_appearance_update_state_unsafe(sca_appearance *, int);
 int sca_appearance_update_owner_unsafe(sca_appearance *, str *);
 int sca_appearance_update_callee_unsafe(sca_appearance *, str *);
 int sca_appearance_update_dialog_unsafe(sca_appearance *, str *, str *, str *);
-int sca_appearance_update_unsafe(sca_appearance *, int, str *, str *,
-		sca_dialog *, str *, str *);
-int sca_appearance_update_index(sca_mod *, str *, int, int, str *, str *,
-		sca_dialog *);
+int sca_appearance_update_unsafe(
+		sca_appearance *, int, str *, str *, sca_dialog *, str *, str *);
+int sca_appearance_update_index(
+		sca_mod *, str *, int, int, str *, str *, sca_dialog *);
 int sca_appearance_release_index(sca_mod *, str *, int);
 int sca_appearance_owner_release_all(str *, str *);
 int sca_appearance_state_for_index(sca_mod *, str *, int);
 sca_appearance *sca_appearance_for_index_unsafe(sca_mod *, str *, int, int);
-sca_appearance *sca_appearance_for_dialog_unsafe(sca_mod *, str *, sca_dialog *,
-		int);
-sca_appearance *sca_appearance_for_tags_unsafe(sca_mod *, str *, str *, str *,
-		str *, int);
+sca_appearance *sca_appearance_for_dialog_unsafe(
+		sca_mod *, str *, sca_dialog *, int);
+sca_appearance *sca_appearance_for_tags_unsafe(
+		sca_mod *, str *, str *, str *, str *, int);
 
 int sca_appearance_register(sca_mod *, str *);
 int sca_appearance_unregister(sca_mod *, str *);
-void sca_appearance_list_insert_appearance(sca_appearance_list *,
-		sca_appearance *);
+void sca_appearance_list_insert_appearance(
+		sca_appearance_list *, sca_appearance *);
 sca_appearance *sca_appearance_list_unlink_index(sca_appearance_list *, int);
-int sca_appearance_list_unlink_appearance(sca_appearance_list *,
-		sca_appearance **);
-sca_appearance *sca_appearance_unlink_by_tags(sca_mod *, str *, str *, str *,
-		str *);
+int sca_appearance_list_unlink_appearance(
+		sca_appearance_list *, sca_appearance **);
+sca_appearance *sca_appearance_unlink_by_tags(
+		sca_mod *, str *, str *, str *, str *);
 
 sca_appearance *sca_appearance_create(int, str *);
 void sca_appearance_free(sca_appearance *);
diff --git a/src/modules/sca/sca_call_info.c b/src/modules/sca/sca_call_info.c
index 5592efd..c443f23 100644
--- a/src/modules/sca/sca_call_info.c
+++ b/src/modules/sca/sca_call_info.c
@@ -40,10 +40,10 @@ static int sca_call_info_domain_from_uri(str *uri, str *domain)
 	assert(domain != NULL);
 
 	domain->s = memchr(uri->s, '@', uri->len);
-	if (domain->s == NULL) {
+	if(domain->s == NULL) {
 		// may be a sip:domain URI
 		domain->s = memchr(uri->s, ':', uri->len);
-		if (domain->s == NULL) {
+		if(domain->s == NULL) {
 			LM_ERR("Bad URI %.*s\n", STR_FMT(uri));
 			return (-1);
 		}
@@ -81,18 +81,18 @@ static int sca_call_info_header_length_for_appearance(
 	assert(aor != NULL);
 
 	// get length of stringified index, since conversion's destructive
-	(void) int2str(appearance->index, &len);
+	(void)int2str(appearance->index, &len);
 
 	sca_appearance_state_to_str(appearance->state, &state_str);
 	len += state_str.len;
 
-	if (!SCA_STR_EMPTY(&appearance->uri)) {
+	if(!SCA_STR_EMPTY(&appearance->uri)) {
 		// +1 for ';', +1 for '=' between param name and value, +2 for quotes
 		len += SCA_APPEARANCE_URI_STR.len + 1 + 1 + 2;
 		len += appearance->uri.len;
 	}
 
-	if (sca_call_info_domain_from_uri(aor, &domain) < 0) {
+	if(sca_call_info_domain_from_uri(aor, &domain) < 0) {
 		return (-1);
 	}
 	len += domain.len;
@@ -102,8 +102,8 @@ static int sca_call_info_header_length_for_appearance(
 	return (len);
 }
 
-static int sca_call_info_header_append_appearances(sca_mod *scam,
-		sca_subscription *sub, char *hdrbuf, int maxlen)
+static int sca_call_info_header_append_appearances(
+		sca_mod *scam, sca_subscription *sub, char *hdrbuf, int maxlen)
 {
 	sca_appearance_list *app_list;
 	sca_appearance *app;
@@ -114,26 +114,26 @@ static int sca_call_info_header_append_appearances(sca_mod *scam,
 	int len = -1;
 	int usedlen = -1;
 
-	slot_idx = sca_hash_table_index_for_key(scam->appearances,
-			&sub->target_aor);
+	slot_idx =
+			sca_hash_table_index_for_key(scam->appearances, &sub->target_aor);
 	slot = sca_hash_table_slot_for_index(scam->appearances, slot_idx);
 
 	sca_hash_table_lock_index(scam->appearances, slot_idx);
 
 	app_list = sca_hash_table_slot_kv_find_unsafe(slot, &sub->target_aor);
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		len = 0;
 		goto done;
 	}
 
 	usedlen = 0;
-	for (app = app_list->appearances; app != NULL; app = app->next) {
+	for(app = app_list->appearances; app != NULL; app = app->next) {
 		len = sca_call_info_header_length_for_appearance(app, &sub->target_aor);
-		if (len < 0) {
+		if(len < 0) {
 			goto done;
 		}
 
-		if ((maxlen - len) < 0) {
+		if((maxlen - len) < 0) {
 			LM_ERR("Call-Info header for AoR %.*s is too long\n",
 					STR_FMT(&sub->target_aor));
 			len = -1;
@@ -143,7 +143,7 @@ static int sca_call_info_header_append_appearances(sca_mod *scam,
 		memcpy(hdrbuf, "<sip:", strlen("<sip:"));
 		len = strlen("<sip:");
 
-		if (sca_call_info_domain_from_uri(&sub->target_aor, &domain) < 0) {
+		if(sca_call_info_domain_from_uri(&sub->target_aor, &domain) < 0) {
 			return (-1);
 		}
 
@@ -157,7 +157,7 @@ static int sca_call_info_header_append_appearances(sca_mod *scam,
 				">;appearance-index=%d;appearance-state=%s", app->index,
 				state_str.s);
 
-		if (!SCA_STR_EMPTY(&app->uri)) {
+		if(!SCA_STR_EMPTY(&app->uri)) {
 			hdrbuf[len] = ';';
 			len += 1;
 
@@ -178,7 +178,7 @@ static int sca_call_info_header_append_appearances(sca_mod *scam,
 			len += 1;
 		}
 
-		if (app->next) {
+		if(app->next) {
 			memcpy(hdrbuf + len, ",", 1);
 			len++;
 		}
@@ -189,19 +189,19 @@ static int sca_call_info_header_append_appearances(sca_mod *scam,
 		usedlen += len;
 	}
 
-	done:
+done:
 	sca_hash_table_unlock_index(scam->appearances, slot_idx);
 
 	return (usedlen);
 }
 
-static int sca_call_info_build_idle_value(sca_mod *scam, str *aor, char *hdrbuf,
-		int maxlen)
+static int sca_call_info_build_idle_value(
+		sca_mod *scam, str *aor, char *hdrbuf, int maxlen)
 {
 	str idle_domain = STR_NULL;
 	int len;
 
-	if (sca_call_info_domain_from_uri(aor, &idle_domain) < 0) {
+	if(sca_call_info_domain_from_uri(aor, &idle_domain) < 0) {
 		LM_ERR("Failed to extract domain from %.*s for idle domain\n",
 				STR_FMT(aor));
 		return (-1);
@@ -211,7 +211,7 @@ static int sca_call_info_build_idle_value(sca_mod *scam, str *aor, char *hdrbuf,
 	len = snprintf(hdrbuf, maxlen, "<sip:%.*s>;%s=*;%s=%s%s",
 			STR_FMT(&idle_domain), SCA_APPEARANCE_INDEX_STR.s,
 			SCA_APPEARANCE_STATE_STR.s, SCA_APPEARANCE_STATE_STR_IDLE.s, CRLF);
-	if (len >= maxlen) {
+	if(len >= maxlen) {
 		LM_ERR("Failed to add idle appearance: Call-Info header too long\n");
 		len = -1;
 		// snprintf can also return negative. we catch that in the caller.
@@ -220,8 +220,8 @@ static int sca_call_info_build_idle_value(sca_mod *scam, str *aor, char *hdrbuf,
 	return (len);
 }
 
-int sca_call_info_build_header(sca_mod *scam, sca_subscription *sub,
-		char *hdrbuf, int maxlen)
+int sca_call_info_build_header(
+		sca_mod *scam, sca_subscription *sub, char *hdrbuf, int maxlen)
 {
 	// we send one Call-Info header, appearances separated by commas
 	int len;
@@ -230,21 +230,21 @@ int sca_call_info_build_header(sca_mod *scam, sca_subscription *sub,
 	// begin with "Call-Info: "
 	memcpy(hdrbuf, SCA_CALL_INFO_HEADER_STR.s, SCA_CALL_INFO_HEADER_STR.len);
 
-	len = sca_call_info_header_append_appearances(scam, sub, hdrbuf + usedlen,
-			maxlen - usedlen);
+	len = sca_call_info_header_append_appearances(
+			scam, sub, hdrbuf + usedlen, maxlen - usedlen);
 	usedlen += len;
-	if (usedlen > SCA_CALL_INFO_HEADER_STR.len) {
+	if(usedlen > SCA_CALL_INFO_HEADER_STR.len) {
 		// we added an indexed appearance, append a comma
 		memcpy(hdrbuf + usedlen, ",", 1);
 		usedlen++;
 	}
 
 	// line-seize NOTIFYs will contain only the seized appearance index
-	if (sub->event != SCA_EVENT_TYPE_LINE_SEIZE) {
+	if(sub->event != SCA_EVENT_TYPE_LINE_SEIZE) {
 		// if not all appearances in use, add *-index idle
-		len = sca_call_info_build_idle_value(scam, &sub->target_aor,
-				hdrbuf + usedlen, maxlen - usedlen);
-		if (len < 0 || len + usedlen >= maxlen) {
+		len = sca_call_info_build_idle_value(
+				scam, &sub->target_aor, hdrbuf + usedlen, maxlen - usedlen);
+		if(len < 0 || len + usedlen >= maxlen) {
 			LM_ERR("Cannot build idle Call-Info value: buffer too small\n");
 			return (-1);
 		}
@@ -254,55 +254,54 @@ int sca_call_info_build_header(sca_mod *scam, sca_subscription *sub,
 	return (usedlen);
 }
 
-int sca_call_info_append_header_for_appearance_index(sca_subscription *sub,
-		int appearance_index, char *hdrbuf, int maxlen)
+int sca_call_info_append_header_for_appearance_index(
+		sca_subscription *sub, int appearance_index, char *hdrbuf, int maxlen)
 {
 	str domain = STR_NULL;
 	char *app_index_p = NULL;
-	int len = 0,
-	idx_len;
+	int len = 0, idx_len;
 
 	memcpy(hdrbuf, SCA_CALL_INFO_HEADER_STR.s, SCA_CALL_INFO_HEADER_STR.len);
 	len += SCA_CALL_INFO_HEADER_STR.len;
-	if (len >= maxlen) {
+	if(len >= maxlen) {
 		goto error;
 	}
 
 	memcpy(hdrbuf + len, "<sip:", strlen("<sip:"));
 	len += strlen("<sip:");
-	if (len >= maxlen) {
+	if(len >= maxlen) {
 		goto error;
 	}
 
 	sca_call_info_domain_from_uri(&sub->target_aor, &domain);
 	memcpy(hdrbuf + len, domain.s, domain.len);
 	len += domain.len;
-	if (len >= maxlen) {
+	if(len >= maxlen) {
 		goto error;
 	}
 
 	memcpy(hdrbuf + len, ">;appearance-index=", strlen(">;appearance-index="));
 	len += strlen(">;appearance-index=");
-	if (len >= maxlen) {
+	if(len >= maxlen) {
 		goto error;
 	}
 
 	app_index_p = int2str(appearance_index, &idx_len);
 	memcpy(hdrbuf + len, app_index_p, idx_len);
 	len += idx_len;
-	if (len >= maxlen) {
+	if(len >= maxlen) {
 		goto error;
 	}
 
 	memcpy(hdrbuf + len, CRLF, CRLF_LEN);
 	len += CRLF_LEN;
-	if (len >= maxlen) {
+	if(len >= maxlen) {
 		goto error;
 	}
 
 	return (len);
 
-	error:
+error:
 	LM_ERR("Failed to append Call-Info header for %.*s appearance index %d\n",
 			STR_FMT(&sub->subscriber), appearance_index);
 	return (-1);
@@ -317,7 +316,7 @@ int sca_call_info_body_parse(str *hdr_body, sca_call_info *call_info)
 
 	assert(call_info != NULL);
 
-	if (SCA_STR_EMPTY(hdr_body)) {
+	if(SCA_STR_EMPTY(hdr_body)) {
 		LM_ERR("Call-Info header body is empty\n");
 		return (-1);
 	}
@@ -330,18 +329,19 @@ int sca_call_info_body_parse(str *hdr_body, sca_call_info *call_info)
 	call_info->uri.len = 0;
 
 	p = hdr_body->s;
-	if (memcmp(p, "<sip:", strlen("<sip:")) != 0) {
+	if(memcmp(p, "<sip:", strlen("<sip:")) != 0) {
 		LM_ERR("Bad Call-Info header body: must begin with \"<sip:\"\n");
 		return (-1);
 	}
 	// +5 == strlen("<sip:")
 	semi = memchr(p + 5, ';', hdr_body->len);
-	if (semi == NULL) {
+	if(semi == NULL) {
 		LM_ERR("Bad Call-Info header body: missing ';' between uri and "
-				"%.*s\n", STR_FMT(&SCA_APPEARANCE_INDEX_STR));
+			   "%.*s\n",
+				STR_FMT(&SCA_APPEARANCE_INDEX_STR));
 		return (-1);
 	}
-	if (*(semi - 1) != '>') {
+	if(*(semi - 1) != '>') {
 		LM_ERR("Bad Call-Info header body: SCA URI missing '>' terminator\n");
 		return (-1);
 	}
@@ -351,7 +351,7 @@ int sca_call_info_body_parse(str *hdr_body, sca_call_info *call_info)
 
 	p = semi;
 	p++;
-	if (memcmp(p, SCA_APPEARANCE_INDEX_STR.s, SCA_APPEARANCE_INDEX_STR.len)
+	if(memcmp(p, SCA_APPEARANCE_INDEX_STR.s, SCA_APPEARANCE_INDEX_STR.len)
 			!= 0) {
 		LM_ERR("Bad Call-Info header body: does not begin with %.*s\n",
 				STR_FMT(&SCA_APPEARANCE_INDEX_STR));
@@ -359,7 +359,7 @@ int sca_call_info_body_parse(str *hdr_body, sca_call_info *call_info)
 	}
 
 	p += SCA_APPEARANCE_INDEX_STR.len;
-	if (*p != '=') {
+	if(*p != '=') {
 		LM_ERR("Bad Call-Info header body: missing '=' after %.*s\n",
 				STR_FMT(&SCA_APPEARANCE_INDEX_STR));
 		return (-1);
@@ -368,26 +368,27 @@ int sca_call_info_body_parse(str *hdr_body, sca_call_info *call_info)
 	p++;
 	len = (hdr_body->s + hdr_body->len) - p;
 	semi = memchr(p, ';', len);
-	if (semi != NULL) {
+	if(semi != NULL) {
 		len = semi - p;
 	}
 	s.s = p;
 	s.len = len;
 
-	if (str2int(&s, (unsigned int *) &call_info->index) != 0) {
+	if(str2int(&s, (unsigned int *)&call_info->index) != 0) {
 		LM_ERR("Bad Call-Info header: failed to convert %.*s %.*s to an "
-				"integer\n", STR_FMT(&SCA_APPEARANCE_INDEX_STR), STR_FMT(&s));
+			   "integer\n",
+				STR_FMT(&SCA_APPEARANCE_INDEX_STR), STR_FMT(&s));
 		return (-1);
 	}
 
-	if (semi == NULL) {
+	if(semi == NULL) {
 		// Call-Info header only contained an appearance-index
 		goto done;
 	}
 
 	// advance appearance-index value + semi-colon
 	p += (len + 1);
-	if (memcmp(p, SCA_APPEARANCE_STATE_STR.s, SCA_APPEARANCE_STATE_STR.len)
+	if(memcmp(p, SCA_APPEARANCE_STATE_STR.s, SCA_APPEARANCE_STATE_STR.len)
 			!= 0) {
 		LM_ERR("Bad Call-Info header: missing %.*s\n",
 				STR_FMT(&SCA_APPEARANCE_STATE_STR));
@@ -395,44 +396,43 @@ int sca_call_info_body_parse(str *hdr_body, sca_call_info *call_info)
 	}
 
 	p += SCA_APPEARANCE_STATE_STR.len;
-	if (*p != '=') {
+	if(*p != '=') {
 		LM_ERR("Bad Call-Info header body: missing '=' after %.*s\n",
 				STR_FMT(&SCA_APPEARANCE_STATE_STR));
 		return (-1);
-
 	}
 
 	p++;
 	len = (hdr_body->s + hdr_body->len) - p;
 	semi = memchr(p, ';', len);
-	if (semi != NULL) {
+	if(semi != NULL) {
 		len = semi - p;
 	}
 	s.s = p;
 	s.len = len;
 
 	call_info->state = sca_appearance_state_from_str(&s);
-	if (call_info->state == SCA_APPEARANCE_STATE_UNKNOWN) {
+	if(call_info->state == SCA_APPEARANCE_STATE_UNKNOWN) {
 		LM_ERR("Bad Call-Info header: unrecognized state \"%.*s\"\n",
 				STR_FMT(&s));
 		return (-1);
 	}
 
-	if (semi == NULL) {
+	if(semi == NULL) {
 		// Call-Info header only had appearance-index & appearance-state
 		goto done;
 	}
 
 	// advance length of state + semi-colon
 	p += (len + 1);
-	if (memcmp(p, SCA_APPEARANCE_URI_STR.s, SCA_APPEARANCE_URI_STR.len) != 0) {
+	if(memcmp(p, SCA_APPEARANCE_URI_STR.s, SCA_APPEARANCE_URI_STR.len) != 0) {
 		LM_ERR("Bad Call-Info header: missing %.*s\n",
 				STR_FMT(&SCA_APPEARANCE_URI_STR));
 		return (-1);
 	}
 
 	p += SCA_APPEARANCE_URI_STR.len;
-	if (*p != '=') {
+	if(*p != '=') {
 		LM_ERR("Bad Call-Info header: missing '=' after %.*s\n",
 				STR_FMT(&SCA_APPEARANCE_URI_STR));
 		return (-1);
@@ -442,13 +442,14 @@ int sca_call_info_body_parse(str *hdr_body, sca_call_info *call_info)
 	call_info->uri.s = p;
 	call_info->uri.len = (hdr_body->s + hdr_body->len) - p;
 
-	if (SCA_STR_EMPTY(&call_info->uri)) {
+	if(SCA_STR_EMPTY(&call_info->uri)) {
 		LM_ERR("Bad Call-Info header: empty %.*s\n",
 				STR_FMT(&SCA_APPEARANCE_URI_STR));
 		return (-1);
 	}
 
-	done: return (0);
+done:
+	return (0);
 }
 
 /*
@@ -464,15 +465,15 @@ static int sca_call_info_header_remove(sip_msg_t *msg)
 	int rc = 0;
 
 	// all headers must be parsed before using del_lump
-	if (parse_headers(msg, HDR_EOH_F, 0) < 0) {
+	if(parse_headers(msg, HDR_EOH_F, 0) < 0) {
 		LM_ERR("Failed to parse_headers\n");
 		return (-1);
 	}
-	for (hdr = get_hdr(msg, HDR_CALLINFO_T); hdr; hdr = next_sibling_hdr(hdr)) {
+	for(hdr = get_hdr(msg, HDR_CALLINFO_T); hdr; hdr = next_sibling_hdr(hdr)) {
 		// del_lump takes packet, offset, lump length, & hdr type
-		ci_hdr_lump = del_lump(msg, hdr->name.s - msg->buf, hdr->len,
-				HDR_CALLINFO_T);
-		if (ci_hdr_lump == NULL) {
+		ci_hdr_lump =
+				del_lump(msg, hdr->name.s - msg->buf, hdr->len, HDR_CALLINFO_T);
+		if(ci_hdr_lump == NULL) {
 			LM_ERR("Failed to del_lump Call-Info header\n");
 			rc = -1;
 			break;
@@ -500,23 +501,24 @@ int sca_call_info_seize_held_call(sip_msg_t *msg, sca_call_info *call_info,
 	int slot_idx = -1;
 	int rc = -1;
 
-	LM_DBG( "From-AOR:%.*s To-AOR:%.*s From-URI:<%.*s> To-URI:<%.*s> "
-			"Contact: <%.*s> Call-Info: appearance-index=%d\n",
-			STR_FMT(from_aor), STR_FMT(to_aor),STR_FMT(&from->uri),
+	LM_DBG("From-AOR:%.*s To-AOR:%.*s From-URI:<%.*s> To-URI:<%.*s> "
+		   "Contact: <%.*s> Call-Info: appearance-index=%d\n",
+			STR_FMT(from_aor), STR_FMT(to_aor), STR_FMT(&from->uri),
 			STR_FMT(&to->uri), STR_FMT(contact_uri), call_info->index);
 
 	slot_idx = sca_hash_table_index_for_key(sca->appearances, from_aor);
 	sca_hash_table_lock_index(sca->appearances, slot_idx);
 
-	app = sca_appearance_for_index_unsafe(sca, from_aor, call_info->index,
-			slot_idx);
-	if (app == NULL) {
+	app = sca_appearance_for_index_unsafe(
+			sca, from_aor, call_info->index, slot_idx);
+	if(app == NULL) {
 		LM_ERR("sca_call_info_seize_held_call: no active appearances for "
-				"%.*s\n", STR_FMT(from_aor));
+			   "%.*s\n",
+				STR_FMT(from_aor));
 		goto done;
 	}
 
-	if (app->state == SCA_APPEARANCE_STATE_HELD_PRIVATE) {
+	if(app->state == SCA_APPEARANCE_STATE_HELD_PRIVATE) {
 		// spec calls for "403 Forbidden" when non-owner tries to
 		// seize a privately held call. if we get here, there's no
 		// to-tag in the INVITE, meaning this isn't a reINVITE
@@ -528,15 +530,16 @@ int sca_call_info_seize_held_call(sip_msg_t *msg, sca_call_info *call_info,
 		goto done;
 	}
 
-	LM_DBG("sca_call_info_seize_held_call: seizing %.*s index %d, callee %.*s\n",
+	LM_DBG("sca_call_info_seize_held_call: seizing %.*s index %d, callee "
+		   "%.*s\n",
 			STR_FMT(from_aor), app->index, STR_FMT(&app->callee));
 
 	// rewrite the RURI to use the callee in this SCA dialog
-	if (msg->new_uri.s) {
+	if(msg->new_uri.s) {
 		// someone already rewrote the URI. shouldn't happen, but we have
 		// to watch for it. log our overwriting of it.
 		LM_DBG("SCA caller retrieving held call, but RURI was already "
-				"rewritten as %.*s. Overwriting with %.*s.\n",
+			   "rewritten as %.*s. Overwriting with %.*s.\n",
 				STR_FMT(&msg->new_uri), STR_FMT(&app->callee));
 
 		pkg_free(msg->new_uri.s);
@@ -545,10 +548,11 @@ int sca_call_info_seize_held_call(sip_msg_t *msg, sca_call_info *call_info,
 	}
 
 	// msg->new_uri.s is free'd when transaction is torn down
-	msg->new_uri.s = (char *) pkg_malloc(app->callee.len);
-	if (msg->new_uri.s == NULL) {
+	msg->new_uri.s = (char *)pkg_malloc(app->callee.len);
+	if(msg->new_uri.s == NULL) {
 		LM_ERR("sca_call_info_seize_held_call: pkg_malloc new RURI %.*s "
-				"failed\n", STR_FMT(&app->callee));
+			   "failed\n",
+				STR_FMT(&app->callee));
 		goto done;
 	}
 	SCA_STR_COPY(&msg->new_uri, &app->callee);
@@ -556,10 +560,10 @@ int sca_call_info_seize_held_call(sip_msg_t *msg, sca_call_info *call_info,
 	{
 		int idx;
 
-		for (idx = 0; get_sip_branch(idx) != NULL; idx++)
+		for(idx = 0; get_sip_branch(idx) != NULL; idx++)
 			;
 
-		for (; idx >= 0; idx--) {
+		for(; idx >= 0; idx--) {
 			drop_sip_branch(idx);
 		}
 	}
@@ -576,39 +580,41 @@ int sca_call_info_seize_held_call(sip_msg_t *msg, sca_call_info *call_info,
 	SCA_STR_COPY(&prev_totag, &app->dialog.to_tag);
 
 	// pkg_malloc's replaces_hdr.s, which is free'd if added as lump
-	if (sca_dialog_create_replaces_header(&app->dialog, &replaces_hdr) < 0) {
+	if(sca_dialog_create_replaces_header(&app->dialog, &replaces_hdr) < 0) {
 		LM_ERR("sca_call_info_seize_held_call: failed to create Replaces "
-				"header for %.*s from dialog %.*s\n",
+			   "header for %.*s from dialog %.*s\n",
 				STR_FMT(from_aor), STR_FMT(&app->dialog.id));
 		goto done;
 	}
 
 	// store the callee's username for lookup of the callee by AoR
 	callee_aor.s = callee_buf;
-	if (sca_uri_build_aor(&callee_aor, sizeof(callee_buf), &app->callee,
-			from_aor) < 0) {
+	if(sca_uri_build_aor(
+			   &callee_aor, sizeof(callee_buf), &app->callee, from_aor)
+			< 0) {
 		LM_ERR("sca_call_info_seize_held_call: failed to create To AoR "
-				"from %.*s and %.*s\n", STR_FMT(&app->callee),
-				STR_FMT(from_aor));
+			   "from %.*s and %.*s\n",
+				STR_FMT(&app->callee), STR_FMT(from_aor));
 		pkg_free(replaces_hdr.s);
 		goto done;
 	}
 
 	// all headers must be parsed before using lump functions
-	if (parse_headers(msg, HDR_EOH_F, 0) < 0) {
+	if(parse_headers(msg, HDR_EOH_F, 0) < 0) {
 		LM_ERR("Failed to parse_headers\n");
 		goto done;
 	}
 
 	anchor = anchor_lump(msg, msg->eoh - msg->buf, 0, HDR_OTHER_T);
-	if (anchor == NULL) {
+	if(anchor == NULL) {
 		LM_ERR("Failed to anchor lump\n");
 		goto done;
 	}
 
 	// append the Replaces header before the sdp body
-	if (insert_new_lump_before(anchor, replaces_hdr.s, replaces_hdr.len,
-			HDR_OTHER_T) == NULL) {
+	if(insert_new_lump_before(
+			   anchor, replaces_hdr.s, replaces_hdr.len, HDR_OTHER_T)
+			== NULL) {
 		LM_ERR("Failed to add Replaces header %.*s\n", STR_FMT(&replaces_hdr));
 		pkg_free(replaces_hdr.s);
 		goto done;
@@ -623,14 +629,15 @@ int sca_call_info_seize_held_call(sip_msg_t *msg, sca_call_info *call_info,
 	//
 	// if the reINVITE to seize the held line fails for some reason,
 	// we restore the original owner and dialog.
-	if (sca_appearance_update_owner_unsafe(app, contact_uri) < 0) {
+	if(sca_appearance_update_owner_unsafe(app, contact_uri) < 0) {
 		LM_ERR("sca_call_info_seize_held_call: failed to update owner\n");
 		pkg_free(replaces_hdr.s);
 		goto done;
 	}
 
-	if (sca_appearance_update_dialog_unsafe(app, &msg->callid->body,
-			&from->tag_value, &to->tag_value) < 0) {
+	if(sca_appearance_update_dialog_unsafe(
+			   app, &msg->callid->body, &from->tag_value, &to->tag_value)
+			< 0) {
 		LM_ERR("sca_call_info_seize_held_call: failed to update dialog\n");
 		goto done;
 	}
@@ -641,13 +648,13 @@ int sca_call_info_seize_held_call(sip_msg_t *msg, sca_call_info *call_info,
 	sca_hash_table_unlock_index(sca->appearances, slot_idx);
 	slot_idx = -1;
 
-	if (callee_aor.s != NULL && callee_aor.len > 0) {
-		if (sca_uri_lock_if_shared_appearance(sca, &callee_aor, &slot_idx)) {
+	if(callee_aor.s != NULL && callee_aor.len > 0) {
+		if(sca_uri_lock_if_shared_appearance(sca, &callee_aor, &slot_idx)) {
 			app = sca_appearance_for_tags_unsafe(sca, &callee_aor, &prev_callid,
 					&prev_totag, NULL, slot_idx);
-			if (app == NULL) {
+			if(app == NULL) {
 				LM_ERR("sca_call_info_seize_held_call: failed to find "
-						"appearance of %.*s with dialog %.*s;%.*s\n",
+					   "appearance of %.*s with dialog %.*s;%.*s\n",
 						STR_FMT(&callee_aor), STR_FMT(&prev_callid),
 						STR_FMT(&prev_totag));
 				goto done;
@@ -655,15 +662,16 @@ int sca_call_info_seize_held_call(sip_msg_t *msg, sca_call_info *call_info,
 
 			app->flags |= SCA_APPEARANCE_FLAG_CALLEE_PENDING;
 
-			if (sca_appearance_update_callee_unsafe(app, contact_uri) < 0) {
+			if(sca_appearance_update_callee_unsafe(app, contact_uri) < 0) {
 				LM_ERR("sca_call_info_seize_held_call: "
-						"failed to update callee\n");
+					   "failed to update callee\n");
 				goto done;
 			}
-			if (sca_appearance_update_dialog_unsafe(app, &msg->callid->body,
-					&to->tag_value, &from->tag_value) < 0) {
+			if(sca_appearance_update_dialog_unsafe(app, &msg->callid->body,
+					   &to->tag_value, &from->tag_value)
+					< 0) {
 				LM_ERR("sca_call_info_seize_held_call: "
-						"failed to update dialog\n");
+					   "failed to update dialog\n");
 				goto done;
 			}
 		}
@@ -671,7 +679,8 @@ int sca_call_info_seize_held_call(sip_msg_t *msg, sca_call_info *call_info,
 
 	rc = 1;
 
-	done: if (slot_idx >= 0) {
+done:
+	if(slot_idx >= 0) {
 		sca_hash_table_unlock_index(sca->appearances, slot_idx);
 	}
 
@@ -695,17 +704,18 @@ static int sca_call_info_uri_update(str *aor, sca_call_info *call_info,
 	assert(call_info != NULL);
 
 	LM_DBG("sca_call_info_uri_update for %.*s: From: <%.*s> To: <%.*s> "
-			"Contact: <%.*s> Call-ID: %.*s Call-Info: appearance-index=%d\n",
+		   "Contact: <%.*s> Call-ID: %.*s Call-Info: appearance-index=%d\n",
 			STR_FMT(aor), STR_FMT(&from->uri), STR_FMT(&to->uri),
 			STR_FMT(contact_uri), STR_FMT(call_id), call_info->index);
 
-	if (!sca_uri_is_shared_appearance(sca, aor)) {
+	if(!sca_uri_is_shared_appearance(sca, aor)) {
 		return (1);
 	}
 
 	dialog.id.s = dlg_buf;
-	if (sca_dialog_build_from_tags(&dialog, sizeof(dlg_buf), call_id, from_tag,
-			to_tag) < 0) {
+	if(sca_dialog_build_from_tags(
+			   &dialog, sizeof(dlg_buf), call_id, from_tag, to_tag)
+			< 0) {
 		LM_ERR("sca_call_info_uri_update: Failed to build dialog from tags\n");
 		return (-1);
 	}
@@ -714,57 +724,62 @@ static int sca_call_info_uri_update(str *aor, sca_call_info *call_info,
 	sca_hash_table_lock_index(sca->appearances, slot_idx);
 
 	app = sca_appearance_for_index_unsafe(sca, aor, call_info->index, slot_idx);
-	if (app == NULL) {
+	if(app == NULL) {
 		LM_DBG("sca_call_info_uri_update: no appearance found for %.*s "
-				"index %d, looking up by dialog...\n", STR_FMT(aor),
-				call_info->index);
+			   "index %d, looking up by dialog...\n",
+				STR_FMT(aor), call_info->index);
 		app = sca_appearance_for_dialog_unsafe(sca, aor, &dialog, slot_idx);
 	}
-	if (app != NULL) {
+	if(app != NULL) {
 		LM_DBG("sca_call_info_uri_update: setting owner to %.*s\n",
 				STR_FMT(contact_uri));
 
-		if (sca_appearance_update_unsafe(app, call_info->state,
-		NULL, NULL, &dialog, contact_uri, NULL) < 0) {
+		if(sca_appearance_update_unsafe(app, call_info->state, NULL, NULL,
+				   &dialog, contact_uri, NULL)
+				< 0) {
 			sca_appearance_state_to_str(call_info->state, &state_str);
 			LM_ERR("sca_call_info_uri_update: failed to update appearance "
-					"%.*s appearance-index %d with dialog id %.*s to "
-					"state %.*s\n", STR_FMT(&app->owner), app->index,
-					STR_FMT(&app->dialog.id), STR_FMT(&state_str));
+				   "%.*s appearance-index %d with dialog id %.*s to "
+				   "state %.*s\n",
+					STR_FMT(&app->owner), app->index, STR_FMT(&app->dialog.id),
+					STR_FMT(&state_str));
 			goto done;
 		}
 
 		rc = 1;
 	} else {
-		app = sca_appearance_seize_index_unsafe(sca, aor, contact_uri,
-				call_info->index, slot_idx, NULL);
-		if (app == NULL) {
+		app = sca_appearance_seize_index_unsafe(
+				sca, aor, contact_uri, call_info->index, slot_idx, NULL);
+		if(app == NULL) {
 			LM_ERR("sca_call_info_uri_update: failed to seize index %d "
-					"for %.*s\n", call_info->index, STR_FMT(contact_uri));
+				   "for %.*s\n",
+					call_info->index, STR_FMT(contact_uri));
 			goto done;
 		}
 
 		LM_DBG("sca_call_info_uri_update: seized %d for %.*s: From: <%.*s> "
-				"To: <%.*s> Call-ID: <%.*s> Dialog: <%.*s>\n", app->index,
-				STR_FMT(&app->owner), STR_FMT(&from->uri),
-				STR_FMT(&to->uri), STR_FMT(call_id),
-				STR_FMT(&app->dialog.id));
-
-		if (sca_appearance_update_unsafe(app,
-				SCA_APPEARANCE_STATE_ACTIVE_PENDING, &from->display, &from->uri,
-				&dialog, contact_uri, &from->uri) < 0) {
+			   "To: <%.*s> Call-ID: <%.*s> Dialog: <%.*s>\n",
+				app->index, STR_FMT(&app->owner), STR_FMT(&from->uri),
+				STR_FMT(&to->uri), STR_FMT(call_id), STR_FMT(&app->dialog.id));
+
+		if(sca_appearance_update_unsafe(app,
+				   SCA_APPEARANCE_STATE_ACTIVE_PENDING, &from->display,
+				   &from->uri, &dialog, contact_uri, &from->uri)
+				< 0) {
 			sca_appearance_state_to_str(call_info->state, &state_str);
 			LM_ERR("sca_call_info_uri_update: failed to update appearance "
-					"%.*s appearance-index %d with dialog id %.*s to "
-					"state %.*s\n", STR_FMT(&app->owner), app->index,
-					STR_FMT(&app->dialog.id), STR_FMT(&state_str));
+				   "%.*s appearance-index %d with dialog id %.*s to "
+				   "state %.*s\n",
+					STR_FMT(&app->owner), app->index, STR_FMT(&app->dialog.id),
+					STR_FMT(&state_str));
 			goto done;
 		}
 
 		rc = 1;
 	}
 
-	done: if (slot_idx >= 0) {
+done:
+	if(slot_idx >= 0) {
 		sca_hash_table_unlock_index(sca->appearances, slot_idx);
 	}
 
@@ -773,13 +788,14 @@ static int sca_call_info_uri_update(str *aor, sca_call_info *call_info,
 
 static int sca_call_info_is_line_seize_reinvite(sip_msg_t *msg,
 		sca_call_info *call_info, struct to_body *from, struct to_body *to,
-		str *from_aor, str *to_aor) {
+		str *from_aor, str *to_aor)
+{
 	str *ruri;
 	str ruri_aor;
 	int state;
 
 	LM_DBG("For From-AOR %.*s To-AOR: %.*s: From: <%.*s> To: <%.*s> "
-			"Call-Info: appearance-index=%d\n",
+		   "Call-Info: appearance-index=%d\n",
 			STR_FMT(from_aor), STR_FMT(to_aor), STR_FMT(&from->uri),
 			STR_FMT(&to->uri), call_info->index);
 
@@ -788,32 +804,34 @@ static int sca_call_info_is_line_seize_reinvite(sip_msg_t *msg,
 	//		the above are SCA AoRs;
 	//		there is no to-tag;
 	//		a Call-Info header is present
-	if (SCA_CALL_INFO_EMPTY(call_info)) {
+	if(SCA_CALL_INFO_EMPTY(call_info)) {
 		return (0);
 	}
-	if (!SCA_STR_EMPTY(&to->tag_value)) {
+	if(!SCA_STR_EMPTY(&to->tag_value)) {
 		return (0);
 	}
 
 	ruri = GET_RURI(msg);
-	if (sca_uri_extract_aor(ruri, &ruri_aor) < 0) {
+	if(sca_uri_extract_aor(ruri, &ruri_aor) < 0) {
 		LM_ERR("sca_call_info_is_line_seize_reinvite: failed to extract "
-				"AoR from RURI %.*s\n", STR_FMT(ruri));
+			   "AoR from RURI %.*s\n",
+				STR_FMT(ruri));
 		return (0);
 	}
 
-	if (!SCA_STR_EQ(from_aor, to_aor)) {
+	if(!SCA_STR_EQ(from_aor, to_aor)) {
 		return (0);
 	}
 
 	state = sca_appearance_state_for_index(sca, from_aor, call_info->index);
-	if (state != SCA_APPEARANCE_STATE_HELD) {
+	if(state != SCA_APPEARANCE_STATE_HELD) {
 		LM_DBG("sca_call_info_is_line_seize_reinvite: new INVITE to "
-				"%.*s from %.*s appearance-index %d (not seizing held line)\n",
+			   "%.*s from %.*s appearance-index %d (not seizing held line)\n",
 				STR_FMT(to_aor), STR_FMT(from_aor), call_info->index);
 		return (0);
 	}
-	LM_DBG("reINVITE to %.*s from %.*s appearance-index %d (seizing held line)\n",
+	LM_DBG("reINVITE to %.*s from %.*s appearance-index %d (seizing held "
+		   "line)\n",
 			STR_FMT(to_aor), STR_FMT(from_aor), call_info->index);
 
 	return (1);
@@ -831,32 +849,36 @@ static void sca_call_info_local_error_reply_handler(sip_msg_t *msg, int status)
 	str contact_uri = STR_NULL;
 	int rc;
 
-	if (sca_get_msg_from_header(msg, &from) < 0) {
+	if(sca_get_msg_from_header(msg, &from) < 0) {
 		LM_ERR("sca_call_info_sl_reply_cb: failed to get From header from "
-				"request before stateless reply with %d\n", status);
+			   "request before stateless reply with %d\n",
+				status);
 		return;
 	}
-	if (sca_uri_extract_aor(&from->uri, &aor) < 0) {
+	if(sca_uri_extract_aor(&from->uri, &aor) < 0) {
 		LM_ERR("sca_call_info_sl_reply_cb: failed to extract AoR "
-				"from URI %.*s\n", STR_FMT(&from->uri));
+			   "from URI %.*s\n",
+				STR_FMT(&from->uri));
 		return;
 	}
 
-	if (!sca_uri_is_shared_appearance(sca, &aor)) {
+	if(!sca_uri_is_shared_appearance(sca, &aor)) {
 		// LM_DBG("sca_call_info_sl_reply_cb: ignoring non-shared appearance "
 		//		"%.*s\n", STR_FMT(&aor));
 		return;
 	}
 
-	if (sca_get_msg_contact_uri(msg, &contact_uri) < 0) {
+	if(sca_get_msg_contact_uri(msg, &contact_uri) < 0) {
 		LM_ERR("sca_call_info_sl_reply_cb: failed to get Contact from "
-				"request before stateless reply with %d\n", status);
+			   "request before stateless reply with %d\n",
+				status);
 		return;
 	}
 
-	if (sca_get_msg_to_header(msg, &to) < 0) {
+	if(sca_get_msg_to_header(msg, &to) < 0) {
 		LM_ERR("sca_call_info_sl_reply_cb: failed to get To header from "
-				"request before stateless reply with %d\n", status);
+			   "request before stateless reply with %d\n",
+				status);
 		return;
 	}
 
@@ -872,32 +894,33 @@ static void sca_call_info_local_error_reply_handler(sip_msg_t *msg, int status)
 	rc = sca_subscription_terminate(sca, &aor, SCA_EVENT_TYPE_LINE_SEIZE,
 			&contact_uri, SCA_SUBSCRIPTION_STATE_TERMINATED_NORESOURCE,
 			SCA_SUBSCRIPTION_TERMINATE_OPT_DEFAULT);
-	if (rc < 0) {
+	if(rc < 0) {
 		LM_ERR("sca_call_info_sl_reply_cb: failed to terminate "
-				"line-seize subscription for %.*s\n", STR_FMT(&contact_uri));
-	} else if (rc == 0) {
+			   "line-seize subscription for %.*s\n",
+				STR_FMT(&contact_uri));
+	} else if(rc == 0) {
 		// no line-seize subscription found
 		app = sca_appearance_unlink_by_tags(sca, &aor, &msg->callid->body,
 				&from->tag_value, &to->tag_value);
-		if (app) {
+		if(app) {
 			sca_appearance_free(app);
-			if (sca_notify_call_info_subscribers(sca, &aor) < 0) {
+			if(sca_notify_call_info_subscribers(sca, &aor) < 0) {
 				LM_ERR("sca_call_info_local_error_reply: failed to send "
-						"call-info NOTIFY to %.*s subscribers\n",
+					   "call-info NOTIFY to %.*s subscribers\n",
 						STR_FMT(&aor));
 			}
 		}
 	}
 }
 
-void sca_call_info_response_ready_cb(struct cell *t, int type,
-		struct tmcb_params *params)
+void sca_call_info_response_ready_cb(
+		struct cell *t, int type, struct tmcb_params *params)
 {
-	if (!(type & TMCB_RESPONSE_READY)) {
+	if(!(type & TMCB_RESPONSE_READY)) {
 		return;
 	}
 
-	if (params->code < 400) {
+	if(params->code < 400) {
 		// non-error final response: 1xx, 2xx, 3xx
 		return;
 	}
@@ -916,20 +939,22 @@ int sca_call_info_invite_request_handler(sip_msg_t *msg,
 	int rc = -1;
 
 	LM_DBG("For From-AOR %.*s To-AOR: %.*s: From: <%.*s> To: <%.*s> "
-			"Contact: <%.*s> Call-Info: appearance-index=%d\n",
-			STR_FMT(from_aor), STR_FMT(to_aor),STR_FMT(&from->uri), STR_FMT(&to->uri),
-			STR_FMT(contact_uri), call_info->index);
+		   "Contact: <%.*s> Call-Info: appearance-index=%d\n",
+			STR_FMT(from_aor), STR_FMT(to_aor), STR_FMT(&from->uri),
+			STR_FMT(&to->uri), STR_FMT(contact_uri), call_info->index);
 
 	// if we get here, one of the legs is an SCA endpoint. we want to know
 	// when the e2e ACK comes in so we can notify other members of the group.
-	if (sca->tm_api->register_tmcb(msg, NULL, TMCB_E2EACK_IN,
-			sca_call_info_ack_cb, NULL, NULL) < 0) {
+	if(sca->tm_api->register_tmcb(
+			   msg, NULL, TMCB_E2EACK_IN, sca_call_info_ack_cb, NULL, NULL)
+			< 0) {
 		LM_ERR("sca_call_info_invite_request_handler: failed to register "
-				"callback for INVITE %.*s ACK\n", STR_FMT(from_aor));
+			   "callback for INVITE %.*s ACK\n",
+				STR_FMT(from_aor));
 		goto done;
 	}
 
-	if (!SCA_CALL_INFO_IS_SHARED_CALLER(call_info)) {
+	if(!SCA_CALL_INFO_IS_SHARED_CALLER(call_info)) {
 		// caller isn't SCA, no more to do. update callee in reply handler.
 		rc = 1;
 		goto done;
@@ -938,49 +963,52 @@ int sca_call_info_invite_request_handler(sip_msg_t *msg,
 	// register callback to handle error responses sent from script using
 	// t_reply. TMCB_RESPONSE_READY will only be called from t_reply(),
 	// so relayed responses from upstream UASs will not triggers this.
-	if (sca->tm_api->register_tmcb(msg, NULL, TMCB_RESPONSE_READY,
-			sca_call_info_response_ready_cb, NULL, NULL) < 0) {
+	if(sca->tm_api->register_tmcb(msg, NULL, TMCB_RESPONSE_READY,
+			   sca_call_info_response_ready_cb, NULL, NULL)
+			< 0) {
 		LM_ERR("sca_call_info_invite_request_handler: failed to register "
-				"callback for INVITE %.*s ACK\n", STR_FMT(from_aor));
+			   "callback for INVITE %.*s ACK\n",
+				STR_FMT(from_aor));
 		goto done;
 	}
 
-	if (sca_call_is_held(msg)) {
+	if(sca_call_is_held(msg)) {
 		state = SCA_APPEARANCE_STATE_HELD;
-		if (call_info->state == SCA_APPEARANCE_STATE_HELD_PRIVATE) {
+		if(call_info->state == SCA_APPEARANCE_STATE_HELD_PRIVATE) {
 			state = SCA_APPEARANCE_STATE_HELD_PRIVATE;
 		} else {
 			state = SCA_APPEARANCE_STATE_HELD;
 		}
-	} else if (!SCA_STR_EMPTY(&to->tag_value)) {
+	} else if(!SCA_STR_EMPTY(&to->tag_value)) {
 		// this is a reINVITE from an SCA line that put the call on hold
 		state = SCA_APPEARANCE_STATE_ACTIVE;
-	} else if (sca_call_info_is_line_seize_reinvite(msg, call_info, from, to,
-			from_aor, to_aor)) {
-		rc = sca_call_info_seize_held_call(msg, call_info, from, to, from_aor,
-				to_aor, contact_uri);
-		if (rc <= 0) {
+	} else if(sca_call_info_is_line_seize_reinvite(
+					  msg, call_info, from, to, from_aor, to_aor)) {
+		rc = sca_call_info_seize_held_call(
+				msg, call_info, from, to, from_aor, to_aor, contact_uri);
+		if(rc <= 0) {
 			goto done;
 		}
 	}
 
 	// otherwise, this is an initial INVITE
 	dialog.id.s = dlg_buf;
-	if (sca_dialog_build_from_tags(&dialog, sizeof(dlg_buf), &msg->callid->body,
-			&from->tag_value, &to->tag_value) < 0) {
+	if(sca_dialog_build_from_tags(&dialog, sizeof(dlg_buf), &msg->callid->body,
+			   &from->tag_value, &to->tag_value)
+			< 0) {
 		LM_ERR("Failed to build dialog from tags\n");
 		return (-1);
 	}
 
-	if (sca_appearance_update_index(sca, from_aor, call_info->index, state,
-			NULL, NULL, &dialog) != SCA_APPEARANCE_OK) {
+	if(sca_appearance_update_index(
+			   sca, from_aor, call_info->index, state, NULL, NULL, &dialog)
+			!= SCA_APPEARANCE_OK) {
 		sca_appearance_state_to_str(state, &state_str);
 		LM_ERR("Failed to update %.*s appearance-index %d to %.*s\n",
-				STR_FMT(from_aor), call_info->index,
-				STR_FMT(&state_str));
+				STR_FMT(from_aor), call_info->index, STR_FMT(&state_str));
 	}
 
-	if (sca_notify_call_info_subscribers(sca, from_aor) < 0) {
+	if(sca_notify_call_info_subscribers(sca, from_aor) < 0) {
 		LM_ERR("Failed to call-info NOTIFY %.*s subscribers on INVITE\n",
 				STR_FMT(from_aor));
 		goto done;
@@ -988,7 +1016,8 @@ int sca_call_info_invite_request_handler(sip_msg_t *msg,
 
 	rc = 1;
 
-	done: return (rc);
+done:
+	return (rc);
 }
 
 int sca_call_info_invite_reply_18x_handler(sip_msg_t *msg,
@@ -1003,78 +1032,81 @@ int sca_call_info_invite_reply_18x_handler(sip_msg_t *msg,
 	int notify = 0;
 
 	LM_DBG("For From-AOR %.*s To-AOR: %.*s: From: <%.*s> To: <%.*s> "
-			"Contact: <%.*s> Call-Info: appearance-index=%d",
-			STR_FMT(from_aor), STR_FMT(to_aor),STR_FMT(&from->uri), STR_FMT(&to->uri),
-			STR_FMT(contact_uri), call_info->index);
+		   "Contact: <%.*s> Call-Info: appearance-index=%d",
+			STR_FMT(from_aor), STR_FMT(to_aor), STR_FMT(&from->uri),
+			STR_FMT(&to->uri), STR_FMT(contact_uri), call_info->index);
 
-	switch (msg->REPLY_STATUS) {
-	case 180:
-	case 183:
-		state = SCA_APPEARANCE_STATE_PROGRESSING;
-		break;
+	switch(msg->REPLY_STATUS) {
+		case 180:
+		case 183:
+			state = SCA_APPEARANCE_STATE_PROGRESSING;
+			break;
 
-	default:
-		goto done;
+		default:
+			goto done;
 	}
 
-	if (!sca_uri_lock_if_shared_appearance(sca, from_aor, &slot_idx)) {
+	if(!sca_uri_lock_if_shared_appearance(sca, from_aor, &slot_idx)) {
 		LM_DBG("sca_call_info_invite_reply_18x_handler: From-AoR %.*s is "
-				"not a shared appearance\n", STR_FMT(from_aor));
+			   "not a shared appearance\n",
+				STR_FMT(from_aor));
 		return (1);
 	}
 
 	app = sca_appearance_for_tags_unsafe(sca, from_aor, &msg->callid->body,
 			&from->tag_value, &to->tag_value, slot_idx);
-	if (app == NULL) {
+	if(app == NULL) {
 		goto done;
 	}
 
 	// clone appearance owner for subscription termination below
-	owner.s = (char *) pkg_malloc(app->owner.len);
-	if (owner.s == NULL) {
+	owner.s = (char *)pkg_malloc(app->owner.len);
+	if(owner.s == NULL) {
 		LM_ERR("sca_call_info_invite_18x_reply_handler: failed to "
-				"pkg_malloc %d bytes to clone <%.*s>\n",
+			   "pkg_malloc %d bytes to clone <%.*s>\n",
 				app->owner.len, STR_FMT(&app->owner));
 		goto done;
 	}
 	SCA_STR_COPY(&owner, &app->owner);
 
 	notify = (app->state != state);
-	if (notify) {
+	if(notify) {
 		sca_appearance_update_state_unsafe(app, state);
 	}
 	rc = 1;
 
-	done: if (slot_idx >= 0) {
+done:
+	if(slot_idx >= 0) {
 		sca_hash_table_unlock_index(sca->appearances, slot_idx);
 	}
 
-	if (rc > 0 && notify && owner.s != NULL) {
-		if (sca_subscription_terminate(sca, from_aor, SCA_EVENT_TYPE_LINE_SEIZE,
-				&owner, SCA_SUBSCRIPTION_STATE_TERMINATED_NORESOURCE,
-				SCA_SUBSCRIPTION_TERMINATE_OPT_UNSUBSCRIBE) < 0) {
+	if(rc > 0 && notify && owner.s != NULL) {
+		if(sca_subscription_terminate(sca, from_aor, SCA_EVENT_TYPE_LINE_SEIZE,
+				   &owner, SCA_SUBSCRIPTION_STATE_TERMINATED_NORESOURCE,
+				   SCA_SUBSCRIPTION_TERMINATE_OPT_UNSUBSCRIBE)
+				< 0) {
 			LM_ERR("sca_call_info_invite_reply_18x_handler: "
-					"failed to terminate line-seize subscription for %.*s\n",
+				   "failed to terminate line-seize subscription for %.*s\n",
 					STR_FMT(&owner));
 			rc = -1;
 		}
 
-		if (sca_notify_call_info_subscribers(sca, from_aor) < 0) {
+		if(sca_notify_call_info_subscribers(sca, from_aor) < 0) {
 			LM_ERR("sca_call_info_invite_reply_18x_handler: "
-					"failed to NOTIFY %.*s call-info subscribers\n",
+				   "failed to NOTIFY %.*s call-info subscribers\n",
 					STR_FMT(from_aor));
 			rc = -1;
 		}
 	}
-	if (owner.s != NULL) {
+	if(owner.s != NULL) {
 		pkg_free(owner.s);
 	}
 
 	return (rc);
 }
 
-static int sca_call_info_insert_asserted_identity(sip_msg_t *msg, str *display,
-		int ua_type)
+static int sca_call_info_insert_asserted_identity(
+		sip_msg_t *msg, str *display, int ua_type)
 {
 	struct lump *anchor;
 	str aor = STR_NULL;
@@ -1083,33 +1115,33 @@ static int sca_call_info_insert_asserted_identity(sip_msg_t *msg, str *display,
 	int rc = -1;
 
 	anchor = anchor_lump(msg, msg->eoh - msg->buf, 0, HDR_OTHER_T);
-	if (anchor == NULL) {
+	if(anchor == NULL) {
 		LM_ERR("Failed to anchor lump\n");
 		goto done;
 	}
 
-	if (sca_create_canonical_aor_for_ua(msg, &aor, ua_type) < 0) {
+	if(sca_create_canonical_aor_for_ua(msg, &aor, ua_type) < 0) {
 		LM_ERR("sca_call_info_insert_asserted_identity: failed to create "
-				"canonical AoR\n");
+			   "canonical AoR\n");
 		goto done;
 	}
 
-#define SCA_P_ASSERTED_IDENTITY_HDR_PREFIX	"P-Asserted-Identity: "
-#define SCA_P_ASSERTED_IDENTITY_HDR_PREFIX_LEN	strlen("P-Asserted-Identity: ")
+#define SCA_P_ASSERTED_IDENTITY_HDR_PREFIX "P-Asserted-Identity: "
+#define SCA_P_ASSERTED_IDENTITY_HDR_PREFIX_LEN strlen("P-Asserted-Identity: ")
 
 	len = SCA_P_ASSERTED_IDENTITY_HDR_PREFIX_LEN;
 	len += display->len;
 	// +1 for space, +1 for <, + 1 for >
 	len += 1 + 1 + aor.len + 1 + CRLF_LEN;
 
-	hdr.s = (char *) pkg_malloc(len);
-	if (hdr.s == NULL) {
+	hdr.s = (char *)pkg_malloc(len);
+	if(hdr.s == NULL) {
 		LM_ERR("insert_asserted_identity: pkg_malloc %d bytes failed\n", len);
 		goto done;
 	}
 
 	memcpy(hdr.s, SCA_P_ASSERTED_IDENTITY_HDR_PREFIX,
-	SCA_P_ASSERTED_IDENTITY_HDR_PREFIX_LEN);
+			SCA_P_ASSERTED_IDENTITY_HDR_PREFIX_LEN);
 	hdr.len = SCA_P_ASSERTED_IDENTITY_HDR_PREFIX_LEN;
 
 	SCA_STR_APPEND(&hdr, display);
@@ -1129,17 +1161,18 @@ static int sca_call_info_insert_asserted_identity(sip_msg_t *msg, str *display,
 	hdr.len += CRLF_LEN;
 
 	// append the PAI header before the sdp body
-	if (insert_new_lump_before(anchor, hdr.s, hdr.len, HDR_PAI_T) == NULL) {
+	if(insert_new_lump_before(anchor, hdr.s, hdr.len, HDR_PAI_T) == NULL) {
 		LM_ERR("Failed to add PAI header %.*s\n", STR_FMT(&hdr));
 		goto done;
 	}
 
 	rc = 1;
 
-	done: if (aor.s != NULL) {
+done:
+	if(aor.s != NULL) {
 		pkg_free(aor.s);
 	}
-	if (rc < 0 && hdr.s != NULL) {
+	if(rc < 0 && hdr.s != NULL) {
 		pkg_free(hdr.s);
 	}
 
@@ -1162,22 +1195,23 @@ static int sca_call_info_invite_reply_200_handler(sip_msg_t *msg,
 	int rc = -1;
 
 	LM_DBG("For From-AOR %.*s To-AOR: %.*s: From: <%.*s> To: <%.*s> "
-			"Contact: <%.*s> Call-Info: appearance-index=%d\n",
-			STR_FMT(from_aor), STR_FMT(to_aor),STR_FMT(&from->uri), STR_FMT(&to->uri),
-			STR_FMT(contact_uri), call_info->index);
+		   "Contact: <%.*s> Call-Info: appearance-index=%d\n",
+			STR_FMT(from_aor), STR_FMT(to_aor), STR_FMT(&from->uri),
+			STR_FMT(&to->uri), STR_FMT(contact_uri), call_info->index);
 
-	if (SCA_CALL_INFO_IS_SHARED_CALLEE(call_info) &&
-			(!SCA_STR_EQ(from_aor, to_aor))) {
-		rc = sca_call_info_uri_update(to_aor, call_info, from, to, contact_uri,
-				&msg->callid->body);
+	if(SCA_CALL_INFO_IS_SHARED_CALLEE(call_info)
+			&& (!SCA_STR_EQ(from_aor, to_aor))) {
+		rc = sca_call_info_uri_update(
+				to_aor, call_info, from, to, contact_uri, &msg->callid->body);
 	}
 
-	if (!SCA_CALL_INFO_IS_SHARED_CALLER(call_info)) {
+	if(!SCA_CALL_INFO_IS_SHARED_CALLER(call_info)) {
 		goto done;
 	}
 
-	if (sca_call_info_insert_asserted_identity(msg, &to->display,
-			SCA_AOR_TYPE_UAS) < 0) {
+	if(sca_call_info_insert_asserted_identity(
+			   msg, &to->display, SCA_AOR_TYPE_UAS)
+			< 0) {
 		LM_WARN("sca_call_info_invite_reply_200_handler: failed to "
 				"add P-Asserted-Identity header to response from %.*s\n",
 				STR_FMT(contact_uri));
@@ -1197,29 +1231,31 @@ static int sca_call_info_invite_reply_200_handler(sip_msg_t *msg,
 
 	app = sca_appearance_for_tags_unsafe(sca, from_aor, &msg->callid->body,
 			&from->tag_value, NULL, slot_idx);
-	if (app == NULL) {
+	if(app == NULL) {
 		// no SCA line is involved with this call
 		rc = 1;
 		goto done;
 	}
 
-	if (!sca_appearance_is_held(app)) {
+	if(!sca_appearance_is_held(app)) {
 		state = SCA_APPEARANCE_STATE_ACTIVE;
 	}
 
 	// if a Call-Info header is present, app-index goes to Contact
 	dialog.id.s = dlg_buf;
-	if (sca_dialog_build_from_tags(&dialog, sizeof(dlg_buf), &msg->callid->body,
-			&from->tag_value, &to->tag_value) < 0) {
+	if(sca_dialog_build_from_tags(&dialog, sizeof(dlg_buf), &msg->callid->body,
+			   &from->tag_value, &to->tag_value)
+			< 0) {
 		LM_ERR("sca_call_info_invite_handler: failed to build sca_dialog "
-				"from tags\n");
+			   "from tags\n");
 		rc = -1;
 		goto done;
 	}
 
-	if (parse_uri(contact_uri->s, contact_uri->len, &c_uri) < 0) {
+	if(parse_uri(contact_uri->s, contact_uri->len, &c_uri) < 0) {
 		LM_ERR("sca_call_info_invite_200_reply_handler: "
-				"parse_uri <%.*s> failed\n", STR_FMT(contact_uri));
+			   "parse_uri <%.*s> failed\n",
+				STR_FMT(contact_uri));
 		goto done;
 	}
 
@@ -1228,38 +1264,42 @@ static int sca_call_info_invite_reply_200_handler(sip_msg_t *msg,
 	// INVITE for the call to sca_appearance_update_unsafe(). Otherwise its a
 	// 200 reply for a reINVITE and the 'to_display' and 'app_uri_aor' are
 	// already set to NULL and that won't change the appearance-uri.
-	if (!SCA_STR_EQ(from_aor, to_aor)) {
+	if(!SCA_STR_EQ(from_aor, to_aor)) {
 		to_display = to->display;
-		if (sca_create_canonical_aor(msg, &app_uri_aor) < 0) {
-			LM_ERR( "sca_call_info_invite_200_reply_handler: "
-					"sca_create_canonical_aor failed\n" );
+		if(sca_create_canonical_aor(msg, &app_uri_aor) < 0) {
+			LM_ERR("sca_call_info_invite_200_reply_handler: "
+				   "sca_create_canonical_aor failed\n");
 			goto done;
 		}
 	}
-	if (sca_appearance_update_unsafe(app, state, &to_display, &app_uri_aor,
-			&dialog, NULL, contact_uri) < 0) {
+	if(sca_appearance_update_unsafe(app, state, &to_display, &app_uri_aor,
+			   &dialog, NULL, contact_uri)
+			< 0) {
 		sca_appearance_state_to_str(state, &state_str);
 		LM_ERR("sca_call_info_invite_handler: failed to update appearance "
-				"%.*s appearance-index %d with dialog id %.*s to "
-				"state %.*s\n", STR_FMT(&app->owner), app->index,
-				STR_FMT(&app->dialog.id), STR_FMT(&state_str));
+			   "%.*s appearance-index %d with dialog id %.*s to "
+			   "state %.*s\n",
+				STR_FMT(&app->owner), app->index, STR_FMT(&app->dialog.id),
+				STR_FMT(&state_str));
 		rc = -1;
 		goto done;
 	}
 
 	rc = 1;
 
-	done: if (slot_idx >= 0) {
+done:
+	if(slot_idx >= 0) {
 		sca_hash_table_unlock_index(sca->appearances, slot_idx);
 	}
-	if (app_uri_aor.s != NULL) {
+	if(app_uri_aor.s != NULL) {
 		pkg_free(app_uri_aor.s);
 	}
 
-	if (rc == 1) {
-		if (sca_notify_call_info_subscribers(sca, from_aor) < 0) {
+	if(rc == 1) {
+		if(sca_notify_call_info_subscribers(sca, from_aor) < 0) {
 			LM_ERR("Failed to call-info NOTIFY %.*s subscribers on "
-					"200 OK reply to INVITE\n", STR_FMT(from_aor));
+				   "200 OK reply to INVITE\n",
+					STR_FMT(from_aor));
 			rc = -1;
 		}
 	}
@@ -1281,25 +1321,26 @@ static int sca_call_info_invite_reply_error_handler(sip_msg_t *msg,
 	// for a start, we just deal with the first case.
 	sca_appearance *app;
 
-	if (msg->REPLY_STATUS == 487) {
+	if(msg->REPLY_STATUS == 487) {
 		// reply status for a CANCEL'd INVITE
 		return (1);
 	}
 
-	if (sca_uri_is_shared_appearance(sca, from_aor)) {
-		app = sca_appearance_unlink_by_tags(sca, from_aor, &msg->callid->body,
-				&from->tag_value, NULL);
-		if (app == NULL) {
+	if(sca_uri_is_shared_appearance(sca, from_aor)) {
+		app = sca_appearance_unlink_by_tags(
+				sca, from_aor, &msg->callid->body, &from->tag_value, NULL);
+		if(app == NULL) {
 			LM_ERR("sca_call_info_invite_reply_error_handler: failed to "
-					"look up dialog for failed INVITE %.*s from %.*s\n",
+				   "look up dialog for failed INVITE %.*s from %.*s\n",
 					STR_FMT(&to->uri), STR_FMT(from_aor));
 			return (-1);
 		}
 		sca_appearance_free(app);
 
-		if (sca_notify_call_info_subscribers(sca, from_aor) < 0) {
+		if(sca_notify_call_info_subscribers(sca, from_aor) < 0) {
 			LM_ERR("Failed to call-info NOTIFY %.*s subscribers on "
-					"failed INVITE\n", STR_FMT(from_aor));
+				   "failed INVITE\n",
+					STR_FMT(from_aor));
 			return (-1);
 		}
 	}
@@ -1315,22 +1356,23 @@ void sca_call_info_ack_from_handler(sip_msg_t *msg, str *from_aor, str *to_aor)
 	int slot_idx = -1;
 	int state = SCA_APPEARANCE_STATE_IDLE;
 
-	if (sca_get_msg_from_header(msg, &from) < 0) {
+	if(sca_get_msg_from_header(msg, &from) < 0) {
 		LM_ERR("sca_call_info_ack_cb: failed to get From-header\n");
 		return;
 	}
-	if (sca_get_msg_to_header(msg, &to) < 0) {
+	if(sca_get_msg_to_header(msg, &to) < 0) {
 		LM_ERR("sca_call_info_ack_cb: failed to get To-header\n");
 		return;
 	}
 
-	if (sca_uri_lock_if_shared_appearance(sca, from_aor, &slot_idx)) {
+	if(sca_uri_lock_if_shared_appearance(sca, from_aor, &slot_idx)) {
 		app = sca_appearance_for_tags_unsafe(sca, from_aor, &msg->callid->body,
 				&from->tag_value, NULL, slot_idx);
-		if (app == NULL) {
+		if(app == NULL) {
 			LM_ERR("sca_call_info_ack_cb: No appearance for %.*s matching "
-					"call-id <%.*s> and from-tag <%.*s>\n", STR_FMT(from_aor),
-					STR_FMT(&msg->callid->body), STR_FMT(&from->tag_value));
+				   "call-id <%.*s> and from-tag <%.*s>\n",
+					STR_FMT(from_aor), STR_FMT(&msg->callid->body),
+					STR_FMT(&from->tag_value));
 			goto done;
 		}
 
@@ -1345,19 +1387,21 @@ void sca_call_info_ack_from_handler(sip_msg_t *msg, str *from_aor, str *to_aor)
 		// false. instead, the ACK from the party placing the call on hold
 		// includes the sendonly SDP. detect that here, and send NOTIFYs
 		// as necessary.
-		if (sca_call_is_held(msg)) {
+		if(sca_call_is_held(msg)) {
 			state = SCA_APPEARANCE_STATE_HELD;
 			sca_appearance_update_state_unsafe(app, state);
 			// can't send NOTIFYs until we unlock the slot below
 		}
 	}
 
-	done: if (slot_idx >= 0) {
+done:
+	if(slot_idx >= 0) {
 		sca_hash_table_unlock_index(sca->appearances, slot_idx);
 
-		if (state != SCA_APPEARANCE_STATE_IDLE) {
-			if (sca_notify_call_info_subscribers(sca, from_aor) < 0) {
-				LM_ERR("Failed to call-info NOTIFY %.*s subscribers on INVITE\n",
+		if(state != SCA_APPEARANCE_STATE_IDLE) {
+			if(sca_notify_call_info_subscribers(sca, from_aor) < 0) {
+				LM_ERR("Failed to call-info NOTIFY %.*s subscribers on "
+					   "INVITE\n",
 						STR_FMT(from_aor));
 			}
 		}
@@ -1373,19 +1417,19 @@ void sca_call_info_ack_cb(struct cell *t, int type, struct tmcb_params *params)
 	str to_aor = STR_NULL;
 	int slot_idx = -1;
 
-	if (!(type & TMCB_E2EACK_IN)) {
+	if(!(type & TMCB_E2EACK_IN)) {
 		return;
 	}
 
-	if (sca_create_canonical_aor(params->req, &from_aor) < 0) {
+	if(sca_create_canonical_aor(params->req, &from_aor) < 0) {
 		return;
 	}
 
-	if (sca_get_msg_to_header(params->req, &to) < 0) {
+	if(sca_get_msg_to_header(params->req, &to) < 0) {
 		LM_ERR("sca_call_info_ack_cb: failed to get To-header\n");
 		goto done;
 	}
-	if (sca_uri_extract_aor(&to->uri, &to_aor) < 0) {
+	if(sca_uri_extract_aor(&to->uri, &to_aor) < 0) {
 		LM_ERR("sca_call_info_ack_cb: failed to extract To AoR from %.*s\n",
 				STR_FMT(&to->uri));
 		goto done;
@@ -1393,7 +1437,7 @@ void sca_call_info_ack_cb(struct cell *t, int type, struct tmcb_params *params)
 
 	sca_call_info_ack_from_handler(params->req, &from_aor, &to_aor);
 
-	if (!sca_uri_lock_if_shared_appearance(sca, &to_aor, &slot_idx)) {
+	if(!sca_uri_lock_if_shared_appearance(sca, &to_aor, &slot_idx)) {
 		LM_DBG("sca_call_info_ack_cb: %.*s is not a shared appearance\n",
 				STR_FMT(&to_aor));
 		goto done;
@@ -1402,73 +1446,75 @@ void sca_call_info_ack_cb(struct cell *t, int type, struct tmcb_params *params)
 	// on ACK, ensure SCA callee state is promoted to ACTIVE.
 	app = sca_appearance_for_tags_unsafe(sca, &to_aor,
 			&params->req->callid->body, &to->tag_value, NULL, slot_idx);
-	if (app && app->state == SCA_APPEARANCE_STATE_ACTIVE_PENDING) {
+	if(app && app->state == SCA_APPEARANCE_STATE_ACTIVE_PENDING) {
 		LM_DBG("promoting %.*s appearance-index %d to active\n",
 				STR_FMT(&to_aor), app->index);
 		sca_appearance_update_state_unsafe(app, SCA_APPEARANCE_STATE_ACTIVE);
 	}
 
-	if (slot_idx >= 0) {
+	if(slot_idx >= 0) {
 		sca_hash_table_unlock_index(sca->appearances, slot_idx);
 	}
 
-	if (sca_notify_call_info_subscribers(sca, &to_aor) < 0) {
+	if(sca_notify_call_info_subscribers(sca, &to_aor) < 0) {
 		LM_ERR("sca_call_info_ack_cb: failed to call-info "
-				"NOTIFY %.*s subscribers\n", STR_FMT(&to_aor));
+			   "NOTIFY %.*s subscribers\n",
+				STR_FMT(&to_aor));
 		goto done;
 	}
 
-	done: if (from_aor.s != NULL) {
+done:
+	if(from_aor.s != NULL) {
 		pkg_free(from_aor.s);
 	}
 }
 
-static int sca_call_info_invite_handler(sip_msg_t *msg, sca_call_info *call_info,
-		struct to_body *from, struct to_body *to, str *from_aor, str *to_aor,
-		str *contact_uri)
+static int sca_call_info_invite_handler(sip_msg_t *msg,
+		sca_call_info *call_info, struct to_body *from, struct to_body *to,
+		str *from_aor, str *to_aor, str *contact_uri)
 {
 	int rc = -1;
 
-	if (SCA_STR_EMPTY(contact_uri)) {
+	if(SCA_STR_EMPTY(contact_uri)) {
 		LM_DBG("sca_call_info_invite_handler: Contact header is empty. "
-				"(From: %.*s To: %.*s)\n", STR_FMT(from_aor),
-				STR_FMT(to_aor));
+			   "(From: %.*s To: %.*s)\n",
+				STR_FMT(from_aor), STR_FMT(to_aor));
 		return (1);
 	}
 
-	if (msg->first_line.type == SIP_REQUEST) {
-		rc = sca_call_info_invite_request_handler(msg, call_info, from, to,
-				from_aor, to_aor, contact_uri);
+	if(msg->first_line.type == SIP_REQUEST) {
+		rc = sca_call_info_invite_request_handler(
+				msg, call_info, from, to, from_aor, to_aor, contact_uri);
 	} else {
 		// XXX replace with dispatch table.
-		switch (msg->REPLY_STATUS) {
-		case 100:
-			rc = 1;
-			break;
-
-		case 180:
-		case 183:
-			rc = sca_call_info_invite_reply_18x_handler(msg, call_info, from,
-					to, from_aor, to_aor, contact_uri);
-			break;
-
-		case 200:
-			rc = sca_call_info_invite_reply_200_handler(msg, call_info, from,
-					to, from_aor, to_aor, contact_uri);
-			break;
-
-		case 300:
-		case 301:
-		case 302:
-			// redirection (at least on Polycoms) does not cause caller to
-			// release its seized appearance. pass it through.
-			rc = 1;
-			break;
+		switch(msg->REPLY_STATUS) {
+			case 100:
+				rc = 1;
+				break;
+
+			case 180:
+			case 183:
+				rc = sca_call_info_invite_reply_18x_handler(msg, call_info,
+						from, to, from_aor, to_aor, contact_uri);
+				break;
+
+			case 200:
+				rc = sca_call_info_invite_reply_200_handler(msg, call_info,
+						from, to, from_aor, to_aor, contact_uri);
+				break;
+
+			case 300:
+			case 301:
+			case 302:
+				// redirection (at least on Polycoms) does not cause caller to
+				// release its seized appearance. pass it through.
+				rc = 1;
+				break;
 
-		default:
-			rc = sca_call_info_invite_reply_error_handler(msg, call_info, from,
-					to, from_aor, to_aor, contact_uri);
-			break;
+			default:
+				rc = sca_call_info_invite_reply_error_handler(msg, call_info,
+						from, to, from_aor, to_aor, contact_uri);
+				break;
 		}
 	}
 
@@ -1483,40 +1529,39 @@ static int sca_call_info_bye_handler(sip_msg_t *msg, sca_call_info *call_info,
 	int slot_idx = -1;
 	int rc = -1;
 
-	if (msg->first_line.type == SIP_REQUEST) {
-		if (SCA_CALL_INFO_IS_SHARED_CALLER(call_info)) {
+	if(msg->first_line.type == SIP_REQUEST) {
+		if(SCA_CALL_INFO_IS_SHARED_CALLER(call_info)) {
 			slot_idx = sca_uri_lock_shared_appearance(sca, from_aor);
-			if (slot_idx < 0) {
+			if(slot_idx < 0) {
 				LM_ERR("sca_call_info_bye_handler: failed to acquire "
-						"lock for %.*s, appearance-index %.d\n",
+					   "lock for %.*s, appearance-index %.d\n",
 						STR_FMT(from_aor), call_info->index);
 				goto done;
 			}
 
-			if (call_info->index != SCA_CALL_INFO_APPEARANCE_INDEX_ANY) {
-				app = sca_appearance_for_index_unsafe(sca, from_aor,
-						call_info->index, slot_idx);
+			if(call_info->index != SCA_CALL_INFO_APPEARANCE_INDEX_ANY) {
+				app = sca_appearance_for_index_unsafe(
+						sca, from_aor, call_info->index, slot_idx);
 			}
-			if (app == NULL) {
+			if(app == NULL) {
 				// try to find it by tags
 				app = sca_appearance_for_tags_unsafe(sca, from_aor,
 						&msg->callid->body, &from->tag_value, NULL, slot_idx);
 			}
-			if (app == NULL) {
+			if(app == NULL) {
 				LM_ERR("sca_call_info_bye_handler: %.*s "
-						"dialog leg %.*s;%.*s is not active\n",
-						STR_FMT(from_aor),
-						STR_FMT(&msg->callid->body),
+					   "dialog leg %.*s;%.*s is not active\n",
+						STR_FMT(from_aor), STR_FMT(&msg->callid->body),
 						STR_FMT(&from->tag_value));
 				goto done;
 			}
 
-			if (SCA_STR_EQ(&app->dialog.call_id, &msg->callid->body)) {
+			if(SCA_STR_EQ(&app->dialog.call_id, &msg->callid->body)) {
 				// XXX yes, duplicated below, too
-				if (!sca_appearance_list_unlink_appearance(app->appearance_list,
-						&app)) {
+				if(!sca_appearance_list_unlink_appearance(
+						   app->appearance_list, &app)) {
 					LM_ERR("sca_call_info_bye_handler: failed to unlink "
-							"%.*s appearance-index %d, owner %.*s\n",
+						   "%.*s appearance-index %d, owner %.*s\n",
 							STR_FMT(&app->owner), app->index,
 							STR_FMT(&app->owner));
 					goto done;
@@ -1526,21 +1571,22 @@ static int sca_call_info_bye_handler(sip_msg_t *msg, sca_call_info *call_info,
 				sca_hash_table_unlock_index(sca->appearances, slot_idx);
 				slot_idx = -1;
 
-				if (sca_notify_call_info_subscribers(sca, from_aor) < 0) {
+				if(sca_notify_call_info_subscribers(sca, from_aor) < 0) {
 					LM_ERR("Failed to call-info NOTIFY %.*s subscribers "
-							"on BYE\n", STR_FMT(&to->uri));
+						   "on BYE\n",
+							STR_FMT(&to->uri));
 					goto done;
 				}
 			}
 		}
 
-		if (slot_idx >= 0) {
+		if(slot_idx >= 0) {
 			sca_hash_table_unlock_index(sca->appearances, slot_idx);
 			slot_idx = -1;
 		}
 
-		if (SCA_CALL_INFO_IS_SHARED_CALLEE(call_info)) {
-			if (!sca_uri_lock_if_shared_appearance(sca, to_aor, &slot_idx)) {
+		if(SCA_CALL_INFO_IS_SHARED_CALLEE(call_info)) {
+			if(!sca_uri_lock_if_shared_appearance(sca, to_aor, &slot_idx)) {
 				LM_DBG("BYE from non-SCA %.*s to non-SCA %.*s\n",
 						STR_FMT(from_aor), STR_FMT(to_aor));
 				rc = 1;
@@ -1548,9 +1594,8 @@ static int sca_call_info_bye_handler(sip_msg_t *msg, sca_call_info *call_info,
 			}
 
 			app = sca_appearance_for_tags_unsafe(sca, to_aor,
-					&msg->callid->body, &to->tag_value,
-					NULL, slot_idx);
-			if (app == NULL) {
+					&msg->callid->body, &to->tag_value, NULL, slot_idx);
+			if(app == NULL) {
 				LM_INFO("sca_call_info_bye_handler: no in-use callee "
 						"appearance for BYE %.*s from %.*s, call-ID %.*s\n",
 						STR_FMT(to_aor), STR_FMT(from_aor),
@@ -1559,11 +1604,11 @@ static int sca_call_info_bye_handler(sip_msg_t *msg, sca_call_info *call_info,
 				goto done;
 			}
 
-			if (SCA_STR_EQ(&app->dialog.call_id, &msg->callid->body)) {
-				if (!sca_appearance_list_unlink_appearance(app->appearance_list,
-						&app)) {
+			if(SCA_STR_EQ(&app->dialog.call_id, &msg->callid->body)) {
+				if(!sca_appearance_list_unlink_appearance(
+						   app->appearance_list, &app)) {
 					LM_ERR("sca_call_info_bye_handler: failed to unlink "
-							"%.*s appearance-index %d, owner %.*s\n",
+						   "%.*s appearance-index %d, owner %.*s\n",
 							STR_FMT(&app->owner), app->index,
 							STR_FMT(&app->owner));
 					goto done;
@@ -1573,29 +1618,29 @@ static int sca_call_info_bye_handler(sip_msg_t *msg, sca_call_info *call_info,
 				sca_hash_table_unlock_index(sca->appearances, slot_idx);
 				slot_idx = -1;
 
-				if (sca_notify_call_info_subscribers(sca, to_aor) < 0) {
+				if(sca_notify_call_info_subscribers(sca, to_aor) < 0) {
 					LM_ERR("Failed to call-info NOTIFY %.*s subscribers "
-							"on BYE\n", STR_FMT(to_aor));
+						   "on BYE\n",
+							STR_FMT(to_aor));
 					goto done;
 				}
 			}
 		}
 	} else {
 		// this is just a backup to catch anything missed on the BYE request
-		if (SCA_CALL_INFO_IS_SHARED_CALLEE(call_info)) {
+		if(SCA_CALL_INFO_IS_SHARED_CALLEE(call_info)) {
 			slot_idx = sca_hash_table_index_for_key(sca->appearances, to_aor);
 			sca_hash_table_lock_index(sca->appearances, slot_idx);
 
-			app = sca_appearance_for_index_unsafe(sca, to_aor, call_info->index,
-					slot_idx);
-			if (app == NULL) {
+			app = sca_appearance_for_index_unsafe(
+					sca, to_aor, call_info->index, slot_idx);
+			if(app == NULL) {
 				app = sca_appearance_for_tags_unsafe(sca, to_aor,
-						&msg->callid->body, &to->tag_value,
-						NULL, slot_idx);
+						&msg->callid->body, &to->tag_value, NULL, slot_idx);
 			}
-			if (app == NULL) {
+			if(app == NULL) {
 				LM_DBG("sca_call_info_bye_handler: no appearance found "
-						"for callee %.*s, call-ID %.*s\n",
+					   "for callee %.*s, call-ID %.*s\n",
 						STR_FMT(to_aor), STR_FMT(&msg->callid->body));
 				rc = 1;
 				goto done;
@@ -1605,11 +1650,11 @@ static int sca_call_info_bye_handler(sip_msg_t *msg, sca_call_info *call_info,
 					"for callee %.*s, call-ID %.*s\n",
 					STR_FMT(to_aor), STR_FMT(&msg->callid->body));
 
-			if (SCA_STR_EQ(&app->dialog.call_id, &msg->callid->body)) {
-				if (!sca_appearance_list_unlink_appearance(app->appearance_list,
-						&app)) {
+			if(SCA_STR_EQ(&app->dialog.call_id, &msg->callid->body)) {
+				if(!sca_appearance_list_unlink_appearance(
+						   app->appearance_list, &app)) {
 					LM_ERR("sca_call_info_bye_handler: failed to unlink "
-							"%.*s appearance-index %d, owner %.*s\n",
+						   "%.*s appearance-index %d, owner %.*s\n",
 							STR_FMT(&app->owner), app->index,
 							STR_FMT(&app->owner));
 					goto done;
@@ -1619,9 +1664,10 @@ static int sca_call_info_bye_handler(sip_msg_t *msg, sca_call_info *call_info,
 				sca_hash_table_unlock_index(sca->appearances, slot_idx);
 				slot_idx = -1;
 
-				if (sca_notify_call_info_subscribers(sca, to_aor) < 0) {
+				if(sca_notify_call_info_subscribers(sca, to_aor) < 0) {
 					LM_ERR("Failed to call-info NOTIFY %.*s subscribers "
-							"on BYE\n", STR_FMT(to_aor));
+						   "on BYE\n",
+							STR_FMT(to_aor));
 					goto done;
 				}
 			}
@@ -1630,7 +1676,8 @@ static int sca_call_info_bye_handler(sip_msg_t *msg, sca_call_info *call_info,
 
 	rc = 1;
 
-	done: if (slot_idx >= 0) {
+done:
+	if(slot_idx >= 0) {
 		sca_hash_table_unlock_index(sca->appearances, slot_idx);
 	}
 
@@ -1644,36 +1691,38 @@ static int sca_call_info_cancel_handler(sip_msg_t *msg,
 	sca_appearance *app;
 	int rc = 1;
 
-	if (msg->first_line.type != SIP_REQUEST) {
+	if(msg->first_line.type != SIP_REQUEST) {
 		return (1);
 	}
 
 	// Polycom SCA CANCELs as of sip.ld 3.3.4 don't include Call-Info headers;
 	// find appearance by dialog if Call-Info not present.
 	// XXX also handle CANCEL w/ Call-Info header? Some UAs might send it
-	if (SCA_CALL_INFO_IS_SHARED_CALLER(call_info)) {
-		app = sca_appearance_unlink_by_tags(sca, from_aor, &msg->callid->body,
-				&from->tag_value, NULL);
-		if (app) {
+	if(SCA_CALL_INFO_IS_SHARED_CALLER(call_info)) {
+		app = sca_appearance_unlink_by_tags(
+				sca, from_aor, &msg->callid->body, &from->tag_value, NULL);
+		if(app) {
 			sca_appearance_free(app);
 
-			if (sca_notify_call_info_subscribers(sca, from_aor) < 0) {
-				LM_ERR("Failed to call-info NOTIFY %.*s subscribers on CANCEL\n",
+			if(sca_notify_call_info_subscribers(sca, from_aor) < 0) {
+				LM_ERR("Failed to call-info NOTIFY %.*s subscribers on "
+					   "CANCEL\n",
 						STR_FMT(from_aor));
 				rc = -1;
 			}
 		}
 	}
 
-	if (!SCA_STR_EMPTY(&to->tag_value)
+	if(!SCA_STR_EMPTY(&to->tag_value)
 			&& sca_uri_is_shared_appearance(sca, to_aor)) {
-		app = sca_appearance_unlink_by_tags(sca, to_aor, &msg->callid->body,
-				&to->tag_value, NULL);
-		if (app) {
+		app = sca_appearance_unlink_by_tags(
+				sca, to_aor, &msg->callid->body, &to->tag_value, NULL);
+		if(app) {
 			sca_appearance_free(app);
 
-			if (sca_notify_call_info_subscribers(sca, to_aor) < 0) {
-				LM_ERR("Failed to call-info NOTIFY %.*s subscribers on CANCEL\n",
+			if(sca_notify_call_info_subscribers(sca, to_aor) < 0) {
+				LM_ERR("Failed to call-info NOTIFY %.*s subscribers on "
+					   "CANCEL\n",
 						STR_FMT(to_aor));
 				rc = -1;
 			}
@@ -1685,71 +1734,74 @@ static int sca_call_info_cancel_handler(sip_msg_t *msg,
 
 void sca_call_info_sl_reply_cb(void *cb_arg)
 {
-	sl_cbp_t *slcbp = (sl_cbp_t *) cb_arg;
+	sl_cbp_t *slcbp = (sl_cbp_t *)cb_arg;
 	sip_msg_t *msg;
 	struct to_body *from;
 	struct to_body *to;
 	str aor = STR_NULL;
 	str contact_uri = STR_NULL;
 
-	if (slcbp == NULL) {
+	if(slcbp == NULL) {
 		return;
 	}
 
-	if (slcbp->type != SLCB_REPLY_READY) {
+	if(slcbp->type != SLCB_REPLY_READY) {
 		return;
 	}
 
 	// for now, it appears we only need this during INVITEs...
-	if (slcbp->req->REQ_METHOD != METHOD_INVITE) {
+	if(slcbp->req->REQ_METHOD != METHOD_INVITE) {
 		return;
 	}
 
 	// ...and even then only on error
-	if (slcbp->code < 400 || slcbp->code == 401 || slcbp->code == 407) {
+	if(slcbp->code < 400 || slcbp->code == 401 || slcbp->code == 407) {
 		// LM_DBG("sca_call_info_sl_reply_cb: ignoring stateless reply with "
 		//		"status %d %.*s\n", slcbp->code, STR_FMT(slcbp->reason));
 		return;
 	}
 
 	msg = slcbp->req;
-	if (sca_get_msg_from_header(msg, &from) < 0) {
+	if(sca_get_msg_from_header(msg, &from) < 0) {
 		LM_ERR("sca_call_info_sl_reply_cb: failed to get From header from "
-				"request before stateless reply with %d %.*s\n",
+			   "request before stateless reply with %d %.*s\n",
 				slcbp->code, STR_FMT(slcbp->reason));
 		return;
 	}
-	if (sca_uri_extract_aor(&from->uri, &aor) < 0) {
+	if(sca_uri_extract_aor(&from->uri, &aor) < 0) {
 		LM_ERR("sca_call_info_sl_reply_cb: failed to extract AoR "
-				"from URI %.*s\n", STR_FMT(&from->uri));
+			   "from URI %.*s\n",
+				STR_FMT(&from->uri));
 		return;
 	}
 
-	if (!sca_uri_is_shared_appearance(sca, &aor)) {
+	if(!sca_uri_is_shared_appearance(sca, &aor)) {
 		// LM_DBG("sca_call_info_sl_reply_cb: ignoring non-shared appearance "
 		//		"%.*s", STR_FMT(&aor));
 		return;
 	}
 
-	if (sca_get_msg_contact_uri(msg, &contact_uri) < 0) {
+	if(sca_get_msg_contact_uri(msg, &contact_uri) < 0) {
 		LM_ERR("sca_call_info_sl_reply_cb: failed to get Contact from "
-				"request before stateless reply with %d %.*s\n",
+			   "request before stateless reply with %d %.*s\n",
 				slcbp->code, STR_FMT(slcbp->reason));
 		return;
 	}
 
-	if (sca_get_msg_to_header(msg, &to) < 0) {
+	if(sca_get_msg_to_header(msg, &to) < 0) {
 		LM_ERR("sca_call_info_sl_reply_cb: failed to get To header from "
-				"request before stateless reply with %d %.*s\n",
+			   "request before stateless reply with %d %.*s\n",
 				slcbp->code, STR_FMT(slcbp->reason));
 		return;
 	}
 
-	if (sca_subscription_terminate(sca, &aor, SCA_EVENT_TYPE_LINE_SEIZE,
-			&contact_uri, SCA_SUBSCRIPTION_STATE_TERMINATED_NORESOURCE,
-			SCA_SUBSCRIPTION_TERMINATE_OPT_DEFAULT) < 0) {
+	if(sca_subscription_terminate(sca, &aor, SCA_EVENT_TYPE_LINE_SEIZE,
+			   &contact_uri, SCA_SUBSCRIPTION_STATE_TERMINATED_NORESOURCE,
+			   SCA_SUBSCRIPTION_TERMINATE_OPT_DEFAULT)
+			< 0) {
 		LM_ERR("sca_call_info_sl_reply_cb: failed to terminate "
-				"line-seize subscription for %.*s\n", STR_FMT(&contact_uri));
+			   "line-seize subscription for %.*s\n",
+				STR_FMT(&contact_uri));
 		return;
 	}
 }
@@ -1768,7 +1820,8 @@ static inline int sca_call_info_refer_handler(sip_msg_t *msg,
 	return (1);
 }
 
-struct sca_call_info_dispatch {
+struct sca_call_info_dispatch
+{
 	int method;
 	int (*handler)(sip_msg_t *, sca_call_info *, struct to_body *,
 			struct to_body *, str *, str *, str *);
@@ -1782,12 +1835,12 @@ struct sca_call_info_dispatch call_info_dispatch[] = {
 		{METHOD_REFER, sca_call_info_refer_handler},
 };
 
-#define SCA_CALL_INFO_UPDATE_FLAG_DEFAULT	0
-#define SCA_CALL_INFO_UPDATE_FLAG_FROM_ALLOC	(1 << 0)
-#define SCA_CALL_INFO_UPDATE_FLAG_TO_ALLOC	(1 << 1)
+#define SCA_CALL_INFO_UPDATE_FLAG_DEFAULT 0
+#define SCA_CALL_INFO_UPDATE_FLAG_FROM_ALLOC (1 << 0)
+#define SCA_CALL_INFO_UPDATE_FLAG_TO_ALLOC (1 << 1)
 
-int sca_call_info_update(sip_msg_t *msg, int update_mask, str *uri_to,
-		str *uri_from)
+int sca_call_info_update(
+		sip_msg_t *msg, int update_mask, str *uri_to, str *uri_from)
 {
 	sca_call_info call_info;
 	hdr_field_t *call_info_hdr;
@@ -1807,102 +1860,100 @@ int sca_call_info_update(sip_msg_t *msg, int update_mask, str *uri_to,
 	method = sca_get_msg_method(msg);
 
 	n_dispatch = sizeof(call_info_dispatch) / sizeof(call_info_dispatch[0]);
-	for (i = 0; i < n_dispatch; i++) {
-		if (method == call_info_dispatch[i].method) {
+	for(i = 0; i < n_dispatch; i++) {
+		if(method == call_info_dispatch[i].method) {
 			break;
 		}
 	}
-	if (i >= n_dispatch) {
-		if(msg->cseq==NULL && ((parse_headers(msg, HDR_CSEQ_F, 0)==-1) ||
-			(msg->cseq==NULL)))
-		{
+	if(i >= n_dispatch) {
+		if(msg->cseq == NULL
+				&& ((parse_headers(msg, HDR_CSEQ_F, 0) == -1)
+						|| (msg->cseq == NULL))) {
 			LM_ERR("no CSEQ header\n");
 			return (1);
 		}
 		LM_DBG("BUG: sca module does not support Call-Info headers "
-				"in %.*s requests\n", STR_FMT(&get_cseq(msg)->method));
+			   "in %.*s requests\n",
+				STR_FMT(&get_cseq(msg)->method));
 		return (1);
 	}
 
-	if (parse_headers(msg, HDR_EOH_F, 0) < 0) {
+	if(parse_headers(msg, HDR_EOH_F, 0) < 0) {
 		LM_ERR("header parsing failed: bad request\n");
 		return (-1);
 	}
 
-	if (update_mask != SCA_CALL_INFO_SHARED_BOTH) {
-		switch (update_mask) {
-		case SCA_CALL_INFO_SHARED_NONE:
-			update_mask = SCA_CALL_INFO_SHARED_BOTH;
-			break;
+	if(update_mask != SCA_CALL_INFO_SHARED_BOTH) {
+		switch(update_mask) {
+			case SCA_CALL_INFO_SHARED_NONE:
+				update_mask = SCA_CALL_INFO_SHARED_BOTH;
+				break;
 
-		case SCA_CALL_INFO_SHARED_CALLER:
-		case SCA_CALL_INFO_SHARED_CALLEE:
-			break;
+			case SCA_CALL_INFO_SHARED_CALLER:
+			case SCA_CALL_INFO_SHARED_CALLEE:
+				break;
 
-		default:
-			LM_ERR("sca_call_info_update: argument 1: invalid value "
-					"(0, 1 or 2 expected)\n");
-			return (-1);
+			default:
+				LM_ERR("sca_call_info_update: argument 1: invalid value "
+					   "(0, 1 or 2 expected)\n");
+				return (-1);
 		}
 	}
 
 	memset(&call_info, 0, sizeof(sca_call_info));
 	call_info_hdr = get_hdr(msg, HDR_CALLINFO_T);
-	if (!SCA_HEADER_EMPTY(call_info_hdr)) {
+	if(!SCA_HEADER_EMPTY(call_info_hdr)) {
 		// this needs to accomodate comma-separated appearance info
-		if (sca_call_info_body_parse(&call_info_hdr->body, &call_info) < 0) {
+		if(sca_call_info_body_parse(&call_info_hdr->body, &call_info) < 0) {
 			LM_ERR("Bad Call-Info header body: %.*s\n",
 					STR_FMT(&call_info_hdr->body));
 			return (-1);
 		}
 	}
 
-	if (uri_from != NULL) {
-		if(sca_build_to_body_from_uri(msg, &from, uri_from)<0){
+	if(uri_from != NULL) {
+		if(sca_build_to_body_from_uri(msg, &from, uri_from) < 0) {
 			LM_ERR("Bad From uri from param\n");
 			return (-1);
 		}
 		LM_DBG("from[%.*s] param\n", STR_FMT(uri_from));
 		to_body_flags |= SCA_CALL_INFO_UPDATE_FLAG_FROM_ALLOC;
-		if (sca_uri_extract_aor(&from->uri, &from_aor) < 0) {
+		if(sca_uri_extract_aor(&from->uri, &from_aor) < 0) {
 			LM_ERR("Failed to extract AoR from From URI %.*s\n",
 					STR_FMT(&from->uri));
 			goto done;
 		}
-	}
-	else if (sca_get_msg_from_header(msg, &from) < 0) {
+	} else if(sca_get_msg_from_header(msg, &from) < 0) {
 		LM_ERR("Bad From header\n");
 		return (-1);
 	}
-	if (uri_to != NULL) {
-		if(sca_build_to_body_from_uri(msg, &to, uri_to)<0){
+	if(uri_to != NULL) {
+		if(sca_build_to_body_from_uri(msg, &to, uri_to) < 0) {
 			LM_ERR("Bad From uri to param\n");
 			goto done;
 		}
 		LM_DBG("to[%.*s] param\n", STR_FMT(uri_to));
 		to_body_flags |= SCA_CALL_INFO_UPDATE_FLAG_TO_ALLOC;
-		if (sca_uri_extract_aor(&to->uri, &to_aor) < 0) {
+		if(sca_uri_extract_aor(&to->uri, &to_aor) < 0) {
 			LM_ERR("Failed to extract AoR from To URI %.*s\n",
 					STR_FMT(&to->uri));
 			goto done;
 		}
-	}
-	else if (sca_get_msg_to_header(msg, &to) < 0) {
+	} else if(sca_get_msg_to_header(msg, &to) < 0) {
 		LM_ERR("Bad To header\n");
 		goto done;
 	}
 
 	memset(&c_uri, 0, sizeof(sip_uri_t));
 	rc = sca_get_msg_contact_uri(msg, &contact_uri);
-	if (rc > 0) {
+	if(rc > 0) {
 		// Contact header in packet
-		if (parse_uri(contact_uri.s, contact_uri.len, &c_uri) < 0) {
-			LM_ERR("Failed to parse Contact URI %.*s\n",
-					STR_FMT(&contact_uri));
+		if(parse_uri(contact_uri.s, contact_uri.len, &c_uri) < 0) {
+			LM_ERR("Failed to parse Contact URI %.*s\n", STR_FMT(&contact_uri));
 			rc = -1;
 			goto done;
 		}
-	} else if (rc < 0) {
+	} else if(rc < 0) {
 		LM_ERR("Bad Contact\n");
 		goto done;
 	}
@@ -1910,109 +1961,110 @@ int sca_call_info_update(sip_msg_t *msg, int update_mask, str *uri_to,
 	rc = -1;
 
 	// reconcile mismatched Contact users and To/From URIs
-	if (msg->first_line.type == SIP_REQUEST) {
-		if (uri_from==NULL) {
-			if (sca_create_canonical_aor(msg, &from_aor) < 0) {
+	if(msg->first_line.type == SIP_REQUEST) {
+		if(uri_from == NULL) {
+			if(sca_create_canonical_aor(msg, &from_aor) < 0) {
 				goto done;
 			}
 			aor_flags |= SCA_CALL_INFO_UPDATE_FLAG_FROM_ALLOC;
 		}
-		if (uri_to==NULL) {
-			if (sca_uri_extract_aor(&to->uri, &to_aor) < 0) {
+		if(uri_to == NULL) {
+			if(sca_uri_extract_aor(&to->uri, &to_aor) < 0) {
 				LM_ERR("Failed to extract AoR from To URI %.*s\n",
 						STR_FMT(&to->uri));
 				goto done;
 			}
 		}
 	} else {
-		if (uri_from==NULL) {
-			if (sca_uri_extract_aor(&from->uri, &from_aor) < 0) {
+		if(uri_from == NULL) {
+			if(sca_uri_extract_aor(&from->uri, &from_aor) < 0) {
 				LM_ERR("Failed to extract AoR from From URI %.*s\n",
 						STR_FMT(&from->uri));
 				goto done;
 			}
 		}
-		if (uri_to==NULL) {
-			if (sca_create_canonical_aor(msg, &to_aor) < 0) {
+		if(uri_to == NULL) {
+			if(sca_create_canonical_aor(msg, &to_aor) < 0) {
 				goto done;
 			}
 			aor_flags |= SCA_CALL_INFO_UPDATE_FLAG_TO_ALLOC;
 		}
 	}
 
-	LM_DBG("to_aor[%.*s] from_aor[%.*s]\n",
-		STR_FMT(&to_aor), STR_FMT(&from_aor));
+	LM_DBG("to_aor[%.*s] from_aor[%.*s]\n", STR_FMT(&to_aor),
+			STR_FMT(&from_aor));
 
 	// early check to see if we're dealing with any SCA endpoints
-	if (sca_uri_is_shared_appearance(sca, &from_aor)) {
-		if ((update_mask & SCA_CALL_INFO_SHARED_CALLER)) {
+	if(sca_uri_is_shared_appearance(sca, &from_aor)) {
+		if((update_mask & SCA_CALL_INFO_SHARED_CALLER)) {
 			call_info.ua_shared |= SCA_CALL_INFO_SHARED_CALLER;
 		}
 	}
-	if (sca_uri_is_shared_appearance(sca, &to_aor)) {
-		if ((update_mask & SCA_CALL_INFO_SHARED_CALLEE)) {
+	if(sca_uri_is_shared_appearance(sca, &to_aor)) {
+		if((update_mask & SCA_CALL_INFO_SHARED_CALLEE)) {
 			call_info.ua_shared |= SCA_CALL_INFO_SHARED_CALLEE;
 		}
 	}
 
-	if (call_info_hdr == NULL) {
-		if (SCA_CALL_INFO_IS_SHARED_CALLER(&call_info) &&
-		msg->first_line.type == SIP_REQUEST) {
-			if (!sca_subscription_aor_has_subscribers(SCA_EVENT_TYPE_CALL_INFO,
-					&from_aor)) {
+	if(call_info_hdr == NULL) {
+		if(SCA_CALL_INFO_IS_SHARED_CALLER(&call_info)
+				&& msg->first_line.type == SIP_REQUEST) {
+			if(!sca_subscription_aor_has_subscribers(
+					   SCA_EVENT_TYPE_CALL_INFO, &from_aor)) {
 				call_info.ua_shared &= ~SCA_CALL_INFO_SHARED_CALLER;
 				sca_appearance_unregister(sca, &from_aor);
 			}
-		} else if (SCA_CALL_INFO_IS_SHARED_CALLEE(&call_info) &&
-		msg->first_line.type == SIP_REPLY) {
-			if (!sca_subscription_aor_has_subscribers(SCA_EVENT_TYPE_CALL_INFO,
-					&to_aor)) {
+		} else if(SCA_CALL_INFO_IS_SHARED_CALLEE(&call_info)
+				  && msg->first_line.type == SIP_REPLY) {
+			if(!sca_subscription_aor_has_subscribers(
+					   SCA_EVENT_TYPE_CALL_INFO, &to_aor)) {
 				call_info.ua_shared &= ~SCA_CALL_INFO_SHARED_CALLEE;
 				sca_appearance_unregister(sca, &to_aor);
 			}
 		}
 	}
 
-	if (sca_call_info_header_remove(msg) < 0) {
+	if(sca_call_info_header_remove(msg) < 0) {
 		LM_ERR("Failed to remove Call-Info header\n");
 		goto done;
 	}
 
-	if (call_info.ua_shared == SCA_CALL_INFO_SHARED_NONE) {
-		LM_DBG("Neither %.*s nor %.*s are SCA AoRs\n",
-				STR_FMT(&from_aor), STR_FMT(&to_aor));
+	if(call_info.ua_shared == SCA_CALL_INFO_SHARED_NONE) {
+		LM_DBG("Neither %.*s nor %.*s are SCA AoRs\n", STR_FMT(&from_aor),
+				STR_FMT(&to_aor));
 		goto done;
 	}
 
-	LM_DBG( "Calling Dispatch Id: %d handler with From-AOR: %.*s To-AOR: %.*s "
-			"From-URI: <%.*s> To-URI: <%.*s> Contact-URI: <%.*s>\n",
-			i, STR_FMT(&from_aor), STR_FMT(&to_aor),STR_FMT(&from->uri),
+	LM_DBG("Calling Dispatch Id: %d handler with From-AOR: %.*s To-AOR: %.*s "
+		   "From-URI: <%.*s> To-URI: <%.*s> Contact-URI: <%.*s>\n",
+			i, STR_FMT(&from_aor), STR_FMT(&to_aor), STR_FMT(&from->uri),
 			STR_FMT(&to->uri), STR_FMT(&contact_uri));
 
-	rc = call_info_dispatch[i].handler(msg, &call_info, from, to, &from_aor,
-			&to_aor, &contact_uri);
-	if (rc < 0) {
+	rc = call_info_dispatch[i].handler(
+			msg, &call_info, from, to, &from_aor, &to_aor, &contact_uri);
+	if(rc < 0) {
 		LM_ERR("Failed to update Call-Info state for %.*s\n",
 				STR_FMT(&contact_uri));
 	}
 
-	done: if ((aor_flags & SCA_CALL_INFO_UPDATE_FLAG_FROM_ALLOC)) {
-		if (from_aor.s != NULL) {
+done:
+	if((aor_flags & SCA_CALL_INFO_UPDATE_FLAG_FROM_ALLOC)) {
+		if(from_aor.s != NULL) {
 			pkg_free(from_aor.s);
 		}
 	}
-	if ((aor_flags & SCA_CALL_INFO_UPDATE_FLAG_TO_ALLOC)) {
-		if (to_aor.s != NULL) {
+	if((aor_flags & SCA_CALL_INFO_UPDATE_FLAG_TO_ALLOC)) {
+		if(to_aor.s != NULL) {
 			pkg_free(to_aor.s);
 		}
 	}
-	if ((to_body_flags & SCA_CALL_INFO_UPDATE_FLAG_FROM_ALLOC)) {
-		if (from != NULL) {
+	if((to_body_flags & SCA_CALL_INFO_UPDATE_FLAG_FROM_ALLOC)) {
+		if(from != NULL) {
 			free_to(from);
 		}
 	}
-	if ((to_body_flags & SCA_CALL_INFO_UPDATE_FLAG_TO_ALLOC)) {
-		if (to != NULL) {
+	if((to_body_flags & SCA_CALL_INFO_UPDATE_FLAG_TO_ALLOC)) {
+		if(to != NULL) {
 			free_to(to);
 		}
 	}
diff --git a/src/modules/sca/sca_call_info.h b/src/modules/sca/sca_call_info.h
index f12bceb..914f36f 100644
--- a/src/modules/sca/sca_call_info.h
+++ b/src/modules/sca/sca_call_info.h
@@ -24,9 +24,10 @@
 #include "sca_subscribe.h"
 
 // pass to sca_notify_subscriber to include all appearances in Call-Info hdr
-#define SCA_CALL_INFO_APPEARANCE_INDEX_ANY	0
+#define SCA_CALL_INFO_APPEARANCE_INDEX_ANY 0
 
-enum {
+enum
+{
 	SCA_CALL_INFO_SHARED_NONE = 0,
 	SCA_CALL_INFO_SHARED_CALLER = (1 << 0),
 	SCA_CALL_INFO_SHARED_CALLEE = (1 << 1),
@@ -34,7 +35,8 @@ enum {
 #define SCA_CALL_INFO_SHARED_BOTH \
 	(SCA_CALL_INFO_SHARED_CALLER | SCA_CALL_INFO_SHARED_CALLEE)
 
-struct _sca_call_info {
+struct _sca_call_info
+{
 	str sca_uri;
 	int index;
 	int state;
@@ -44,28 +46,30 @@ struct _sca_call_info {
 };
 typedef struct _sca_call_info sca_call_info;
 
-#define SCA_CALL_INFO_EMPTY(ci1) \
-	((void*)(ci1) == NULL || \
-		((ci1)->index == SCA_CALL_INFO_APPEARANCE_INDEX_ANY && \
-		(ci1)->state == SCA_APPEARANCE_STATE_UNKNOWN))
+#define SCA_CALL_INFO_EMPTY(ci1)                                   \
+	((void *)(ci1) == NULL                                         \
+			|| ((ci1)->index == SCA_CALL_INFO_APPEARANCE_INDEX_ANY \
+					&& (ci1)->state == SCA_APPEARANCE_STATE_UNKNOWN))
 
-#define SCA_CALL_INFO_IS_SHARED_CALLER(ci1) \
-	(!SCA_CALL_INFO_EMPTY((ci1)) && \
-	(((sca_call_info *)(ci1))->ua_shared & SCA_CALL_INFO_SHARED_CALLER))
+#define SCA_CALL_INFO_IS_SHARED_CALLER(ci1)         \
+	(!SCA_CALL_INFO_EMPTY((ci1))                    \
+			&& (((sca_call_info *)(ci1))->ua_shared \
+					& SCA_CALL_INFO_SHARED_CALLER))
 
-#define SCA_CALL_INFO_IS_SHARED_CALLEE(ci1) \
-	(!SCA_CALL_INFO_EMPTY((ci1)) && \
-	(((sca_call_info *)(ci1))->ua_shared & SCA_CALL_INFO_SHARED_CALLEE))
+#define SCA_CALL_INFO_IS_SHARED_CALLEE(ci1)         \
+	(!SCA_CALL_INFO_EMPTY((ci1))                    \
+			&& (((sca_call_info *)(ci1))->ua_shared \
+					& SCA_CALL_INFO_SHARED_CALLEE))
 
 extern const str SCA_CALL_INFO_HEADER_STR;
 
-int sca_call_info_update(sip_msg_t *, int, str*, str*);
+int sca_call_info_update(sip_msg_t *, int, str *, str *);
 void sca_call_info_sl_reply_cb(void *);
 void sca_call_info_ack_cb(struct cell *, int, struct tmcb_params *);
 
 int sca_call_info_build_header(sca_mod *, sca_subscription *, char *, int);
-int sca_call_info_append_header_for_appearance_index(sca_subscription *, int,
-		char *, int);
+int sca_call_info_append_header_for_appearance_index(
+		sca_subscription *, int, char *, int);
 
 int sca_call_info_body_parse(str *, sca_call_info *);
 int sca_call_info_free(sca_call_info *);
diff --git a/src/modules/sca/sca_common.h b/src/modules/sca/sca_common.h
index acf967b..5c4520a 100644
--- a/src/modules/sca/sca_common.h
+++ b/src/modules/sca/sca_common.h
@@ -52,45 +52,43 @@
 #define SCA_STRUCT_PTR_OFFSET(struct1, cast1, offset1) \
 	(cast1)(struct1) + (offset1)
 
-#define SCA_STR_COPY(str1, str2) \
+#define SCA_STR_COPY(str1, str2)               \
 	memcpy((str1)->s, (str2)->s, (str2)->len); \
 	(str1)->len = (str2)->len;
 
-#define SCA_STR_APPEND(str1, str2) \
+#define SCA_STR_APPEND(str1, str2)                           \
 	memcpy((str1)->s + (str1)->len, (str2)->s, (str2)->len); \
 	(str1)->len += (str2)->len;
 
-#define SCA_STR_APPEND_L(str1, str1_lim, s2, s2_len) \
-	if ((str1)->len + (s2_len) >= (str1_lim)) { \
+#define SCA_STR_APPEND_L(str1, str1_lim, s2, s2_len)   \
+	if((str1)->len + (s2_len) >= (str1_lim)) {         \
 		LM_ERR("Failed to append to str: too long\n"); \
-	} else { \
-		SCA_STR_APPEND((str1), (s2), (s2_len)); \
-		(str1_lim) -= (s2_len); \
+	} else {                                           \
+		SCA_STR_APPEND((str1), (s2), (s2_len));        \
+		(str1_lim) -= (s2_len);                        \
 	}
 
-#define SCA_STR_COPY_CSTR(str1, cstr1) \
+#define SCA_STR_COPY_CSTR(str1, cstr1)                         \
 	memcpy((str1)->s + (str1)->len, (cstr1), strlen((cstr1))); \
 	(str1)->len += strlen((cstr1));
 
-#define SCA_STR_APPEND_CSTR(str1, cstr1) \
-	SCA_STR_COPY_CSTR((str1), (cstr1))
+#define SCA_STR_APPEND_CSTR(str1, cstr1) SCA_STR_COPY_CSTR((str1), (cstr1))
 
-#define SCA_STR_APPEND_CSTR_L(str1, str1_lim, cstr1) \
-	if ((str1)->len + strlen(cstr1) >= (str1_lim)) { \
+#define SCA_STR_APPEND_CSTR_L(str1, str1_lim, cstr1)   \
+	if((str1)->len + strlen(cstr1) >= (str1_lim)) {    \
 		LM_ERR("Failed to append to str: too long\n"); \
-	} else { \
-		SCA_STR_APPEND_CSTR((str1), (cstr1)); \
+	} else {                                           \
+		SCA_STR_APPEND_CSTR((str1), (cstr1));          \
 	}
 
 // STR_EQ assumes we're not using str pointers, which is obnoxious
-#define SCA_STR_EQ(str1, str2) \
-	(((str1)->len == (str2)->len) && \
-		memcmp((str1)->s, (str2)->s, (str1)->len) == 0)
+#define SCA_STR_EQ(str1, str2)    \
+	(((str1)->len == (str2)->len) \
+			&& memcmp((str1)->s, (str2)->s, (str1)->len) == 0)
 
 #define SCA_STR_EMPTY(str1) \
 	((str1) == NULL || ((str1)->s == NULL || (str1)->len <= 0))
 
-#define SCA_HEADER_EMPTY(hdr1) \
-	((hdr1) == NULL || SCA_STR_EMPTY(&(hdr1)->body))
+#define SCA_HEADER_EMPTY(hdr1) ((hdr1) == NULL || SCA_STR_EMPTY(&(hdr1)->body))
 
 #endif // SCA_COMMON_H
diff --git a/src/modules/sca/sca_db.c b/src/modules/sca/sca_db.c
index ce40d9a..2dc107b 100644
--- a/src/modules/sca/sca_db.c
+++ b/src/modules/sca/sca_db.c
@@ -38,102 +38,103 @@ const str SCA_DB_NOTIFY_CSEQ_COL_NAME = STR_STATIC_INIT("notify_cseq");
 const str SCA_DB_SUBSCRIBE_CSEQ_COL_NAME = STR_STATIC_INIT("subscribe_cseq");
 const str SCA_DB_SERVER_ID_COL_NAME = STR_STATIC_INIT("server_id");
 
-void sca_db_subscriptions_get_value_for_column(int column, db_val_t *row_values,
-		void *column_value)
+void sca_db_subscriptions_get_value_for_column(
+		int column, db_val_t *row_values, void *column_value)
 {
 	assert(column_value != NULL);
 	assert(row_values != NULL);
 	assert(column >= 0 && column < SCA_DB_SUBS_BOUNDARY);
 
-	switch (column) {
-	case SCA_DB_SUBS_SUBSCRIBER_COL:
-	case SCA_DB_SUBS_AOR_COL:
-	case SCA_DB_SUBS_CALL_ID_COL:
-	case SCA_DB_SUBS_FROM_TAG_COL:
-	case SCA_DB_SUBS_TO_TAG_COL:
-	case SCA_DB_SUBS_RECORD_ROUTE_COL:
-		((str *) column_value)->s = (char *) row_values[column].val.string_val;
-		((str *) column_value)->len = strlen(((str *) column_value)->s);
-		break;
-
-	case SCA_DB_SUBS_EXPIRES_COL:
-		*((time_t *) column_value) = row_values[column].val.time_val;
-		break;
-
-	case SCA_DB_SUBS_EVENT_COL:
-	case SCA_DB_SUBS_STATE_COL:
-	case SCA_DB_SUBS_NOTIFY_CSEQ_COL:
-	case SCA_DB_SUBS_SUBSCRIBE_CSEQ_COL:
-	case SCA_DB_SUBS_SERVER_ID_COL:
-		*((int *) column_value) = row_values[column].val.int_val;
-		break;
-
-	default:
-		column_value = NULL;
+	switch(column) {
+		case SCA_DB_SUBS_SUBSCRIBER_COL:
+		case SCA_DB_SUBS_AOR_COL:
+		case SCA_DB_SUBS_CALL_ID_COL:
+		case SCA_DB_SUBS_FROM_TAG_COL:
+		case SCA_DB_SUBS_TO_TAG_COL:
+		case SCA_DB_SUBS_RECORD_ROUTE_COL:
+			((str *)column_value)->s =
+					(char *)row_values[column].val.string_val;
+			((str *)column_value)->len = strlen(((str *)column_value)->s);
+			break;
+
+		case SCA_DB_SUBS_EXPIRES_COL:
+			*((time_t *)column_value) = row_values[column].val.time_val;
+			break;
+
+		case SCA_DB_SUBS_EVENT_COL:
+		case SCA_DB_SUBS_STATE_COL:
+		case SCA_DB_SUBS_NOTIFY_CSEQ_COL:
+		case SCA_DB_SUBS_SUBSCRIBE_CSEQ_COL:
+		case SCA_DB_SUBS_SERVER_ID_COL:
+			*((int *)column_value) = row_values[column].val.int_val;
+			break;
+
+		default:
+			column_value = NULL;
 	}
 }
 
-void sca_db_subscriptions_set_value_for_column(int column, db_val_t *row_values,
-		void *column_value)
+void sca_db_subscriptions_set_value_for_column(
+		int column, db_val_t *row_values, void *column_value)
 {
 	assert(column >= 0 && column < SCA_DB_SUBS_BOUNDARY);
 	assert(column_value != NULL);
 	assert(row_values != NULL);
 
-	switch (column) {
-	case SCA_DB_SUBS_SUBSCRIBER_COL:
-	case SCA_DB_SUBS_AOR_COL:
-	case SCA_DB_SUBS_CALL_ID_COL:
-	case SCA_DB_SUBS_FROM_TAG_COL:
-	case SCA_DB_SUBS_TO_TAG_COL:
-	case SCA_DB_SUBS_RECORD_ROUTE_COL:
-		row_values[column].val.str_val = *((str *) column_value);
-		row_values[column].type = DB1_STR;
-		row_values[column].nul = 0;
-		break;
-
-	case SCA_DB_SUBS_EXPIRES_COL:
-		row_values[column].val.int_val = (int) (*((time_t *) column_value));
-		row_values[column].type = DB1_INT;
-		row_values[column].nul = 0;
-		break;
-
-	case SCA_DB_SUBS_APP_IDX_COL:
-		// for now, don't save appearance index associated with subscriber
-		row_values[column].val.int_val = 0;
-		row_values[column].type = DB1_INT;
-		row_values[column].nul = 0;
-		break;
-
-	default:
-		LM_WARN("sca_db_subscriptions_set_value_for_column: unrecognized "
-				"column index %d, treating as INT\n", column);
-		// fall through
-
-	case SCA_DB_SUBS_EVENT_COL:
-	case SCA_DB_SUBS_STATE_COL:
-	case SCA_DB_SUBS_NOTIFY_CSEQ_COL:
-	case SCA_DB_SUBS_SUBSCRIBE_CSEQ_COL:
-	case SCA_DB_SUBS_SERVER_ID_COL:
-		row_values[column].val.int_val = *((int *) column_value);
-		row_values[column].type = DB1_INT;
-		row_values[column].nul = 0;
-		break;
+	switch(column) {
+		case SCA_DB_SUBS_SUBSCRIBER_COL:
+		case SCA_DB_SUBS_AOR_COL:
+		case SCA_DB_SUBS_CALL_ID_COL:
+		case SCA_DB_SUBS_FROM_TAG_COL:
+		case SCA_DB_SUBS_TO_TAG_COL:
+		case SCA_DB_SUBS_RECORD_ROUTE_COL:
+			row_values[column].val.str_val = *((str *)column_value);
+			row_values[column].type = DB1_STR;
+			row_values[column].nul = 0;
+			break;
+
+		case SCA_DB_SUBS_EXPIRES_COL:
+			row_values[column].val.int_val = (int)(*((time_t *)column_value));
+			row_values[column].type = DB1_INT;
+			row_values[column].nul = 0;
+			break;
+
+		case SCA_DB_SUBS_APP_IDX_COL:
+			// for now, don't save appearance index associated with subscriber
+			row_values[column].val.int_val = 0;
+			row_values[column].type = DB1_INT;
+			row_values[column].nul = 0;
+			break;
+
+		default:
+			LM_WARN("sca_db_subscriptions_set_value_for_column: unrecognized "
+					"column index %d, treating as INT\n",
+					column);
+			// fall through
+
+		case SCA_DB_SUBS_EVENT_COL:
+		case SCA_DB_SUBS_STATE_COL:
+		case SCA_DB_SUBS_NOTIFY_CSEQ_COL:
+		case SCA_DB_SUBS_SUBSCRIBE_CSEQ_COL:
+		case SCA_DB_SUBS_SERVER_ID_COL:
+			row_values[column].val.int_val = *((int *)column_value);
+			row_values[column].type = DB1_INT;
+			row_values[column].nul = 0;
+			break;
 	}
 }
 
 str **sca_db_subscriptions_columns(void)
 {
-	static str *subs_columns[] = {(str *) &SCA_DB_SUBSCRIBER_COL_NAME,
-			(str *) &SCA_DB_AOR_COL_NAME, (str *) &SCA_DB_EVENT_COL_NAME,
-			(str *) &SCA_DB_EXPIRES_COL_NAME, (str *) &SCA_DB_STATE_COL_NAME,
-			(str *) &SCA_DB_APP_IDX_COL_NAME, (str *) &SCA_DB_CALL_ID_COL_NAME,
-			(str *) &SCA_DB_FROM_TAG_COL_NAME, (str *) &SCA_DB_TO_TAG_COL_NAME,
-			(str *) &SCA_DB_RECORD_ROUTE_COL_NAME,
-			(str *) &SCA_DB_NOTIFY_CSEQ_COL_NAME,
-			(str *) &SCA_DB_SUBSCRIBE_CSEQ_COL_NAME,
-			(str *) &SCA_DB_SERVER_ID_COL_NAME,
-			NULL};
+	static str *subs_columns[] = {(str *)&SCA_DB_SUBSCRIBER_COL_NAME,
+			(str *)&SCA_DB_AOR_COL_NAME, (str *)&SCA_DB_EVENT_COL_NAME,
+			(str *)&SCA_DB_EXPIRES_COL_NAME, (str *)&SCA_DB_STATE_COL_NAME,
+			(str *)&SCA_DB_APP_IDX_COL_NAME, (str *)&SCA_DB_CALL_ID_COL_NAME,
+			(str *)&SCA_DB_FROM_TAG_COL_NAME, (str *)&SCA_DB_TO_TAG_COL_NAME,
+			(str *)&SCA_DB_RECORD_ROUTE_COL_NAME,
+			(str *)&SCA_DB_NOTIFY_CSEQ_COL_NAME,
+			(str *)&SCA_DB_SUBSCRIBE_CSEQ_COL_NAME,
+			(str *)&SCA_DB_SERVER_ID_COL_NAME, NULL};
 
 	return (subs_columns);
 }
@@ -143,7 +144,7 @@ db1_con_t *sca_db_get_connection(void)
 	assert(sca && sca->cfg->db_url);
 	assert(sca->db_api && sca->db_api->init);
 
-	if (sca_db_con == NULL) {
+	if(sca_db_con == NULL) {
 		sca_db_con = sca->db_api->init(sca->cfg->db_url);
 		// catch connection error in caller
 	}
@@ -151,8 +152,9 @@ db1_con_t *sca_db_get_connection(void)
 	return (sca_db_con);
 }
 
-void sca_db_disconnect(void) {
-	if (sca_db_con != NULL) {
+void sca_db_disconnect(void)
+{
+	if(sca_db_con != NULL) {
 		sca->db_api->close(sca_db_con);
 		sca_db_con = NULL;
 	}
diff --git a/src/modules/sca/sca_db.h b/src/modules/sca/sca_db.h
index 22f8349..89e47fc 100644
--- a/src/modules/sca/sca_db.h
+++ b/src/modules/sca/sca_db.h
@@ -22,13 +22,14 @@
 
 #include "../../lib/srdb1/db.h"
 
-#define SCA_DB_SUBSCRIPTIONS_TABLE_VERSION	2
+#define SCA_DB_SUBSCRIPTIONS_TABLE_VERSION 2
 
-#define SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS	13
+#define SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS 13
 
-#define SCA_DB_DEFAULT_FETCH_ROW_COUNT		1000
+#define SCA_DB_DEFAULT_FETCH_ROW_COUNT 1000
 
-enum {
+enum
+{
 	SCA_DB_SUBS_SUBSCRIBER_COL = 0,
 	SCA_DB_SUBS_AOR_COL = 1,
 	SCA_DB_SUBS_EVENT_COL,
@@ -46,25 +47,26 @@ enum {
 	SCA_DB_SUBS_BOUNDARY,
 };
 
-enum {
+enum
+{
 	SCA_DB_FLAG_NONE = 0,
 	SCA_DB_FLAG_INSERT = 1,
 	SCA_DB_FLAG_UPDATE,
 	SCA_DB_FLAG_DELETE,
 };
 
-#define SCA_DB_BIND_STR_VALUE(cv, ct, k, v, c) \
-	((db_key_t *)(k))[ (c) ] = (str *)(ct); \
-	((db_val_t *)(v))[ (c) ].type = DB1_STR; \
-	((db_val_t *)(v))[ (c) ].nul = 0; \
-	((db_val_t *)(v))[ (c) ].val.str_val = (str)(cv); \
+#define SCA_DB_BIND_STR_VALUE(cv, ct, k, v, c)      \
+	((db_key_t *)(k))[(c)] = (str *)(ct);           \
+	((db_val_t *)(v))[(c)].type = DB1_STR;          \
+	((db_val_t *)(v))[(c)].nul = 0;                 \
+	((db_val_t *)(v))[(c)].val.str_val = (str)(cv); \
 	(c)++;
 
-#define SCA_DB_BIND_INT_VALUE(cv, ct, k, v, c) \
-	((db_key_t *)(k))[ (c) ] = (str *)(ct); \
-	((db_val_t *)(v))[ (c) ].type = DB1_INT; \
-	((db_val_t *)(v))[ (c) ].nul = 0; \
-	((db_val_t *)(v))[ (c) ].val.int_val = (int)(cv); \
+#define SCA_DB_BIND_INT_VALUE(cv, ct, k, v, c)      \
+	((db_key_t *)(k))[(c)] = (str *)(ct);           \
+	((db_val_t *)(v))[(c)].type = DB1_INT;          \
+	((db_val_t *)(v))[(c)].nul = 0;                 \
+	((db_val_t *)(v))[(c)].val.int_val = (int)(cv); \
 	(c)++;
 
 extern const str SCA_DB_SUBSCRIBER_COL_NAME;
diff --git a/src/modules/sca/sca_dialog.c b/src/modules/sca/sca_dialog.c
index a5e6924..1076caa 100644
--- a/src/modules/sca/sca_dialog.c
+++ b/src/modules/sca/sca_dialog.c
@@ -32,15 +32,15 @@ int sca_dialog_build_from_tags(sca_dialog *dialog, int maxlen, str *call_id,
 	assert(call_id != NULL);
 	assert(from_tag != NULL);
 
-	LM_DBG( "From-Tag: %.*s To-Tag: %.*s CallId: %.*s\n",
-			STR_FMT(from_tag), STR_FMT(to_tag), STR_FMT(call_id));
+	LM_DBG("From-Tag: %.*s To-Tag: %.*s CallId: %.*s\n", STR_FMT(from_tag),
+			STR_FMT(to_tag), STR_FMT(call_id));
 
 	len = call_id->len + from_tag->len;
-	if (!SCA_STR_EMPTY(to_tag)) {
+	if(!SCA_STR_EMPTY(to_tag)) {
 		len += to_tag->len;
 	}
 
-	if (len >= maxlen) {
+	if(len >= maxlen) {
 		LM_ERR("sca_dialog_build_from_tags: tags too long\n");
 		return (-1);
 	}
@@ -53,7 +53,7 @@ int sca_dialog_build_from_tags(sca_dialog *dialog, int maxlen, str *call_id,
 	dialog->from_tag.s = dialog->id.s + call_id->len;
 	dialog->from_tag.len = from_tag->len;
 
-	if (!SCA_STR_EMPTY(to_tag)) {
+	if(!SCA_STR_EMPTY(to_tag)) {
 		memcpy(dialog->id.s + call_id->len + from_tag->len, to_tag->s,
 				to_tag->len);
 		dialog->to_tag.s = dialog->id.s + call_id->len + from_tag->len;
@@ -64,12 +64,12 @@ int sca_dialog_build_from_tags(sca_dialog *dialog, int maxlen, str *call_id,
 	return (len);
 }
 
-#define SCA_REPLACES_HDR_PREFIX		"Replaces: "
-#define SCA_REPLACES_HDR_PREFIX_LEN	strlen(SCA_REPLACES_HDR_PREFIX)
-#define SCA_REPLACES_TO_TAG		"to-tag="
-#define SCA_REPLACES_TO_TAG_LEN		strlen(SCA_REPLACES_TO_TAG)
-#define SCA_REPLACES_FROM_TAG		"from-tag="
-#define SCA_REPLACES_FROM_TAG_LEN	strlen(SCA_REPLACES_FROM_TAG)
+#define SCA_REPLACES_HDR_PREFIX "Replaces: "
+#define SCA_REPLACES_HDR_PREFIX_LEN strlen(SCA_REPLACES_HDR_PREFIX)
+#define SCA_REPLACES_TO_TAG "to-tag="
+#define SCA_REPLACES_TO_TAG_LEN strlen(SCA_REPLACES_TO_TAG)
+#define SCA_REPLACES_FROM_TAG "from-tag="
+#define SCA_REPLACES_FROM_TAG_LEN strlen(SCA_REPLACES_FROM_TAG)
 
 int sca_dialog_create_replaces_header(sca_dialog *dlg, str *replaces_hdr)
 {
@@ -77,12 +77,12 @@ int sca_dialog_create_replaces_header(sca_dialog *dlg, str *replaces_hdr)
 
 	assert(replaces_hdr != NULL);
 
-	LM_DBG( "Called\n" );
+	LM_DBG("Called\n");
 
-	if (SCA_STR_EMPTY(&dlg->call_id) || SCA_STR_EMPTY(&dlg->from_tag) ||
-	SCA_STR_EMPTY(&dlg->to_tag)) {
+	if(SCA_STR_EMPTY(&dlg->call_id) || SCA_STR_EMPTY(&dlg->from_tag)
+			|| SCA_STR_EMPTY(&dlg->to_tag)) {
 		LM_ERR("sca_dialog_create_replaces_header: dialog %.*s is not a "
-				"confirmed dialog, cannot build Replaces header\n",
+			   "confirmed dialog, cannot build Replaces header\n",
 				STR_FMT(&dlg->id));
 		return (-1);
 	}
@@ -91,11 +91,11 @@ int sca_dialog_create_replaces_header(sca_dialog *dlg, str *replaces_hdr)
 
 	// +2 for semicolons separating tags, +2 for CRLF
 	replaces_hdr->s =
-			pkg_malloc(
-					SCA_REPLACES_HDR_PREFIX_LEN + SCA_REPLACES_TO_TAG_LEN + SCA_REPLACES_FROM_TAG_LEN + dlg->id.len + 2 + 2);
+			pkg_malloc(SCA_REPLACES_HDR_PREFIX_LEN + SCA_REPLACES_TO_TAG_LEN
+					   + SCA_REPLACES_FROM_TAG_LEN + dlg->id.len + 2 + 2);
 
 	memcpy(replaces_hdr->s, SCA_REPLACES_HDR_PREFIX,
-	SCA_REPLACES_HDR_PREFIX_LEN);
+			SCA_REPLACES_HDR_PREFIX_LEN);
 	len = SCA_REPLACES_HDR_PREFIX_LEN;
 
 	memcpy(replaces_hdr->s + len, dlg->call_id.s, dlg->call_id.len);
@@ -104,8 +104,7 @@ int sca_dialog_create_replaces_header(sca_dialog *dlg, str *replaces_hdr)
 	memcpy(replaces_hdr->s + len, ";", strlen(";"));
 	len += strlen(";");
 
-	memcpy(replaces_hdr->s + len, SCA_REPLACES_TO_TAG,
-	SCA_REPLACES_TO_TAG_LEN);
+	memcpy(replaces_hdr->s + len, SCA_REPLACES_TO_TAG, SCA_REPLACES_TO_TAG_LEN);
 	len += SCA_REPLACES_TO_TAG_LEN;
 	memcpy(replaces_hdr->s + len, dlg->to_tag.s, dlg->to_tag.len);
 	len += dlg->to_tag.len;
@@ -114,7 +113,7 @@ int sca_dialog_create_replaces_header(sca_dialog *dlg, str *replaces_hdr)
 	len += strlen(";");
 
 	memcpy(replaces_hdr->s + len, SCA_REPLACES_FROM_TAG,
-	SCA_REPLACES_FROM_TAG_LEN);
+			SCA_REPLACES_FROM_TAG_LEN);
 	len += SCA_REPLACES_FROM_TAG_LEN;
 	memcpy(replaces_hdr->s + len, dlg->from_tag.s, dlg->from_tag.len);
 	len += dlg->from_tag.len;
diff --git a/src/modules/sca/sca_dialog.h b/src/modules/sca/sca_dialog.h
index 77bc6f3..d308954 100644
--- a/src/modules/sca/sca_dialog.h
+++ b/src/modules/sca/sca_dialog.h
@@ -20,7 +20,8 @@
 #ifndef SCA_DIALOG_H
 #define SCA_DIALOG_H
 
-struct _sca_dialog {
+struct _sca_dialog
+{
 	str id; // call-id + from-tag + to-tag
 	str call_id;
 	str from_tag;
@@ -31,10 +32,10 @@ struct _sca_dialog {
 };
 typedef struct _sca_dialog sca_dialog;
 
-#define SCA_DIALOG_EMPTY(d) \
-	((d) == NULL || (SCA_STR_EMPTY(&(d)->call_id) && \
-			SCA_STR_EMPTY(&(d)->from_tag) && \
-			SCA_STR_EMPTY(&(d)->to_tag)))
+#define SCA_DIALOG_EMPTY(d)                                                   \
+	((d) == NULL                                                              \
+			|| (SCA_STR_EMPTY(&(d)->call_id) && SCA_STR_EMPTY(&(d)->from_tag) \
+					&& SCA_STR_EMPTY(&(d)->to_tag)))
 
 int sca_dialog_build_from_tags(sca_dialog *, int, str *, str *, str *);
 int sca_dialog_create_replaces_header(sca_dialog *, str *);
diff --git a/src/modules/sca/sca_event.c b/src/modules/sca/sca_event.c
index ac691b5..5daa301 100644
--- a/src/modules/sca/sca_event.c
+++ b/src/modules/sca/sca_event.c
@@ -28,13 +28,13 @@ int sca_event_from_str(str *event_str)
 {
 	int event = SCA_EVENT_TYPE_UNKNOWN;
 
-	if (event_str == NULL || event_str->s == NULL) {
+	if(event_str == NULL || event_str->s == NULL) {
 		return (SCA_EVENT_TYPE_UNKNOWN);
 	}
 
-	if (STR_EQ(*event_str, SCA_EVENT_NAME_CALL_INFO)) {
+	if(STR_EQ(*event_str, SCA_EVENT_NAME_CALL_INFO)) {
 		event = SCA_EVENT_TYPE_CALL_INFO;
-	} else if (STR_EQ(*event_str, SCA_EVENT_NAME_LINE_SEIZE)) {
+	} else if(STR_EQ(*event_str, SCA_EVENT_NAME_LINE_SEIZE)) {
 		event = SCA_EVENT_TYPE_LINE_SEIZE;
 	}
 
@@ -43,15 +43,15 @@ int sca_event_from_str(str *event_str)
 
 char *sca_event_name_from_type(int event_type)
 {
-	switch (event_type) {
-	case SCA_EVENT_TYPE_CALL_INFO:
-		return (SCA_EVENT_NAME_CALL_INFO.s);
+	switch(event_type) {
+		case SCA_EVENT_TYPE_CALL_INFO:
+			return (SCA_EVENT_NAME_CALL_INFO.s);
 
-	case SCA_EVENT_TYPE_LINE_SEIZE:
-		return (SCA_EVENT_NAME_LINE_SEIZE.s);
+		case SCA_EVENT_TYPE_LINE_SEIZE:
+			return (SCA_EVENT_NAME_LINE_SEIZE.s);
 
-	default:
-		break;
+		default:
+			break;
 	}
 
 	return ("unknown");
@@ -63,7 +63,7 @@ int sca_event_append_header_for_type(int event_type, char *hdrbuf, int maxlen)
 
 	len = snprintf(hdrbuf, maxlen, "Event: %s%s",
 			sca_event_name_from_type(event_type), CRLF);
-	if (len >= maxlen) {
+	if(len >= maxlen) {
 		LM_ERR("%s Event header too long\n",
 				sca_event_name_from_type(event_type));
 		return (-1);
diff --git a/src/modules/sca/sca_event.h b/src/modules/sca/sca_event.h
index 0baae6b..f03fe69 100644
--- a/src/modules/sca/sca_event.h
+++ b/src/modules/sca/sca_event.h
@@ -17,7 +17,8 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA. 02110-1301 USA
  */
-enum {
+enum
+{
 	SCA_EVENT_TYPE_UNKNOWN = -1,
 	SCA_EVENT_TYPE_CALL_INFO = 1,
 	SCA_EVENT_TYPE_LINE_SEIZE = 2,
@@ -26,8 +27,7 @@ enum {
 extern str SCA_EVENT_NAME_CALL_INFO;
 extern str SCA_EVENT_NAME_LINE_SEIZE;
 
-#define sca_ok_status_for_event(e1) \
-	(e1) == SCA_EVENT_TYPE_CALL_INFO ? 202 : 200
+#define sca_ok_status_for_event(e1) (e1) == SCA_EVENT_TYPE_CALL_INFO ? 202 : 200
 #define sca_ok_text_for_event(e1) \
 	(e1) == SCA_EVENT_TYPE_CALL_INFO ? "Accepted" : "OK"
 
diff --git a/src/modules/sca/sca_hash.c b/src/modules/sca/sca_hash.c
index ce7be73..3e96bc2 100644
--- a/src/modules/sca/sca_hash.c
+++ b/src/modules/sca/sca_hash.c
@@ -31,14 +31,14 @@ int sca_hash_table_create(sca_hash_table **ht, unsigned int size)
 	assert(ht != NULL);
 
 	*ht = shm_malloc(sizeof(sca_hash_table));
-	if (*ht == NULL) {
+	if(*ht == NULL) {
 		LM_ERR("Failed to shm_malloc space for hash table\n");
 		return (-1);
 	}
 
 	(*ht)->size = size;
-	(*ht)->slots = (sca_hash_slot *) shm_malloc(size * sizeof(sca_hash_slot));
-	if ((*ht)->slots == NULL) {
+	(*ht)->slots = (sca_hash_slot *)shm_malloc(size * sizeof(sca_hash_slot));
+	if((*ht)->slots == NULL) {
 		LM_ERR("Failed to shm_malloc hash table slots\n");
 		shm_free(*ht);
 		*ht = NULL;
@@ -46,8 +46,8 @@ int sca_hash_table_create(sca_hash_table **ht, unsigned int size)
 	}
 	memset((*ht)->slots, 0, size * sizeof(sca_hash_slot));
 
-	for (i = 0; i < (*ht)->size; i++) {
-		if (lock_init(&(*ht)->slots[i].lock) == NULL) {
+	for(i = 0; i < (*ht)->size; i++) {
+		if(lock_init(&(*ht)->slots[i].lock) == NULL) {
 			LM_ERR("Failed to initialized lock in hash table slot %d\n", i);
 			shm_free(*ht);
 			*ht = NULL;
@@ -69,8 +69,8 @@ int sca_hash_table_slot_kv_insert_unsafe(sca_hash_slot *slot, void *value,
 	assert(value != NULL);
 	assert(e_free != NULL);
 
-	new_entry = (sca_hash_entry *) shm_malloc(sizeof(sca_hash_entry));
-	if (new_entry == NULL) {
+	new_entry = (sca_hash_entry *)shm_malloc(sizeof(sca_hash_entry));
+	if(new_entry == NULL) {
 		LM_ERR("Failed to shm_malloc new hash table entry for slot %p\n", slot);
 		return (-1);
 	}
@@ -95,8 +95,8 @@ int sca_hash_table_slot_kv_insert(sca_hash_slot *slot, void *value,
 
 	lock_get(&slot->lock);
 
-	rc = sca_hash_table_slot_kv_insert_unsafe(slot, value, e_compare,
-			e_description, e_free);
+	rc = sca_hash_table_slot_kv_insert_unsafe(
+			slot, value, e_compare, e_description, e_free);
 
 	lock_release(&slot->lock);
 
@@ -111,8 +111,8 @@ int sca_hash_table_index_kv_insert(sca_hash_table *ht, int slot_idx,
 	assert(ht->slots != NULL);
 	assert(slot_idx >= 0 && slot_idx < ht->size);
 
-	return (sca_hash_table_slot_kv_insert(&ht->slots[slot_idx], value,
-			e_compare, e_description, e_free));
+	return (sca_hash_table_slot_kv_insert(
+			&ht->slots[slot_idx], value, e_compare, e_description, e_free));
 }
 
 int sca_hash_table_kv_insert(sca_hash_table *ht, str *key, void *value,
@@ -125,8 +125,8 @@ int sca_hash_table_kv_insert(sca_hash_table *ht, str *key, void *value,
 	assert(ht != NULL && !SCA_STR_EMPTY(key) && value != NULL);
 
 	hash_idx = sca_hash_table_index_for_key(ht, key);
-	rc = sca_hash_table_index_kv_insert(ht, hash_idx, value, e_compare,
-			e_description, e_free);
+	rc = sca_hash_table_index_kv_insert(
+			ht, hash_idx, value, e_compare, e_description, e_free);
 
 	return (rc);
 }
@@ -138,8 +138,8 @@ void *sca_hash_table_slot_kv_find_unsafe(sca_hash_slot *slot, str *key)
 
 	assert(slot != NULL && !SCA_STR_EMPTY(key));
 
-	for (e = slot->entries; e != NULL; e = e->next) {
-		if (e->compare(key, e->value) == 0) {
+	for(e = slot->entries; e != NULL; e = e->next) {
+		if(e->compare(key, e->value) == 0) {
 			value = e->value;
 		}
 	}
@@ -158,8 +158,8 @@ void *sca_hash_table_slot_kv_find(sca_hash_slot *slot, str *key)
 	return (value);
 }
 
-void *sca_hash_table_index_kv_find_unsafe(sca_hash_table *ht, int slot_idx,
-		str *key)
+void *sca_hash_table_index_kv_find_unsafe(
+		sca_hash_table *ht, int slot_idx, str *key)
 {
 	assert(ht != NULL && !SCA_STR_EMPTY(key));
 	assert(slot_idx >= 0 && slot_idx < ht->size);
@@ -167,8 +167,7 @@ void *sca_hash_table_index_kv_find_unsafe(sca_hash_table *ht, int slot_idx,
 	return (sca_hash_table_slot_kv_find_unsafe(&ht->slots[slot_idx], key));
 }
 
-void *
-sca_hash_table_index_kv_find(sca_hash_table *ht, int slot_idx, str *key)
+void *sca_hash_table_index_kv_find(sca_hash_table *ht, int slot_idx, str *key)
 {
 	assert(ht != NULL && !SCA_STR_EMPTY(key));
 	assert(slot_idx >= 0 && slot_idx < ht->size);
@@ -185,15 +184,15 @@ void *sca_hash_table_kv_find(sca_hash_table *ht, str *key)
 	return (sca_hash_table_index_kv_find(ht, slot_idx, key));
 }
 
-sca_hash_entry *sca_hash_table_slot_kv_find_entry_unsafe(sca_hash_slot *slot,
-		str *key)
+sca_hash_entry *sca_hash_table_slot_kv_find_entry_unsafe(
+		sca_hash_slot *slot, str *key)
 {
 	sca_hash_entry *e = NULL;
 
 	assert(slot != NULL && !SCA_STR_EMPTY(key));
 
-	for (e = slot->entries; e != NULL; e = e->next) {
-		if (e->compare(key, e->value) == 0) {
+	for(e = slot->entries; e != NULL; e = e->next) {
+		if(e->compare(key, e->value) == 0) {
 			break;
 		}
 	}
@@ -220,16 +219,16 @@ void sca_hash_entry_free(sca_hash_entry *e)
 	shm_free(e);
 }
 
-sca_hash_entry *sca_hash_table_slot_unlink_entry_unsafe(sca_hash_slot *slot,
-		sca_hash_entry *e)
+sca_hash_entry *sca_hash_table_slot_unlink_entry_unsafe(
+		sca_hash_slot *slot, sca_hash_entry *e)
 {
 	sca_hash_entry **cur_e;
 
 	assert(slot != NULL);
 	assert(e != NULL);
 
-	for (cur_e = &slot->entries; *cur_e != NULL; cur_e = &(*cur_e)->next) {
-		if (*cur_e == e) {
+	for(cur_e = &slot->entries; *cur_e != NULL; cur_e = &(*cur_e)->next) {
+		if(*cur_e == e) {
 			*cur_e = e->next;
 
 			/* ensure any attempted traversal using this entry goes nowhere */
@@ -248,12 +247,12 @@ int sca_hash_table_slot_kv_delete_unsafe(sca_hash_slot *slot, str *key)
 	sca_hash_entry *e;
 
 	e = sca_hash_table_slot_kv_find_entry_unsafe(slot, key);
-	if (e == NULL) {
+	if(e == NULL) {
 		return (-1);
 	}
 
 	e = sca_hash_table_slot_unlink_entry_unsafe(slot, e);
-	if (e) {
+	if(e) {
 		e->free_entry(e->value);
 		shm_free(e);
 	}
@@ -290,8 +289,8 @@ static void sca_hash_slot_print(sca_hash_slot *hs)
 {
 	sca_hash_entry *e;
 
-	for (e = hs->entries; e != NULL; e = e->next) {
-		if (e->description != NULL) {
+	for(e = hs->entries; e != NULL; e = e->next) {
+		if(e->description != NULL) {
 			e->description(e->value);
 		} else {
 			LM_DBG("0x%p\n", e->value);
@@ -303,7 +302,7 @@ void sca_hash_table_print(sca_hash_table *ht)
 {
 	unsigned int i;
 
-	for (i = 0; i < ht->size; i++) {
+	for(i = 0; i < ht->size; i++) {
 		LM_DBG("SLOT %d:\n", i);
 		sca_hash_slot_print(&ht->slots[i]);
 	}
@@ -314,18 +313,18 @@ void sca_hash_table_free(sca_hash_table *ht)
 	sca_hash_entry *e, *e_tmp;
 	unsigned int i;
 
-	if (ht == NULL) {
+	if(ht == NULL) {
 		return;
 	}
 
-	for (i = 0; i < ht->size; i++) {
-		if (ht->slots[i].entries == NULL) {
+	for(i = 0; i < ht->size; i++) {
+		if(ht->slots[i].entries == NULL) {
 			continue;
 		}
 
 		sca_hash_table_lock_index(ht, i);
 
-		for (e = ht->slots[i].entries; e != NULL; e = e_tmp) {
+		for(e = ht->slots[i].entries; e != NULL; e = e_tmp) {
 			e_tmp = e->next;
 
 			e->free_entry(e->value);
diff --git a/src/modules/sca/sca_hash.h b/src/modules/sca/sca_hash.h
index 72e4bc3..15cbeb2 100644
--- a/src/modules/sca/sca_hash.h
+++ b/src/modules/sca/sca_hash.h
@@ -21,7 +21,8 @@
 #define SCA_HASH_H
 
 struct _sca_hash_slot;
-struct _sca_hash_entry {
+struct _sca_hash_entry
+{
 	void *value;
 	int (*compare)(str *, void *);
 	void (*description)(void *);
@@ -31,13 +32,15 @@ struct _sca_hash_entry {
 };
 typedef struct _sca_hash_entry sca_hash_entry;
 
-struct _sca_hash_slot {
+struct _sca_hash_slot
+{
 	gen_lock_t lock;
 	sca_hash_entry *entries;
 };
 typedef struct _sca_hash_slot sca_hash_slot;
 
-struct _sca_hash_table {
+struct _sca_hash_table
+{
 	unsigned int size; // power of two
 	sca_hash_slot *slots;
 };
@@ -46,14 +49,13 @@ typedef struct _sca_hash_table sca_hash_table;
 #define sca_hash_table_index_for_key(ht1, str1) \
 	(get_hash1_raw((str1)->s, (str1)->len) & ((ht1)->size - 1))
 
-#define sca_hash_table_slot_for_index(ht1, idx1) \
-	&(ht1)->slots[ (idx1) ]
+#define sca_hash_table_slot_for_index(ht1, idx1) &(ht1)->slots[(idx1)]
 
 #define sca_hash_table_lock_index(ht1, idx1) \
-	lock_get(&(ht1)->slots[ (idx1) ].lock)
+	lock_get(&(ht1)->slots[(idx1)].lock)
 
 #define sca_hash_table_unlock_index(ht1, idx1) \
-	lock_release(&(ht1)->slots[ (idx1) ].lock)
+	lock_release(&(ht1)->slots[(idx1)].lock)
 
 // hash table operations
 int sca_hash_table_create(sca_hash_table **, unsigned int);
@@ -77,9 +79,10 @@ void *sca_hash_table_index_kv_find_unsafe(sca_hash_table *, int, str *);
 void *sca_hash_table_index_kv_find(sca_hash_table *, int, str *);
 void *sca_hash_table_kv_find(sca_hash_table *, str *);
 
-sca_hash_entry *sca_hash_table_slot_kv_find_entry_unsafe(sca_hash_slot *, str *);
-sca_hash_entry *sca_hash_table_slot_unlink_entry_unsafe(sca_hash_slot *,
-		sca_hash_entry *);
+sca_hash_entry *sca_hash_table_slot_kv_find_entry_unsafe(
+		sca_hash_slot *, str *);
+sca_hash_entry *sca_hash_table_slot_unlink_entry_unsafe(
+		sca_hash_slot *, sca_hash_entry *);
 
 int sca_hash_table_slot_kv_delete(sca_hash_slot *, str *);
 int sca_hash_table_index_kv_delete(sca_hash_table *, int, str *);
diff --git a/src/modules/sca/sca_notify.c b/src/modules/sca/sca_notify.c
index a654fb9..133a3fe 100644
--- a/src/modules/sca/sca_notify.c
+++ b/src/modules/sca/sca_notify.c
@@ -32,24 +32,24 @@
 
 const str SCA_METHOD_NOTIFY = STR_STATIC_INIT("NOTIFY");
 
-static void sca_notify_reply_cb(struct cell *t, int cb_type,
-		struct tmcb_params *cbp)
+static void sca_notify_reply_cb(
+		struct cell *t, int cb_type, struct tmcb_params *cbp)
 {
 	struct sip_msg *notify_reply = NULL;
 	str to_aor = STR_NULL;
 	str *contact_uri;
 
-	if (cbp == NULL) {
+	if(cbp == NULL) {
 		LM_ERR("Empty parameters passed to NOTIFY callback!\n");
 		return;
 	}
-	if ((notify_reply = cbp->rpl) == NULL) {
+	if((notify_reply = cbp->rpl) == NULL) {
 		LM_ERR("Empty reply passed to NOTIFY callback!\n");
 		return;
 	}
 
 	contact_uri = &t->uac[0].uri;
-	if (notify_reply != FAKED_REPLY && REPLY_CLASS(notify_reply) == 2) {
+	if(notify_reply != FAKED_REPLY && REPLY_CLASS(notify_reply) == 2) {
 		LM_DBG("NOTIFY %.*s returned %d\n", STR_FMT(contact_uri),
 				notify_reply->REPLY_STATUS);
 		return;
@@ -61,30 +61,32 @@ static void sca_notify_reply_cb(struct cell *t, int cb_type,
 	// possible the client will return 481 (no such transaction), but that's
 	// still grounds for us to remove the subscription, since the dialog
 	// we have associated with the subscription is no longer valid.
-	if (notify_reply == FAKED_REPLY) {
+	if(notify_reply == FAKED_REPLY) {
 		LM_ERR("NOTIFY %.*s resulted in FAKED_REPLY from proxy: "
-				"failed to deliver NOTIFY to client\n", STR_FMT(contact_uri));
+			   "failed to deliver NOTIFY to client\n",
+				STR_FMT(contact_uri));
 	} else {
 		LM_ERR("NOTIFY %.*s returned %d %.*s removing call-info "
-				"subscription for %.*s\n", STR_FMT(contact_uri),
-				notify_reply->REPLY_STATUS,
+			   "subscription for %.*s\n",
+				STR_FMT(contact_uri), notify_reply->REPLY_STATUS,
 				STR_FMT(&notify_reply->first_line.u.reply.reason),
 				STR_FMT(contact_uri));
 	}
 	return;
 
-	if (sca_uri_extract_aor(&t->to, &to_aor) < 0) {
+	if(sca_uri_extract_aor(&t->to, &to_aor) < 0) {
 		LM_ERR("Failed to extract AoR from %.*s\n", STR_FMT(&t->to));
 		return;
 	}
 	// t->to is the entire To header: "To: sip:....", so move to_aor.s ahead
-	if (memcmp(to_aor.s, "To: ", strlen("To: ")) == 0) {
+	if(memcmp(to_aor.s, "To: ", strlen("To: ")) == 0) {
 		to_aor.s += strlen("To: ");
 		to_aor.len -= strlen("To: ");
 	}
 
-	if (sca_subscription_delete_subscriber_for_event(sca, contact_uri,
-			&SCA_EVENT_NAME_CALL_INFO, &to_aor) < 0) {
+	if(sca_subscription_delete_subscriber_for_event(
+			   sca, contact_uri, &SCA_EVENT_NAME_CALL_INFO, &to_aor)
+			< 0) {
 		LM_ERR("Failed to delete %.*s %.*s subscription\n",
 				STR_FMT(contact_uri), STR_FMT(&SCA_EVENT_NAME_CALL_INFO));
 	}
@@ -94,8 +96,8 @@ static dlg_t *sca_notify_dlg_for_subscription(sca_subscription *sub)
 {
 	dlg_t *dlg = NULL;
 
-	dlg = (dlg_t *) pkg_malloc(sizeof(dlg_t));
-	if (dlg == NULL) {
+	dlg = (dlg_t *)pkg_malloc(sizeof(dlg_t));
+	if(dlg == NULL) {
 		LM_ERR("pkg_malloc dlg_t for %.*s failed: out of memory\n",
 				STR_FMT(&sub->subscriber));
 		goto error;
@@ -117,10 +119,10 @@ static dlg_t *sca_notify_dlg_for_subscription(sca_subscription *sub)
 	dlg->rem_uri = sub->target_aor;
 
 	// restore route
-	if (!SCA_STR_EMPTY(&sub->rr)) {
-		if (parse_rr_body(sub->rr.s, sub->rr.len, &dlg->route_set) < 0) {
+	if(!SCA_STR_EMPTY(&sub->rr)) {
+		if(parse_rr_body(sub->rr.s, sub->rr.len, &dlg->route_set) < 0) {
 			LM_ERR("sca_notify_dlg_for_subscription: failed to parse "
-					"%.*s subscription's Record-Route info\n",
+				   "%.*s subscription's Record-Route info\n",
 					STR_FMT(&sub->subscriber));
 			goto error;
 		}
@@ -133,35 +135,35 @@ static dlg_t *sca_notify_dlg_for_subscription(sca_subscription *sub)
 
 	return (dlg);
 
-	error: if (dlg != NULL) {
+error:
+	if(dlg != NULL) {
 		pkg_free(dlg);
 	}
 
 	return (NULL);
 }
 
-static int sca_notify_append_subscription_state_header(sca_subscription *sub,
-		char *hdrbuf, int maxlen)
+static int sca_notify_append_subscription_state_header(
+		sca_subscription *sub, char *hdrbuf, int maxlen)
 {
 	str state_str = STR_NULL;
-	int len,
-	total = 0;
+	int len, total = 0;
 	int ttl = sub->expires - time(NULL);
 
-	if (ttl < 0) {
+	if(ttl < 0) {
 		ttl = 0;
 	}
 
 	sca_subscription_state_to_str(sub->state, &state_str);
 	len = snprintf(hdrbuf, maxlen, "Subscription-State: %s", state_str.s);
-	if (len >= maxlen) {
+	if(len >= maxlen) {
 		goto error;
 	}
 	total += len;
 
-	if (ttl > 0) {
+	if(ttl > 0) {
 		len = snprintf(hdrbuf + total, maxlen - total, ";expires=%d", ttl);
-		if (len >= maxlen) {
+		if(len >= maxlen) {
 			goto error;
 		}
 		total += len;
@@ -172,25 +174,24 @@ static int sca_notify_append_subscription_state_header(sca_subscription *sub,
 
 	return (total);
 
-	error:
+error:
 	LM_ERR("Cannot append Subscription-State header: buffer too small\n");
 	return (-1);
 }
 
-static int sca_notify_append_contact_header(sca_subscription *sub, char *hdrbuf,
-		int maxlen)
+static int sca_notify_append_contact_header(
+		sca_subscription *sub, char *hdrbuf, int maxlen)
 {
 	int len = strlen("Contact: ");
 	str *orig = NULL;
 
-	if (sca->cfg->server_address != NULL) {
+	if(sca->cfg->server_address != NULL) {
 		orig = sca->cfg->server_address;
-	}
-	else {
+	} else {
 		orig = &sub->target_aor;
 	}
 
-	if (len + orig->len + strlen(CRLF) >= maxlen) {
+	if(len + orig->len + strlen(CRLF) >= maxlen) {
 		LM_ERR("Cannot append Contact header: buffer too small\n");
 		return (-1);
 	}
@@ -212,7 +213,7 @@ static int sca_notify_build_headers_from_info(str *hdrs, int max_hdrs_len,
 	assert(hdrs != NULL);
 
 	len = sca_notify_append_contact_header(sub, hdrs->s, max_hdrs_len);
-	if (len < 0) {
+	if(len < 0) {
 		LM_ERR("Failed to add Contact header to %s NOTIFY for %.*s\n",
 				sca_event_name_from_type(sub->event),
 				STR_FMT(&sub->subscriber));
@@ -220,10 +221,11 @@ static int sca_notify_build_headers_from_info(str *hdrs, int max_hdrs_len,
 	}
 	hdrs->len = len;
 
-	if (app_idx == SCA_CALL_INFO_APPEARANCE_INDEX_ANY) {
+	if(app_idx == SCA_CALL_INFO_APPEARANCE_INDEX_ANY) {
 		// add Call-Info header with appearance state
-		if ((len = sca_call_info_build_header(scam, sub, hdrs->s + hdrs->len,
-				max_hdrs_len - hdrs->len)) < 0) {
+		if((len = sca_call_info_build_header(
+					scam, sub, hdrs->s + hdrs->len, max_hdrs_len - hdrs->len))
+				< 0) {
 			LM_ERR("Failed to build Call-Info Headers for %s NOTIFY to %.*s\n",
 					sca_event_name_from_type(sub->event),
 					STR_FMT(&sub->subscriber));
@@ -231,18 +233,18 @@ static int sca_notify_build_headers_from_info(str *hdrs, int max_hdrs_len,
 		}
 	} else {
 		// just add Call-Info header with single appearance index
-		len = sca_call_info_append_header_for_appearance_index(sub, app_idx,
-				hdrs->s + hdrs->len, max_hdrs_len - hdrs->len);
-		if (len < 0) {
+		len = sca_call_info_append_header_for_appearance_index(
+				sub, app_idx, hdrs->s + hdrs->len, max_hdrs_len - hdrs->len);
+		if(len < 0) {
 			goto error;
 		}
 	}
 
 	hdrs->len += len;
 
-	len = sca_event_append_header_for_type(sub->event, hdrs->s + hdrs->len,
-			max_hdrs_len - hdrs->len);
-	if (len < 0) {
+	len = sca_event_append_header_for_type(
+			sub->event, hdrs->s + hdrs->len, max_hdrs_len - hdrs->len);
+	if(len < 0) {
 		LM_ERR("Failed to add Event header to %s NOTIFY for %.*s\n",
 				sca_event_name_from_type(sub->event),
 				STR_FMT(&sub->subscriber));
@@ -250,11 +252,12 @@ static int sca_notify_build_headers_from_info(str *hdrs, int max_hdrs_len,
 	}
 	hdrs->len += len;
 
-	len = sca_notify_append_subscription_state_header(sub, hdrs->s + hdrs->len,
-			max_hdrs_len - hdrs->len);
-	if (len < 0) {
+	len = sca_notify_append_subscription_state_header(
+			sub, hdrs->s + hdrs->len, max_hdrs_len - hdrs->len);
+	if(len < 0) {
 		LM_ERR("Failed to add Subscription-State header to %s NOTIFY for "
-				"%.*s\n", sca_event_name_from_type(sub->event),
+			   "%.*s\n",
+				sca_event_name_from_type(sub->event),
 				STR_FMT(&sub->subscriber));
 		goto error;
 	}
@@ -262,11 +265,12 @@ static int sca_notify_build_headers_from_info(str *hdrs, int max_hdrs_len,
 
 	return (hdrs->len);
 
-	error: return (-1);
+error:
+	return (-1);
 }
 
-static int sca_notify_subscriber_internal(sca_mod *scam, sca_subscription *sub,
-		str *headers)
+static int sca_notify_subscriber_internal(
+		sca_mod *scam, sca_subscription *sub, str *headers)
 {
 	uac_req_t request;
 	dlg_t *dlg = NULL;
@@ -274,12 +278,13 @@ static int sca_notify_subscriber_internal(sca_mod *scam, sca_subscription *sub,
 	int rc = -1;
 
 	sca_appearance_state_to_str(sub->state, &state_str);
-	LM_DBG("SCA: NOTIFYing subscriber '%.*s' of event '%s' with a state of '%.*s' to index '%d'\n",
+	LM_DBG("SCA: NOTIFYing subscriber '%.*s' of event '%s' with a state of "
+		   "'%.*s' to index '%d'\n",
 			STR_FMT(&sub->subscriber), sca_event_name_from_type(sub->event),
 			STR_FMT(&state_str), sub->index);
 
 	dlg = sca_notify_dlg_for_subscription(sub);
-	if (dlg == NULL) {
+	if(dlg == NULL) {
 		LM_ERR("Failed to create dlg_t for %s NOTIFY to %.*s\n",
 				sca_event_name_from_type(sub->event),
 				STR_FMT(&sub->subscriber));
@@ -289,15 +294,16 @@ static int sca_notify_subscriber_internal(sca_mod *scam, sca_subscription *sub,
 	set_uac_req(&request, (str *)&SCA_METHOD_NOTIFY, headers, NULL, dlg,
 			TMCB_LOCAL_COMPLETED, sca_notify_reply_cb, scam);
 	rc = scam->tm_api->t_request_within(&request);
-	if (rc < 0) {
+	if(rc < 0) {
 		LM_ERR("Failed to send in-dialog %s NOTIFY to %.*s\n",
 				sca_event_name_from_type(sub->event),
 				STR_FMT(&sub->subscriber));
 	}
 	// fall through, return rc from t_request_within
 
-	done: if (dlg != NULL) {
-		if (dlg->route_set != NULL) {
+done:
+	if(dlg != NULL) {
+		if(dlg->route_set != NULL) {
 			free_rr(&dlg->route_set);
 		}
 
@@ -307,7 +313,7 @@ static int sca_notify_subscriber_internal(sca_mod *scam, sca_subscription *sub,
 	return (rc);
 }
 
-#define SCA_HEADERS_MAX_LEN	4096
+#define SCA_HEADERS_MAX_LEN 4096
 int sca_notify_subscriber(sca_mod *scam, sca_subscription *sub, int app_idx)
 {
 	str headers = STR_NULL;
@@ -316,8 +322,9 @@ int sca_notify_subscriber(sca_mod *scam, sca_subscription *sub, int app_idx)
 	LM_DBG("NOTIFYing subscriber because of a SUBSCRIPTION request\n");
 
 	headers.s = hdrbuf;
-	if (sca_notify_build_headers_from_info(&headers, sizeof(hdrbuf), scam, sub,
-			app_idx) < 0) {
+	if(sca_notify_build_headers_from_info(
+			   &headers, sizeof(hdrbuf), scam, sub, app_idx)
+			< 0) {
 		LM_ERR("Failed to build NOTIFY headers\n");
 		return (-1);
 	}
@@ -344,13 +351,14 @@ int sca_notify_call_info_subscribers(sca_mod *scam, str *subscription_aor)
 	assert(scam->subscriptions != NULL);
 	assert(!SCA_STR_EMPTY(subscription_aor));
 
-	LM_DBG("Notifying ALL subscribers of AOR %.*s due to a SUBSCRIBTION request\n",
+	LM_DBG("Notifying ALL subscribers of AOR %.*s due to a SUBSCRIBTION "
+		   "request\n",
 			STR_FMT(subscription_aor));
 
 	event_name = sca_event_name_from_type(SCA_EVENT_TYPE_CALL_INFO);
-	if (subscription_aor->len + strlen(event_name) >= sizeof(keybuf)) {
-		LM_ERR("Hash key %.*s + %s is too long\n",
-				STR_FMT(subscription_aor), event_name);
+	if(subscription_aor->len + strlen(event_name) >= sizeof(keybuf)) {
+		LM_ERR("Hash key %.*s + %s is too long\n", STR_FMT(subscription_aor),
+				event_name);
 		return (-1);
 	}
 	hash_key.s = keybuf;
@@ -362,17 +370,18 @@ int sca_notify_call_info_subscribers(sca_mod *scam, str *subscription_aor)
 
 	sca_hash_table_lock_index(scam->subscriptions, slot_idx);
 
-	for (e = slot->entries; e != NULL; e = e->next) {
-		sub = (sca_subscription *) e->value;
-		if (!SCA_STR_EQ(subscription_aor, &sub->target_aor)) {
+	for(e = slot->entries; e != NULL; e = e->next) {
+		sub = (sca_subscription *)e->value;
+		if(!SCA_STR_EQ(subscription_aor, &sub->target_aor)) {
 			continue;
 		}
 
-		if (headers.len == 0) {
+		if(headers.len == 0) {
 			headers.s = hdrbuf;
 
-			if (sca_notify_build_headers_from_info(&headers, sizeof(hdrbuf),
-					scam, sub, SCA_CALL_INFO_APPEARANCE_INDEX_ANY) < 0) {
+			if(sca_notify_build_headers_from_info(&headers, sizeof(hdrbuf),
+					   scam, sub, SCA_CALL_INFO_APPEARANCE_INDEX_ANY)
+					< 0) {
 				LM_ERR("Failed to build NOTIFY headers\n");
 				goto done;
 			}
@@ -381,13 +390,13 @@ int sca_notify_call_info_subscribers(sca_mod *scam, str *subscription_aor)
 		// XXX would like this to be wrapped in one location
 		sub->dialog.notify_cseq += 1;
 
-		if (sca_notify_subscriber_internal(scam, sub, &headers) < 0) {
+		if(sca_notify_subscriber_internal(scam, sub, &headers) < 0) {
 			goto done;
 		}
 	}
 	rc = 1;
 
-	done:
+done:
 	sca_hash_table_unlock_index(scam->subscriptions, slot_idx);
 
 	return (rc);
diff --git a/src/modules/sca/sca_reply.c b/src/modules/sca/sca_reply.c
index a56fb93..ad143d5 100644
--- a/src/modules/sca/sca_reply.c
+++ b/src/modules/sca/sca_reply.c
@@ -36,18 +36,18 @@ int sca_reply(sca_mod *scam, int status_code, char *status_msg,
 	status_str.s = status_msg;
 	status_str.len = strlen(status_msg);
 
-	if (extra_headers && extra_headers->len) {
-		if (add_lump_rpl(msg, extra_headers->s, extra_headers->len,
-		LUMP_RPL_HDR) == NULL) {
-			LM_ERR("sca_subscription_reply: failed to add Retry-After header\n");
+	if(extra_headers && extra_headers->len) {
+		if(add_lump_rpl(msg, extra_headers->s, extra_headers->len, LUMP_RPL_HDR)
+				== NULL) {
+			LM_ERR("sca_subscription_reply: failed to add Retry-After "
+				   "header\n");
 			return (-1);
 		}
 	}
 
-	if (scam->sl_api->freply(msg, status_code, &status_str) < 0) {
-		LM_ERR("Failed to send \"%d %s\" reply to %.*s",
-				status_code, status_msg,
-				get_from(msg)->body.len, get_from(msg)->body.s);
+	if(scam->sl_api->freply(msg, status_code, &status_str) < 0) {
+		LM_ERR("Failed to send \"%d %s\" reply to %.*s", status_code,
+				status_msg, get_from(msg)->body.len, get_from(msg)->body.s);
 		return (-1);
 	}
 
diff --git a/src/modules/sca/sca_rpc.c b/src/modules/sca/sca_rpc.c
index 6005aea..f1882fa 100644
--- a/src/modules/sca/sca_rpc.c
+++ b/src/modules/sca/sca_rpc.c
@@ -33,40 +33,31 @@
 #include "sca_subscribe.h"
 
 const char *sca_rpc_show_all_subscriptions_doc[] = {
-		"Show all shared call appearance subscriptions",
-		NULL};
+		"Show all shared call appearance subscriptions", NULL};
 const char *sca_rpc_subscription_count_doc[] = {
-		"Show count of call-info or line-seize subscriptions",
-		NULL};
+		"Show count of call-info or line-seize subscriptions", NULL};
 const char *sca_rpc_show_subscription_doc[] = {
-		"Show details of a single shared call appearance subscription",
-		NULL};
+		"Show details of a single shared call appearance subscription", NULL};
 const char *sca_rpc_show_subscribers_doc[] = {
-		"Show contact URIs for all call-info subscribers",
-		NULL};
+		"Show contact URIs for all call-info subscribers", NULL};
 const char *sca_rpc_deactivate_all_subscriptions_doc[] = {
 		"Send NOTIFYs with Subscription-State: "
-				"terminated;reason=deactivated to all subscribers",
+		"terminated;reason=deactivated to all subscribers",
 		NULL};
 const char *sca_rpc_deactivate_subscription_doc[] = {
 		"Send NOTIFY with Subscription-State: "
-				"terminated;reason=deactivated to a single subscriber",
+		"terminated;reason=deactivated to a single subscriber",
 		NULL};
 const char *sca_rpc_show_all_appearances_doc[] = {
-		"Show appearance state for all SCA accounts of record (AoR)",
-		NULL};
+		"Show appearance state for all SCA accounts of record (AoR)", NULL};
 const char *sca_rpc_show_appearance_doc[] = {
-		"Show appearance state for a single SCA account of record (AoR)",
-		NULL};
+		"Show appearance state for a single SCA account of record (AoR)", NULL};
 const char *sca_rpc_seize_appearance_doc[] = {
-		"Seize an appearance on an SCA line",
-		NULL};
+		"Seize an appearance on an SCA line", NULL};
 const char *sca_rpc_update_appearance_doc[] = {
-		"Update the state of a seized appearance on an SCA line",
-		NULL};
+		"Update the state of a seized appearance on an SCA line", NULL};
 const char *sca_rpc_release_appearance_doc[] = {
-		"Release a seized or active SCA appearance",
-		NULL};
+		"Release a seized or active SCA appearance", NULL};
 
 /*
  * Show all shared call appearance subscriptions
@@ -82,42 +73,42 @@ void sca_rpc_show_all_subscriptions(rpc_t *rpc, void *ctx)
 	int i;
 	int rc = 0;
 
-	if ((ht = sca->subscriptions) == NULL) {
+	if((ht = sca->subscriptions) == NULL) {
 		rpc->fault(ctx, 500, "Empty subscription table!");
 		return;
 	}
 
 	now = time(NULL);
 
-	for (i = 0; i < ht->size; i++) {
+	for(i = 0; i < ht->size; i++) {
 		sca_hash_table_lock_index(ht, i);
 
-		for (ent = ht->slots[i].entries; ent != NULL; ent = ent->next) {
-			sub = (sca_subscription *) ent->value;
+		for(ent = ht->slots[i].entries; ent != NULL; ent = ent->next) {
+			sub = (sca_subscription *)ent->value;
 			sca_subscription_state_to_str(sub->state, &sub_state);
 
 			rc = parse_uri(sub->target_aor.s, sub->target_aor.len, &aor_uri);
-			if (rc >= 0) {
-				rc = parse_uri(sub->subscriber.s, sub->subscriber.len,
-						&sub_uri);
+			if(rc >= 0) {
+				rc = parse_uri(
+						sub->subscriber.s, sub->subscriber.len, &sub_uri);
 			}
-			if (rc >= 0) {
+			if(rc >= 0) {
 				rc = rpc->rpl_printf(ctx, "%.*s %.*s%s%.*s %s %ld %.*s",
 						STR_FMT(&aor_uri.user), STR_FMT(&sub_uri.host),
 						(sub_uri.port.len ? ":" : ""), STR_FMT(&sub_uri.port),
 						sca_event_name_from_type(sub->event),
-						(long) (sub->expires - now), STR_FMT(&sub_state));
+						(long)(sub->expires - now), STR_FMT(&sub_state));
 			} else {
 				LM_ERR("sca_rpc_show_all_subscriptions: parse_uri %.*s "
-						"failed, dumping unparsed info\n",
+					   "failed, dumping unparsed info\n",
 						STR_FMT(&sub->target_aor));
 				rc = rpc->rpl_printf(ctx, "%.*s %.*s %s %ld %.*s",
 						STR_FMT(&sub->target_aor), STR_FMT(&sub->subscriber),
 						sca_event_name_from_type(sub->event),
-						(long) sub->expires, STR_FMT(&sub_state));
+						(long)sub->expires, STR_FMT(&sub_state));
 			}
 
-			if (rc < 0) {
+			if(rc < 0) {
 				// make sure we unlock below
 				break;
 			}
@@ -125,7 +116,7 @@ void sca_rpc_show_all_subscriptions(rpc_t *rpc, void *ctx)
 
 		sca_hash_table_unlock_index(ht, i);
 
-		if (rc < 0) {
+		if(rc < 0) {
 			return;
 		}
 	}
@@ -141,35 +132,35 @@ void sca_rpc_subscription_count(rpc_t *rpc, void *ctx)
 	sca_subscription *sub;
 	str event_name = STR_NULL;
 	char *usage = "usage: sca.subscription_count "
-			"{call-info | line-seize}";
+				  "{call-info | line-seize}";
 	unsigned long sub_count = 0;
 	int i;
 	int event_type;
 
-	if ((ht = sca->subscriptions) == NULL) {
+	if((ht = sca->subscriptions) == NULL) {
 		rpc->fault(ctx, 500, "Empty subscription table!");
 		return;
 	}
 
 	// AoR is required
-	if (rpc->scan(ctx, "S", &event_name) != 1) {
+	if(rpc->scan(ctx, "S", &event_name) != 1) {
 		rpc->fault(ctx, 500, usage);
 		return;
 	}
 
 	event_type = sca_event_from_str(&event_name);
-	if (event_type == SCA_EVENT_TYPE_UNKNOWN) {
+	if(event_type == SCA_EVENT_TYPE_UNKNOWN) {
 		rpc->fault(ctx, 500, usage);
 		return;
 	}
 
-	for (i = 0; i < ht->size; i++) {
+	for(i = 0; i < ht->size; i++) {
 		sca_hash_table_lock_index(ht, i);
 
-		for (ent = ht->slots[i].entries; ent != NULL; ent = ent->next) {
-			sub = (sca_subscription *) ent->value;
+		for(ent = ht->slots[i].entries; ent != NULL; ent = ent->next) {
+			sub = (sca_subscription *)ent->value;
 
-			if (event_type == sub->event) {
+			if(event_type == sub->event) {
 				sub_count++;
 			}
 		}
@@ -191,15 +182,15 @@ void sca_rpc_deactivate_all_subscriptions(rpc_t *rpc, void *ctx)
 	int i;
 	int rc = 0;
 
-	if ((ht = sca->subscriptions) == NULL) {
+	if((ht = sca->subscriptions) == NULL) {
 		rpc->fault(ctx, 500, "Empty subscription table!");
 	}
 
-	for (i = 0; i < ht->size; i++) {
+	for(i = 0; i < ht->size; i++) {
 		sca_hash_table_lock_index(ht, i);
 
-		for (ent = ht->slots[i].entries; ent != NULL; ent = ent->next) {
-			sub = (sca_subscription *) ent->value;
+		for(ent = ht->slots[i].entries; ent != NULL; ent = ent->next) {
+			sub = (sca_subscription *)ent->value;
 			sub->state = SCA_SUBSCRIPTION_STATE_TERMINATED_DEACTIVATED;
 			sub->expires = 0;
 			sub->dialog.notify_cseq += 1;
@@ -207,14 +198,14 @@ void sca_rpc_deactivate_all_subscriptions(rpc_t *rpc, void *ctx)
 			rpc->rpl_printf(ctx, "Deactivating %s subscription from %.*s",
 					sca_event_name_from_type(sub->event),
 					STR_FMT(&sub->subscriber));
-			if (rc < 0) {
+			if(rc < 0) {
 				// make sure we unlock below
 				break;
 			}
 
-			rc = sca_notify_subscriber(sca, sub,
-			SCA_CALL_INFO_APPEARANCE_INDEX_ANY);
-			if (rc < 0) {
+			rc = sca_notify_subscriber(
+					sca, sub, SCA_CALL_INFO_APPEARANCE_INDEX_ANY);
+			if(rc < 0) {
 				// make sure we unlock below
 				break;
 			}
@@ -222,7 +213,7 @@ void sca_rpc_deactivate_all_subscriptions(rpc_t *rpc, void *ctx)
 
 		sca_hash_table_unlock_index(ht, i);
 
-		if (rc < 0) {
+		if(rc < 0) {
 			return;
 		}
 	}
@@ -251,33 +242,32 @@ void sca_rpc_show_subscription(rpc_t *rpc, void *ctx)
 	str event_name = STR_NULL;
 	int event_type;
 	int idx = -1;
-	int rc = 0,
-	opt_rc;
+	int rc = 0, opt_rc;
 	char keybuf[1024];
 	char *usage = "usage: sca.show_subscription sip:user@domain "
-			"{call-info | line-seize} [sip:user@IP]";
+				  "{call-info | line-seize} [sip:user@IP]";
 	char *err_msg = NULL;
 	int err_code = 0;
 
 	// AoR is required
-	if (rpc->scan(ctx, "SS", &aor, &event_name) != 2) {
+	if(rpc->scan(ctx, "SS", &aor, &event_name) != 2) {
 		rpc->fault(ctx, 500, usage);
 	}
 
 	event_type = sca_event_from_str(&event_name);
-	if (event_type == SCA_EVENT_TYPE_UNKNOWN) {
+	if(event_type == SCA_EVENT_TYPE_UNKNOWN) {
 		err_code = 500;
 		err_msg = usage;
 		goto done;
 	}
 
-	if ((ht = sca->subscriptions) == NULL) {
+	if((ht = sca->subscriptions) == NULL) {
 		rpc->fault(ctx, 500, "Empty subscription table!");
 		return;
 	}
 
 	sub_key.s = keybuf;
-	if (aor.len + event_name.len >= sizeof(keybuf)) {
+	if(aor.len + event_name.len >= sizeof(keybuf)) {
 		rpc->fault(ctx, 500, "AoR length + event name length: too long");
 	}
 	SCA_STR_COPY(&sub_key, &aor);
@@ -289,14 +279,14 @@ void sca_rpc_show_subscription(rpc_t *rpc, void *ctx)
 	// Contact is optional
 	opt_rc = rpc->scan(ctx, "*S", &contact);
 
-	for (ent = ht->slots[idx].entries; ent != NULL; ent = ent->next) {
-		sub = (sca_subscription *) ent->value;
-		if (ent->compare(&aor, &sub->target_aor) != 0) {
+	for(ent = ht->slots[idx].entries; ent != NULL; ent = ent->next) {
+		sub = (sca_subscription *)ent->value;
+		if(ent->compare(&aor, &sub->target_aor) != 0) {
 			continue;
 		}
 
-		if (opt_rc == 1) {
-			if (!SCA_STR_EQ(&contact, &sub->subscriber)) {
+		if(opt_rc == 1) {
+			if(!SCA_STR_EQ(&contact, &sub->subscriber)) {
 				continue;
 			}
 		}
@@ -305,17 +295,18 @@ void sca_rpc_show_subscription(rpc_t *rpc, void *ctx)
 				sca_event_name_from_type(sub->event), STR_FMT(&sub->subscriber),
 				sub->expires);
 
-		if (rc < 0) {
+		if(rc < 0) {
 			// make sure we unlock below
 			break;
 		}
 	}
 
-	done: if (ht && idx >= 0) {
+done:
+	if(ht && idx >= 0) {
 		sca_hash_table_unlock_index(ht, idx);
 	}
 
-	if (err_code != 0) {
+	if(err_code != 0) {
 		rpc->fault(ctx, err_code, err_msg);
 	}
 }
@@ -341,26 +332,28 @@ void sca_rpc_show_all_appearances(rpc_t *rpc, void *ctx)
 	int i;
 	int rc = 0;
 
-	if ((ht = sca->appearances) == NULL) {
+	if((ht = sca->appearances) == NULL) {
 		return;
 	}
 
-	for (i = 0; i < ht->size; i++) {
+	for(i = 0; i < ht->size; i++) {
 		sca_hash_table_lock_index(ht, i);
 
-		for (ent = ht->slots[i].entries; ent != NULL; ent = ent->next) {
-			app_list = (sca_appearance_list *) ent->value;
-			for (app = app_list->appearances; app != NULL; app = app->next) {
+		for(ent = ht->slots[i].entries; ent != NULL; ent = ent->next) {
+			app_list = (sca_appearance_list *)ent->value;
+			for(app = app_list->appearances; app != NULL; app = app->next) {
 				sca_appearance_state_to_str(app->state, &state_str);
-				rc = rpc->rpl_printf(ctx, "%.*s %d %.*s %ld %.*s %.*s "
-						"%.*s %.*s %.*s", STR_FMT(&app_list->aor), app->index,
-						STR_FMT(&state_str), (long) app->times.mtime,
+				rc = rpc->rpl_printf(ctx,
+						"%.*s %d %.*s %ld %.*s %.*s "
+						"%.*s %.*s %.*s",
+						STR_FMT(&app_list->aor), app->index,
+						STR_FMT(&state_str), (long)app->times.mtime,
 						STR_FMT(&app->owner), STR_FMT(&app->callee),
 						STR_FMT(&app->dialog.call_id),
 						STR_FMT(&app->dialog.from_tag),
 						STR_FMT(&app->dialog.to_tag));
 
-				if (rc < 0) {
+				if(rc < 0) {
 					// make sure we unlock below
 					goto error;
 				}
@@ -372,7 +365,7 @@ void sca_rpc_show_all_appearances(rpc_t *rpc, void *ctx)
 
 	return;
 
-	error:
+error:
 	sca_hash_table_unlock_index(ht, i);
 	return;
 }
@@ -396,13 +389,13 @@ void sca_rpc_seize_appearance(rpc_t *rpc, void *ctx)
 	char *usage = "usage: sca.seize_appearance sip:user@domain";
 
 	// AoR & Contact are required
-	if (rpc->scan(ctx, "SS", &aor, &owner) != 2) {
+	if(rpc->scan(ctx, "SS", &aor, &owner) != 2) {
 		rpc->fault(ctx, 500, usage);
 		return;
 	}
 
 	app_idx = sca_appearance_seize_next_available_index(sca, &aor, &owner);
-	if (app_idx < 0) {
+	if(app_idx < 0) {
 		rpc->fault(ctx, 500, "Failed to seize line");
 		return;
 	}
@@ -410,7 +403,7 @@ void sca_rpc_seize_appearance(rpc_t *rpc, void *ctx)
 	rpc->rpl_printf(ctx, "Seized %.*s appearance-index %d for %.*s",
 			STR_FMT(&aor), app_idx, STR_FMT(&owner));
 
-	if (sca_notify_call_info_subscribers(sca, &aor) < 0) {
+	if(sca_notify_call_info_subscribers(sca, &aor) < 0) {
 		rpc->fault(ctx, 500, "Failed to NOTIFY subscribers to %.*s",
 				STR_FMT(&aor));
 	}
@@ -423,38 +416,37 @@ void sca_rpc_update_appearance(rpc_t *rpc, void *ctx)
 {
 	str aor = STR_NULL;
 	str app_state_str = STR_NULL;
-	str app_uri = STR_NULL,
-	*app_uri_p = NULL;
+	str app_uri = STR_NULL, *app_uri_p = NULL;
 	int app_idx;
 	int app_state;
 	int rc;
 	char *usage = "Usage: sca.update_appearance "
-			"sip:user@domain appearance-index "
-			"appearance-state [appearance-uri]";
+				  "sip:user@domain appearance-index "
+				  "appearance-state [appearance-uri]";
 
-	if (rpc->scan(ctx, "SdS", &aor, &app_idx, &app_state_str) < 3) {
+	if(rpc->scan(ctx, "SdS", &aor, &app_idx, &app_state_str) < 3) {
 		rpc->fault(ctx, 500, "%s", usage);
 		return;
 	}
-	if (rpc->scan(ctx, "*S", &app_uri) == 1) {
+	if(rpc->scan(ctx, "*S", &app_uri) == 1) {
 		app_uri_p = &app_uri;
 	}
 
 	app_state = sca_appearance_state_from_str(&app_state_str);
-	if (app_state == SCA_APPEARANCE_STATE_UNKNOWN) {
+	if(app_state == SCA_APPEARANCE_STATE_UNKNOWN) {
 		rpc->fault(ctx, 500, "%.*s: invalid state", STR_FMT(&app_state_str));
 		return;
 	}
 
-	rc = sca_appearance_update_index(sca, &aor, app_idx, app_state, NULL,
-			app_uri_p, NULL);
-	if (rc != SCA_APPEARANCE_OK) {
+	rc = sca_appearance_update_index(
+			sca, &aor, app_idx, app_state, NULL, app_uri_p, NULL);
+	if(rc != SCA_APPEARANCE_OK) {
 		rpc->fault(ctx, 500, "Failed to update %.*s appearance-index %d",
 				STR_FMT(&aor), app_idx);
 		return;
 	}
 
-	if (sca_notify_call_info_subscribers(sca, &aor) < 0) {
+	if(sca_notify_call_info_subscribers(sca, &aor) < 0) {
 		rpc->fault(ctx, 500, "Failed to NOTIFY subscribers to %.*s",
 				STR_FMT(&aor));
 	}
@@ -473,22 +465,22 @@ void sca_rpc_release_appearance(rpc_t *rpc, void *ctx)
 	int idx = -1;
 	int app_idx;
 	char *usage = "usage: sca.release_appearance user@domain "
-			"appearance-index";
+				  "appearance-index";
 	char *err_msg = NULL;
 	int err_code = 0;
 
 	// AoR & appearance-index are required
-	if (rpc->scan(ctx, "Sd", &aor, &app_idx) != 2) {
+	if(rpc->scan(ctx, "Sd", &aor, &app_idx) != 2) {
 		rpc->fault(ctx, 500, usage);
 		return;
 	}
 
-	if (app_idx <= 0) {
+	if(app_idx <= 0) {
 		rpc->fault(ctx, 500, "appearance-index must be > 0");
 		return;
 	}
 
-	if ((ht = sca->appearances) == NULL) {
+	if((ht = sca->appearances) == NULL) {
 		rpc->fault(ctx, 500, "No active appearances");
 		return;
 	}
@@ -496,37 +488,38 @@ void sca_rpc_release_appearance(rpc_t *rpc, void *ctx)
 	idx = sca_hash_table_index_for_key(ht, &aor);
 	sca_hash_table_lock_index(ht, idx);
 
-	for (ent = ht->slots[idx].entries; ent != NULL; ent = ent->next) {
-		if (ent->compare(&aor, ent->value) == 0) {
-			app_list = (sca_appearance_list *) ent->value;
+	for(ent = ht->slots[idx].entries; ent != NULL; ent = ent->next) {
+		if(ent->compare(&aor, ent->value) == 0) {
+			app_list = (sca_appearance_list *)ent->value;
 			break;
 		}
 	}
-	if (app_list == NULL) {
+	if(app_list == NULL) {
 		rpc->fault(ctx, 500, "No appearances for %.*s", STR_FMT(&aor));
 		goto done;
 	}
 
 	app = sca_appearance_list_unlink_index(app_list, app_idx);
-	if (app == NULL) {
+	if(app == NULL) {
 		rpc->fault(ctx, 500, "%.*s appearance index %d is not in use",
 				STR_FMT(&aor), app_idx);
 		goto done;
 	}
 	sca_appearance_free(app);
 
-	done: if (ht && idx >= 0) {
+done:
+	if(ht && idx >= 0) {
 		sca_hash_table_unlock_index(ht, idx);
 	}
 
-	if (app != NULL) {
-		if (sca_notify_call_info_subscribers(sca, &aor) < 0) {
+	if(app != NULL) {
+		if(sca_notify_call_info_subscribers(sca, &aor) < 0) {
 			rpc->fault(ctx, 500, "Failed to NOTIFY subscribers to %.*s",
 					STR_FMT(&aor));
 		}
 	}
 
-	if (err_code != 0) {
+	if(err_code != 0) {
 		rpc->fault(ctx, err_code, err_msg);
 	}
 }
diff --git a/src/modules/sca/sca_subscribe.c b/src/modules/sca/sca_subscribe.c
index 8040d49..dc33f00 100644
--- a/src/modules/sca/sca_subscribe.c
+++ b/src/modules/sca/sca_subscribe.c
@@ -41,7 +41,8 @@ void sca_subscription_print(void *);
 
 const str SCA_METHOD_SUBSCRIBE = STR_STATIC_INIT("SUBSCRIBE");
 
-struct sca_sub_state_table {
+struct sca_sub_state_table
+{
 	int state;
 	char *state_name;
 } state_table[] = {
@@ -74,7 +75,7 @@ void sca_subscription_state_to_str(int state, str *state_str_out)
 
 void sca_subscription_purge_expired(unsigned int ticks, void *param)
 {
-	sca_mod *scam = (sca_mod *) param;
+	sca_mod *scam = (sca_mod *)param;
 	sca_hash_table *ht;
 	sca_hash_entry *ent, *ent_tmp;
 	sca_subscription *sub;
@@ -88,46 +89,48 @@ void sca_subscription_purge_expired(unsigned int ticks, void *param)
 	LM_INFO("SCA: purging expired subscriptions\n");
 
 	ht = scam->subscriptions;
-	for (i = 0; i < ht->size; i++) {
+	for(i = 0; i < ht->size; i++) {
 		sca_hash_table_lock_index(ht, i);
 
-		for (ent = ht->slots[i].entries; ent != NULL; ent = ent_tmp) {
+		for(ent = ht->slots[i].entries; ent != NULL; ent = ent_tmp) {
 			ent_tmp = ent->next;
 
-			sub = (sca_subscription *) ent->value;
-			if (sub == NULL || sub->expires > now) {
+			sub = (sca_subscription *)ent->value;
+			if(sub == NULL || sub->expires > now) {
 				continue;
 			}
 
-			if (!SCA_SUBSCRIPTION_IS_TERMINATED(sub)) {
+			if(!SCA_SUBSCRIPTION_IS_TERMINATED(sub)) {
 				sub->state = SCA_SUBSCRIPTION_STATE_TERMINATED_TIMEOUT;
 				sub->expires = 0;
 				sub->dialog.notify_cseq += 1;
 
-				if (sca_notify_subscriber(scam, sub, sub->index) < 0) {
+				if(sca_notify_subscriber(scam, sub, sub->index) < 0) {
 					LM_ERR("Failed to send subscription expired "
-							"NOTIFY %s subscriber %.*s\n",
+						   "NOTIFY %s subscriber %.*s\n",
 							sca_event_name_from_type(sub->event),
 							STR_FMT(&sub->subscriber));
 
 					// remove from subscribers list anyway
 				}
-				if (sub->event == SCA_EVENT_TYPE_LINE_SEIZE) {
+				if(sub->event == SCA_EVENT_TYPE_LINE_SEIZE) {
 					// only notify if the line is just seized
-					state = sca_appearance_state_for_index(sca,
-							&sub->target_aor, sub->index);
-					if (state == SCA_APPEARANCE_STATE_SEIZED) {
-						if (sca_appearance_release_index(sca, &sub->target_aor,
-								sub->index) < 0) {
+					state = sca_appearance_state_for_index(
+							sca, &sub->target_aor, sub->index);
+					if(state == SCA_APPEARANCE_STATE_SEIZED) {
+						if(sca_appearance_release_index(
+								   sca, &sub->target_aor, sub->index)
+								< 0) {
 							LM_ERR("Failed to release seized %.*s "
-									"appearance-index %d\n",
+								   "appearance-index %d\n",
 									STR_FMT(&sub->target_aor), sub->index);
 						}
 
-						if (sca_notify_call_info_subscribers(sca,
-								&sub->target_aor) < 0) {
+						if(sca_notify_call_info_subscribers(
+								   sca, &sub->target_aor)
+								< 0) {
 							LM_ERR("SCA %s NOTIFY to all %.*s "
-									"subscribers failed\n",
+								   "subscribers failed\n",
 									sca_event_name_from_type(sub->event),
 									STR_FMT(&sub->target_aor));
 							// fall through anyway. the state should propagate
@@ -159,32 +162,32 @@ int sca_subscription_from_db_row_values(db_val_t *values, sca_subscription *sub)
 	assert(sub != NULL);
 
 	// XXX condense to loop with preprocessor macros when there's time
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_SUBSCRIBER_COL,
-			values, &sub->subscriber);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_AOR_COL, values,
-			&sub->target_aor);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_EVENT_COL, values,
-			&sub->event);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_EXPIRES_COL, values,
-			&sub->expires);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_STATE_COL, values,
-			&sub->state);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_APP_IDX_COL, values,
-			&sub->index);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_CALL_ID_COL, values,
-			&sub->dialog.call_id);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_FROM_TAG_COL, values,
-			&sub->dialog.from_tag);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_TO_TAG_COL, values,
-			&sub->dialog.to_tag);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_RECORD_ROUTE_COL,
-			values, &sub->rr);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_NOTIFY_CSEQ_COL,
-			values, &sub->dialog.notify_cseq);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_SUBSCRIBER_COL, values, &sub->subscriber);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_AOR_COL, values, &sub->target_aor);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_EVENT_COL, values, &sub->event);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_EXPIRES_COL, values, &sub->expires);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_STATE_COL, values, &sub->state);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_APP_IDX_COL, values, &sub->index);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_CALL_ID_COL, values, &sub->dialog.call_id);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_FROM_TAG_COL, values, &sub->dialog.from_tag);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_TO_TAG_COL, values, &sub->dialog.to_tag);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_RECORD_ROUTE_COL, values, &sub->rr);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_NOTIFY_CSEQ_COL, values, &sub->dialog.notify_cseq);
 	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_SUBSCRIBE_CSEQ_COL,
 			values, &sub->dialog.subscribe_cseq);
-	sca_db_subscriptions_get_value_for_column(SCA_DB_SUBS_SERVER_ID_COL,
-			values, &sub->server_id);
+	sca_db_subscriptions_get_value_for_column(
+			SCA_DB_SUBS_SERVER_ID_COL, values, &sub->server_id);
 
 	return (0);
 }
@@ -196,35 +199,35 @@ int sca_subscription_to_db_row_values(sca_subscription *sub, db_val_t *values)
 	assert(sub != NULL);
 	assert(values != NULL);
 
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_SUBSCRIBER_COL,
-			values, &sub->subscriber);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_AOR_COL, values,
-			&sub->target_aor);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_EVENT_COL, values,
-			&sub->event);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_EXPIRES_COL, values,
-			&sub->expires);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_STATE_COL, values,
-			&sub->state);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_APP_IDX_COL, values,
-			&sub->index);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_CALL_ID_COL, values,
-			&sub->dialog.call_id);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_FROM_TAG_COL, values,
-			&sub->dialog.from_tag);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_TO_TAG_COL, values,
-			&sub->dialog.to_tag);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_RECORD_ROUTE_COL,
-			values, &sub->rr);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_SUBSCRIBER_COL, values, &sub->subscriber);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_AOR_COL, values, &sub->target_aor);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_EVENT_COL, values, &sub->event);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_EXPIRES_COL, values, &sub->expires);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_STATE_COL, values, &sub->state);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_APP_IDX_COL, values, &sub->index);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_CALL_ID_COL, values, &sub->dialog.call_id);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_FROM_TAG_COL, values, &sub->dialog.from_tag);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_TO_TAG_COL, values, &sub->dialog.to_tag);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_RECORD_ROUTE_COL, values, &sub->rr);
 
 	notify_cseq = sub->dialog.notify_cseq + 1;
 	subscribe_cseq = sub->dialog.subscribe_cseq + 1;
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_NOTIFY_CSEQ_COL,
-			values, &notify_cseq);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_SUBSCRIBE_CSEQ_COL,
-			values, &subscribe_cseq);
-	sca_db_subscriptions_set_value_for_column(SCA_DB_SUBS_SERVER_ID_COL,
-			values, &sub->server_id);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_NOTIFY_CSEQ_COL, values, &notify_cseq);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_SUBSCRIBE_CSEQ_COL, values, &subscribe_cseq);
+	sca_db_subscriptions_set_value_for_column(
+			SCA_DB_SUBS_SERVER_ID_COL, values, &sub->server_id);
 
 	return (0);
 }
@@ -250,71 +253,74 @@ int sca_subscriptions_restore_from_db(sca_mod *scam)
 	time_t now = time(NULL);
 
 	db_con = scam->db_api->init(scam->cfg->db_url);
-	if (db_con == NULL) {
+	if(db_con == NULL) {
 		LM_ERR("sca_subscriptions_restore_from_db: failed to connect "
-				"to DB %.*s\n", STR_FMT(scam->cfg->db_url));
+			   "to DB %.*s\n",
+				STR_FMT(scam->cfg->db_url));
 		return (-1);
 	}
 
 	scam->db_api->use_table(db_con, scam->cfg->subs_table);
 
 	column_names = sca_db_subscriptions_columns();
-	if (column_names == NULL) {
+	if(column_names == NULL) {
 		LM_ERR("sca_subscriptions_restore_from_db: failed to get "
-				"column names for SCA subscriptions table\n");
+			   "column names for SCA subscriptions table\n");
 		goto done;
 	}
 
-	for (i = 0; i < SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS; i++) {
+	for(i = 0; i < SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS; i++) {
 		result_columns[i] = column_names[i];
 	}
 
-	query_columns[q_count] = (str *) &SCA_DB_SERVER_ID_COL_NAME;
+	query_columns[q_count] = (str *)&SCA_DB_SERVER_ID_COL_NAME;
 	query_ops[q_count] = OP_EQ;
 	SCA_DB_BIND_INT_VALUE(server_id, &SCA_DB_SERVER_ID_COL_NAME, query_columns,
-		query_values, q_count);
+			query_values, q_count);
 
 	rc = db_fetch_query(scam->db_api, SCA_DB_DEFAULT_FETCH_ROW_COUNT, db_con,
 			query_columns, query_ops, query_values, result_columns, q_count,
 			SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS, 0, &result);
-	switch (rc) {
-	default:
-	case -1:
-		LM_ERR("sca_subscriptions_restore_from_db: query failed\n");
-		goto done;
+	switch(rc) {
+		default:
+		case -1:
+			LM_ERR("sca_subscriptions_restore_from_db: query failed\n");
+			goto done;
 
-	case 0:
-		LM_WARN("sca_subscriptions_restore_from_db: DB module does "
-				"not support fetch, query returning all values...\n");
-		// fall through
+		case 0:
+			LM_WARN("sca_subscriptions_restore_from_db: DB module does "
+					"not support fetch, query returning all values...\n");
+			// fall through
 
-	case 1:
-		break;
+		case 1:
+			break;
 	}
 
 	do {
 		rows = RES_ROWS(result);
 		num_rows = RES_ROW_N(result);
 
-		for (i = 0; i < num_rows; i++) {
+		for(i = 0; i < num_rows; i++) {
 			memset(&sub, 0, sizeof(sca_subscription));
 
 			row_values = ROW_VALUES(rows + i);
 
 			sub.expires = row_values[SCA_DB_SUBS_EXPIRES_COL].val.time_val;
-			if (sub.expires < now) {
+			if(sub.expires < now) {
 				continue;
 			}
 
-			if (sca_subscription_from_db_row_values(row_values, &sub) < 0) {
+			if(sca_subscription_from_db_row_values(row_values, &sub) < 0) {
 				LM_ERR("sca_subscriptions_restore_from_db: skipping bad result "
-						"at index %d\n", i);
+					   "at index %d\n",
+						i);
 				continue;
 			}
 
-			if (sca_subscription_copy_subscription_key(&sub, &sub_key) < 0) {
+			if(sca_subscription_copy_subscription_key(&sub, &sub_key) < 0) {
 				LM_ERR("sca_subscriptions_restore_from_db: failed to copy "
-						"subscription key %.*s%s\n", STR_FMT(&sub.subscriber),
+					   "subscription key %.*s%s\n",
+						STR_FMT(&sub.subscriber),
 						sca_event_name_from_type(sub.event));
 				continue;
 			}
@@ -324,10 +330,11 @@ int sca_subscriptions_restore_from_db(sca_mod *scam)
 
 			sca_hash_table_lock_index(sca->subscriptions, idx);
 
-			if (sca_subscription_save_unsafe(scam, &sub, idx,
-					SCA_SUBSCRIPTION_CREATE_OPT_RAW_EXPIRES) < 0) {
+			if(sca_subscription_save_unsafe(
+					   scam, &sub, idx, SCA_SUBSCRIPTION_CREATE_OPT_RAW_EXPIRES)
+					< 0) {
 				LM_ERR("sca_subscriptions_restore_from_db: failed to restore "
-						"%s subscription from %.*s to the hash table\n",
+					   "%s subscription from %.*s to the hash table\n",
 						sca_event_name_from_type(sub.event),
 						STR_FMT(&sub.subscriber));
 				// fall through to unlock index
@@ -335,28 +342,31 @@ int sca_subscriptions_restore_from_db(sca_mod *scam)
 
 			sca_hash_table_unlock_index(sca->subscriptions, idx);
 		}
-	} while (db_fetch_next(scam->db_api, SCA_DB_DEFAULT_FETCH_ROW_COUNT, db_con,
-			&result) == 1 && num_rows > 0);
+	} while(db_fetch_next(scam->db_api, SCA_DB_DEFAULT_FETCH_ROW_COUNT, db_con,
+					&result)
+					== 1
+			&& num_rows > 0);
 
 	scam->db_api->free_result(db_con, result);
 
 	// clear all records from table, let timer process repopulate it
-	if (scam->db_api->delete(db_con, NULL, NULL, NULL, 0) < 0) {
+	if(scam->db_api->delete(db_con, NULL, NULL, NULL, 0) < 0) {
 		LM_ERR("sca_subscriptions_restore_from_db: failed to delete "
-				"records from table after restoring\n");
+			   "records from table after restoring\n");
 		goto done;
 	}
 
 	rc = 0;
 
-	done: scam->db_api->close(db_con);
+done:
+	scam->db_api->close(db_con);
 	db_con = NULL;
 
 	return (rc);
 }
 
-static int sca_subscription_db_update_subscriber(db1_con_t *db_con,
-		sca_subscription *sub)
+static int sca_subscription_db_update_subscriber(
+		db1_con_t *db_con, sca_subscription *sub)
 {
 	db_key_t query_columns[1];
 	db_val_t query_values[1];
@@ -388,11 +398,12 @@ static int sca_subscription_db_update_subscriber(db1_con_t *db_con,
 			&SCA_DB_SUBSCRIBE_CSEQ_COL_NAME, update_columns, update_values,
 			update_column_idx);
 
-	if (sca->db_api->update(db_con, query_columns, NULL, query_values,
-			update_columns, update_values, query_column_idx, update_column_idx)
+	if(sca->db_api->update(db_con, query_columns, NULL, query_values,
+			   update_columns, update_values, query_column_idx,
+			   update_column_idx)
 			< 0) {
 		LM_ERR("sca_subscription_db_update_subscriber: failed to update "
-				"%s subscriber %.*s in DB\n",
+			   "%s subscriber %.*s in DB\n",
 				sca_event_name_from_type(sub->event),
 				STR_FMT(&sub->subscriber));
 		return (-1);
@@ -404,8 +415,8 @@ static int sca_subscription_db_update_subscriber(db1_con_t *db_con,
 	return (0);
 }
 
-static int sca_subscription_db_insert_subscriber(db1_con_t *db_con,
-		sca_subscription *sub)
+static int sca_subscription_db_insert_subscriber(
+		db1_con_t *db_con, sca_subscription *sub)
 {
 	db_key_t insert_columns[SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS];
 	db_val_t insert_values[SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS];
@@ -416,29 +427,30 @@ static int sca_subscription_db_insert_subscriber(db1_con_t *db_con,
 	assert(sub != NULL);
 
 	column_names = sca_db_subscriptions_columns();
-	if (column_names == NULL) {
+	if(column_names == NULL) {
 		LM_ERR("sca_subscriptions_restore_from_db: failed to get "
-				"column names for SCA subscriptions table\n");
+			   "column names for SCA subscriptions table\n");
 		return (-1);
 	}
 
-	for (i = 0; i < SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS; i++) {
+	for(i = 0; i < SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS; i++) {
 		insert_columns[i] = column_names[i];
 	}
 
 	// XXX array boundary checking
-	if (sca_subscription_to_db_row_values(sub, insert_values) != 0) {
+	if(sca_subscription_to_db_row_values(sub, insert_values) != 0) {
 		LM_ERR("sca_subscription_db_insert_subscriber: failed to set "
-				"DB row values for INSERT of %s subscriber %.*s\n",
+			   "DB row values for INSERT of %s subscriber %.*s\n",
 				sca_event_name_from_type(sub->event),
 				STR_FMT(&sub->subscriber));
 		return (-1);
 	}
 
-	if (sca->db_api->insert(db_con, insert_columns, insert_values,
-	SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS) < 0) {
+	if(sca->db_api->insert(db_con, insert_columns, insert_values,
+			   SCA_DB_SUBSCRIPTIONS_NUM_COLUMNS)
+			< 0) {
 		LM_ERR("sca_subscription_db_insert_subscriber: failed to insert "
-				"%s subscriber %.*s in DB subscription table\n",
+			   "%s subscriber %.*s in DB subscription table\n",
 				sca_event_name_from_type(sub->event),
 				STR_FMT(&sub->subscriber));
 		return (-1);
@@ -458,22 +470,24 @@ int sca_subscription_db_delete_expired(db1_con_t *db_con)
 	time_t now = time(NULL);
 	int kv_count = 0;
 
-	delete_columns[kv_count] = (str *) &SCA_DB_SERVER_ID_COL_NAME;
+	delete_columns[kv_count] = (str *)&SCA_DB_SERVER_ID_COL_NAME;
 	delete_ops[kv_count] = OP_EQ;
 
 	SCA_DB_BIND_INT_VALUE(server_id, &SCA_DB_SERVER_ID_COL_NAME, delete_columns,
 			delete_values, kv_count);
 
-	delete_columns[kv_count] = (str *) &SCA_DB_EXPIRES_COL_NAME;
+	delete_columns[kv_count] = (str *)&SCA_DB_EXPIRES_COL_NAME;
 	delete_ops[kv_count] = OP_LT;
 
 	SCA_DB_BIND_INT_VALUE(now, &SCA_DB_EXPIRES_COL_NAME, delete_columns,
 			delete_values, kv_count);
 
-	if (sca->db_api->delete(db_con, delete_columns, delete_ops, delete_values,
-			kv_count) < 0) {
+	if(sca->db_api->delete(
+			   db_con, delete_columns, delete_ops, delete_values, kv_count)
+			< 0) {
 		LM_ERR("sca_subscription_db_delete_expired: failed to delete "
-				"subscriptions expired before %ld\n", (long int)now);
+			   "subscriptions expired before %ld\n",
+				(long int)now);
 		return (-1);
 	}
 
@@ -491,48 +505,49 @@ int sca_subscription_db_update(void)
 	time_t now = time(NULL);
 
 	db_con = sca_db_get_connection();
-	if (db_con == NULL) {
+	if(db_con == NULL) {
 		LM_ERR("sca_subscription_db_update: failed to connect to DB %.*s\n",
 				STR_FMT(sca->cfg->db_url));
 		goto done;
 	}
-	if (sca->db_api->use_table(db_con, sca->cfg->subs_table) < 0) {
+	if(sca->db_api->use_table(db_con, sca->cfg->subs_table) < 0) {
 		LM_ERR("sca_subscription_db_update: failed to in-use table "
-				"for DB %.*s\n", STR_FMT(sca->cfg->db_url));
+			   "for DB %.*s\n",
+				STR_FMT(sca->cfg->db_url));
 		goto done;
 	}
 
 	ht = sca->subscriptions;
-	for (i = 0; i < ht->size; i++) {
+	for(i = 0; i < ht->size; i++) {
 		sca_hash_table_lock_index(ht, i);
 
-		for (entry = ht->slots[i].entries; entry != NULL; entry = entry->next) {
-			sub = (sca_subscription *) entry->value;
+		for(entry = ht->slots[i].entries; entry != NULL; entry = entry->next) {
+			sub = (sca_subscription *)entry->value;
 
-			if (sub == NULL || sub->expires < now) {
+			if(sub == NULL || sub->expires < now) {
 				continue;
 			}
 
 			// we only do call-info subscriptions for now
-			if (sub->event != SCA_EVENT_TYPE_CALL_INFO) {
+			if(sub->event != SCA_EVENT_TYPE_CALL_INFO) {
 				continue;
 			}
 
-			if (SCA_SUBSCRIPTION_IS_TERMINATED(sub)) {
+			if(SCA_SUBSCRIPTION_IS_TERMINATED(sub)) {
 				continue;
 			}
 
-			if (sub->db_cmd_flag == SCA_DB_FLAG_INSERT) {
-				if (sca_subscription_db_insert_subscriber(db_con, sub) < 0) {
+			if(sub->db_cmd_flag == SCA_DB_FLAG_INSERT) {
+				if(sca_subscription_db_insert_subscriber(db_con, sub) < 0) {
 					LM_ERR("sca_subscription_db_update: failed to insert "
-							"%s subscriber %.*s into subscription DB\n",
+						   "%s subscriber %.*s into subscription DB\n",
 							sca_event_name_from_type(sub->event),
 							STR_FMT(&sub->subscriber));
 				}
-			} else if (sub->db_cmd_flag == SCA_DB_FLAG_UPDATE) {
-				if (sca_subscription_db_update_subscriber(db_con, sub) < 0) {
+			} else if(sub->db_cmd_flag == SCA_DB_FLAG_UPDATE) {
+				if(sca_subscription_db_update_subscriber(db_con, sub) < 0) {
 					LM_ERR("sca_subscription_db_update: failed to insert "
-							"%s subscriber %.*s into subscription DB\n",
+						   "%s subscriber %.*s into subscription DB\n",
 							sca_event_name_from_type(sub->event),
 							STR_FMT(&sub->subscriber));
 				}
@@ -544,14 +559,16 @@ int sca_subscription_db_update(void)
 
 	rc = sca_subscription_db_delete_expired(db_con);
 
-	done: return (rc);
+done:
+	return (rc);
 }
 
 void sca_subscription_db_update_timer(unsigned int ticks, void *param)
 {
-	if (sca_subscription_db_update() != 0) {
+	if(sca_subscription_db_update() != 0) {
 		LM_ERR("sca_subscription_db_update_timer: failed to update "
-				"subscriptions in DB %.*s\n", STR_FMT(sca->cfg->db_url));
+			   "subscriptions in DB %.*s\n",
+				STR_FMT(sca->cfg->db_url));
 	}
 }
 
@@ -568,10 +585,11 @@ int sca_subscription_aor_has_subscribers(int event, str *aor)
 
 	event_name = sca_event_name_from_type(event);
 	len = aor->len + strlen(event_name);
-	sub_key.s = (char *) pkg_malloc(len);
-	if (sub_key.s == NULL) {
+	sub_key.s = (char *)pkg_malloc(len);
+	if(sub_key.s == NULL) {
 		LM_ERR("Failed to pkg_malloc key to look up %s "
-				"subscription for %.*s\n", event_name, STR_FMT(aor));
+			   "subscription for %.*s\n",
+				event_name, STR_FMT(aor));
 		return (-1);
 	}
 	SCA_STR_COPY(&sub_key, aor);
@@ -584,10 +602,10 @@ int sca_subscription_aor_has_subscribers(int event, str *aor)
 	slot = sca_hash_table_slot_for_index(sca->subscriptions, slot_idx);
 	sca_hash_table_lock_index(sca->subscriptions, slot_idx);
 
-	for (e = slot->entries; e != NULL; e = e->next) {
-		sub = (sca_subscription *) e->value;
+	for(e = slot->entries; e != NULL; e = e->next) {
+		sub = (sca_subscription *)e->value;
 
-		if (SCA_STR_EQ(&sub->target_aor, aor)) {
+		if(SCA_STR_EQ(&sub->target_aor, aor)) {
 			subscribers = 1;
 			break;
 		}
@@ -607,12 +625,12 @@ sca_subscription *sca_subscription_create(str *aor, int event, str *subscriber,
 
 	len += sizeof(sca_subscription);
 	len += sizeof(char) * (aor->len + subscriber->len);
-	if (!SCA_STR_EMPTY(rr)) {
+	if(!SCA_STR_EMPTY(rr)) {
 		len += sizeof(char) * rr->len;
 	}
 
-	sub = (sca_subscription *) shm_malloc(len);
-	if (sub == NULL) {
+	sub = (sca_subscription *)shm_malloc(len);
+	if(sub == NULL) {
 		LM_ERR("Failed to create %s subscription for %.*s: out of memory\n",
 				sca_event_name_from_type(event), STR_FMT(subscriber));
 		goto error;
@@ -622,7 +640,7 @@ sca_subscription *sca_subscription_create(str *aor, int event, str *subscriber,
 	sub->event = event;
 	sub->state = SCA_SUBSCRIPTION_STATE_ACTIVE;
 	sub->index = SCA_CALL_INFO_APPEARANCE_INDEX_ANY;
-	if (opts & SCA_SUBSCRIPTION_CREATE_OPT_RAW_EXPIRES) {
+	if(opts & SCA_SUBSCRIPTION_CREATE_OPT_RAW_EXPIRES) {
 		sub->expires = expire_delta;
 	} else {
 		sub->expires = time(NULL) + expire_delta;
@@ -633,16 +651,16 @@ sca_subscription *sca_subscription_create(str *aor, int event, str *subscriber,
 
 	len = sizeof(sca_subscription);
 
-	sub->subscriber.s = (char *) sub + len;
+	sub->subscriber.s = (char *)sub + len;
 	SCA_STR_COPY(&sub->subscriber, subscriber);
 	len += subscriber->len;
 
-	sub->target_aor.s = (char *) sub + len;
+	sub->target_aor.s = (char *)sub + len;
 	SCA_STR_COPY(&sub->target_aor, aor);
 	len += aor->len;
 
-	if (!SCA_STR_EMPTY(rr)) {
-		sub->rr.s = (char *) sub + len;
+	if(!SCA_STR_EMPTY(rr)) {
+		sub->rr.s = (char *)sub + len;
 		SCA_STR_COPY(&sub->rr, rr);
 		len += rr->len;
 	}
@@ -654,10 +672,11 @@ sca_subscription *sca_subscription_create(str *aor, int event, str *subscriber,
 	// dialog saved for this subscriber. this is likely to happen if the
 	// subscriber goes off-line for some reason.
 	len = sizeof(char) * (call_id->len + from_tag->len + to_tag->len);
-	sub->dialog.id.s = (char *) shm_malloc(len);
-	if (sub->dialog.id.s == NULL) {
+	sub->dialog.id.s = (char *)shm_malloc(len);
+	if(sub->dialog.id.s == NULL) {
 		LM_ERR("Failed to shm_malloc space for %.*s %s subscription dialog: "
-				"out of memory\n", STR_FMT(&sub->subscriber),
+			   "out of memory\n",
+				STR_FMT(&sub->subscriber),
 				sca_event_name_from_type(sub->event));
 		goto error;
 	}
@@ -680,8 +699,9 @@ sca_subscription *sca_subscription_create(str *aor, int event, str *subscriber,
 
 	return (sub);
 
-	error: if (sub != NULL) {
-		if (sub->dialog.id.s != NULL) {
+error:
+	if(sub != NULL) {
+		if(sub->dialog.id.s != NULL) {
 			shm_free(sub->dialog.id.s);
 		}
 		shm_free(sub);
@@ -692,10 +712,10 @@ sca_subscription *sca_subscription_create(str *aor, int event, str *subscriber,
 
 int sca_subscription_subscriber_cmp(str *subscriber, void *cmp_value)
 {
-	sca_subscription *sub = (sca_subscription *) cmp_value;
+	sca_subscription *sub = (sca_subscription *)cmp_value;
 	int cmp;
 
-	if ((cmp = subscriber->len - sub->subscriber.len) != 0) {
+	if((cmp = subscriber->len - sub->subscriber.len) != 0) {
 		return (cmp);
 	}
 
@@ -704,17 +724,16 @@ int sca_subscription_subscriber_cmp(str *subscriber, void *cmp_value)
 
 void sca_subscription_free(void *value)
 {
-	sca_subscription *sub = (sca_subscription *) value;
+	sca_subscription *sub = (sca_subscription *)value;
 
-	if (sub == NULL) {
+	if(sub == NULL) {
 		return;
 	}
 
 	LM_DBG("Freeing %s subscription from %.*s\n",
-			sca_event_name_from_type(sub->event),
-			STR_FMT(&sub->subscriber));
+			sca_event_name_from_type(sub->event), STR_FMT(&sub->subscriber));
 
-	if (!SCA_STR_EMPTY(&sub->dialog.id)) {
+	if(!SCA_STR_EMPTY(&sub->dialog.id)) {
 		shm_free(sub->dialog.id.s);
 	}
 
@@ -723,28 +742,23 @@ void sca_subscription_free(void *value)
 
 void sca_subscription_print(void *value)
 {
-	sca_subscription *sub = (sca_subscription *) value;
+	sca_subscription *sub = (sca_subscription *)value;
 
 	LM_DBG("%.*s %s (%d) %.*s, expires: %ld, index: %d, "
-			"dialog %.*s;%.*s;%.*s, record_route: %.*s, "
-			"notify_cseq: %d, subscribe_cseq: %d, server_id: %d\n",
-			STR_FMT(&sub->target_aor),
-			sca_event_name_from_type(sub->event),
-			sub->event,
-			STR_FMT(&sub->subscriber),
-			(long int)sub->expires, sub->index,
-			STR_FMT(&sub->dialog.call_id),
-			STR_FMT(&sub->dialog.from_tag),
-			STR_FMT(&sub->dialog.to_tag),
+		   "dialog %.*s;%.*s;%.*s, record_route: %.*s, "
+		   "notify_cseq: %d, subscribe_cseq: %d, server_id: %d\n",
+			STR_FMT(&sub->target_aor), sca_event_name_from_type(sub->event),
+			sub->event, STR_FMT(&sub->subscriber), (long int)sub->expires,
+			sub->index, STR_FMT(&sub->dialog.call_id),
+			STR_FMT(&sub->dialog.from_tag), STR_FMT(&sub->dialog.to_tag),
 			SCA_STR_EMPTY(&sub->rr) ? 4 : sub->rr.len,
 			SCA_STR_EMPTY(&sub->rr) ? "null" : sub->rr.s,
-			sub->dialog.notify_cseq,
-			sub->dialog.subscribe_cseq,
+			sub->dialog.notify_cseq, sub->dialog.subscribe_cseq,
 			sub->server_id);
 }
 
-int sca_subscription_save_unsafe(sca_mod *scam, sca_subscription *sub,
-		int save_idx, int opts)
+int sca_subscription_save_unsafe(
+		sca_mod *scam, sca_subscription *sub, int save_idx, int opts)
 {
 	sca_subscription *new_sub = NULL;
 	sca_hash_slot *slot;
@@ -756,16 +770,16 @@ int sca_subscription_save_unsafe(sca_mod *scam, sca_subscription *sub,
 			&sub->subscriber, sub->dialog.notify_cseq,
 			sub->dialog.subscribe_cseq, sub->expires, &sub->dialog.call_id,
 			&sub->dialog.from_tag, &sub->dialog.to_tag, &sub->rr, opts);
-	if (new_sub == NULL) {
+	if(new_sub == NULL) {
 		return (-1);
 	}
-	if (sub->index != SCA_CALL_INFO_APPEARANCE_INDEX_ANY) {
+	if(sub->index != SCA_CALL_INFO_APPEARANCE_INDEX_ANY) {
 		new_sub->index = sub->index;
 	}
 
-	if (sca_appearance_register(scam, &sub->target_aor) < 0) {
+	if(sca_appearance_register(scam, &sub->target_aor) < 0) {
 		LM_ERR("sca_subscription_save: sca_appearance_register failed, "
-				"still saving subscription from %.*s\n",
+			   "still saving subscription from %.*s\n",
 				STR_FMT(&sub->subscriber));
 	}
 
@@ -773,7 +787,7 @@ int sca_subscription_save_unsafe(sca_mod *scam, sca_subscription *sub,
 	rc = sca_hash_table_slot_kv_insert_unsafe(slot, new_sub,
 			sca_subscription_subscriber_cmp, sca_subscription_print,
 			sca_subscription_free);
-	if (rc < 0) {
+	if(rc < 0) {
 		shm_free(new_sub);
 		new_sub = NULL;
 	}
@@ -788,38 +802,40 @@ static int sca_subscription_update_unsafe(sca_mod *scam,
 	int len;
 	char *dlg_id_tmp;
 
-	if (sub_idx < 0 || sub_idx > scam->subscriptions->size) {
+	if(sub_idx < 0 || sub_idx > scam->subscriptions->size) {
 		LM_ERR("Invalid hash table index %d\n", sub_idx);
 		goto done;
 	}
 
 	// sanity checks first
-	if (saved_sub->event != update_sub->event) {
+	if(saved_sub->event != update_sub->event) {
 		LM_ERR("Event mismatch for in-dialog SUBSCRIBE from %.*s: "
-				"%s != %s\n", STR_FMT(&update_sub->subscriber),
+			   "%s != %s\n",
+				STR_FMT(&update_sub->subscriber),
 				sca_event_name_from_type(saved_sub->event),
 				sca_event_name_from_type(update_sub->event));
 		goto done;
 	}
-	if (!STR_EQ(saved_sub->subscriber, update_sub->subscriber)) {
+	if(!STR_EQ(saved_sub->subscriber, update_sub->subscriber)) {
 		LM_ERR("Contact mismatch for in-dialog SUBSCRIBE from %.*s: "
-				"%.*s != %.*s\n", STR_FMT(&update_sub->subscriber),
+			   "%.*s != %.*s\n",
+				STR_FMT(&update_sub->subscriber),
 				STR_FMT(&update_sub->subscriber),
 				STR_FMT(&saved_sub->subscriber));
 		goto done;
 	}
-	if (!STR_EQ(saved_sub->target_aor, update_sub->target_aor)) {
+	if(!STR_EQ(saved_sub->target_aor, update_sub->target_aor)) {
 		LM_ERR("AoR mismatch for in-dialog SUBSCRIBE from %.*s: "
-				"%.*s != %.*s\n", STR_FMT(&update_sub->subscriber),
+			   "%.*s != %.*s\n",
+				STR_FMT(&update_sub->subscriber),
 				STR_FMT(&update_sub->target_aor),
 				STR_FMT(&saved_sub->target_aor));
 		goto done;
 	}
 
-	if (!STR_EQ(saved_sub->dialog.call_id, update_sub->dialog.call_id) ||
-	!STR_EQ(saved_sub->dialog.from_tag,
-			update_sub->dialog.from_tag) ||
-	!STR_EQ(saved_sub->dialog.to_tag, update_sub->dialog.to_tag)) {
+	if(!STR_EQ(saved_sub->dialog.call_id, update_sub->dialog.call_id)
+			|| !STR_EQ(saved_sub->dialog.from_tag, update_sub->dialog.from_tag)
+			|| !STR_EQ(saved_sub->dialog.to_tag, update_sub->dialog.to_tag)) {
 		// mismatched dialog. we assume a subscriber can hold only one
 		// subscription per event at any given time, so we replace the old
 		// one with the new.
@@ -827,14 +843,15 @@ static int sca_subscription_update_unsafe(sca_mod *scam,
 
 		// this is allocated separately from the rest of the subscription
 		len = sizeof(char *)
-				* (update_sub->dialog.call_id.len
-						+ update_sub->dialog.from_tag.len
-						+ update_sub->dialog.to_tag.len);
+			  * (update_sub->dialog.call_id.len
+					  + update_sub->dialog.from_tag.len
+					  + update_sub->dialog.to_tag.len);
 
-		dlg_id_tmp = (char *) shm_malloc(len);
-		if (dlg_id_tmp == NULL) {
+		dlg_id_tmp = (char *)shm_malloc(len);
+		if(dlg_id_tmp == NULL) {
 			LM_ERR("Failed to replace %.*s %s subscription dialog: "
-					"shm_malloc failed\n", STR_FMT(&update_sub->subscriber),
+				   "shm_malloc failed\n",
+					STR_FMT(&update_sub->subscriber),
 					sca_event_name_from_type(update_sub->event));
 			// XXX should remove subscription entirely here?
 		} else {
@@ -849,13 +866,13 @@ static int sca_subscription_update_unsafe(sca_mod *scam,
 			saved_sub->dialog.call_id.s = saved_sub->dialog.id.s;
 			saved_sub->dialog.call_id.len = update_sub->dialog.call_id.len;
 
-			saved_sub->dialog.from_tag.s = saved_sub->dialog.id.s
-					+ update_sub->dialog.call_id.len;
+			saved_sub->dialog.from_tag.s =
+					saved_sub->dialog.id.s + update_sub->dialog.call_id.len;
 			saved_sub->dialog.from_tag.len = update_sub->dialog.from_tag.len;
 
 			saved_sub->dialog.to_tag.s = saved_sub->dialog.id.s
-					+ update_sub->dialog.call_id.len
-					+ update_sub->dialog.from_tag.len;
+										 + update_sub->dialog.call_id.len
+										 + update_sub->dialog.from_tag.len;
 			saved_sub->dialog.to_tag.len = update_sub->dialog.to_tag.len;
 		}
 	}
@@ -866,11 +883,11 @@ static int sca_subscription_update_unsafe(sca_mod *scam,
 	saved_sub->expires = time(NULL) + update_sub->expires;
 
 	// flag subscription for DB update only if we've already inserted
-	if (saved_sub->db_cmd_flag == SCA_DB_FLAG_NONE) {
+	if(saved_sub->db_cmd_flag == SCA_DB_FLAG_NONE) {
 		saved_sub->db_cmd_flag = SCA_DB_FLAG_UPDATE;
 	}
 
-	if (update_sub->index != SCA_CALL_INFO_APPEARANCE_INDEX_ANY) {
+	if(update_sub->index != SCA_CALL_INFO_APPEARANCE_INDEX_ANY) {
 		saved_sub->index = update_sub->index;
 	}
 
@@ -878,11 +895,12 @@ static int sca_subscription_update_unsafe(sca_mod *scam,
 	update_sub->dialog.notify_cseq = saved_sub->dialog.notify_cseq;
 
 	// ensure we send the NOTIFY back through the same path as the SUBSCRIBE
-	if (SCA_STR_EMPTY(&update_sub->rr) && !SCA_STR_EMPTY(&saved_sub->rr)) {
-		update_sub->rr.s = (char *) pkg_malloc(saved_sub->rr.len);
-		if (update_sub->rr.s == NULL) {
+	if(SCA_STR_EMPTY(&update_sub->rr) && !SCA_STR_EMPTY(&saved_sub->rr)) {
+		update_sub->rr.s = (char *)pkg_malloc(saved_sub->rr.len);
+		if(update_sub->rr.s == NULL) {
 			LM_ERR("sca_subscription_update_unsafe: pkg_malloc record-route "
-					"value %.*s failed\n", STR_FMT(&saved_sub->rr));
+				   "value %.*s failed\n",
+					STR_FMT(&saved_sub->rr));
 			goto done;
 		}
 
@@ -891,11 +909,12 @@ static int sca_subscription_update_unsafe(sca_mod *scam,
 
 	rc = 1;
 
-	done: return (rc);
+done:
+	return (rc);
 }
 
-static int sca_subscription_copy_subscription_key(sca_subscription *sub,
-		str *key_out)
+static int sca_subscription_copy_subscription_key(
+		sca_subscription *sub, str *key_out)
 {
 	char *event_name;
 	int len;
@@ -907,8 +926,8 @@ static int sca_subscription_copy_subscription_key(sca_subscription *sub,
 	event_name = sca_event_name_from_type(sub->event);
 	len += strlen(event_name);
 
-	key_out->s = (char *) pkg_malloc(len);
-	if (key_out->s == NULL) {
+	key_out->s = (char *)pkg_malloc(len);
+	if(key_out->s == NULL) {
 		LM_ERR("Failed to pkg_malloc space for subscription key\n");
 		return (-1);
 	}
@@ -919,8 +938,8 @@ static int sca_subscription_copy_subscription_key(sca_subscription *sub,
 	return (key_out->len);
 }
 
-int sca_subscription_delete_subscriber_for_event(sca_mod *scam, str *subscriber,
-		str *event, str *aor)
+int sca_subscription_delete_subscriber_for_event(
+		sca_mod *scam, str *subscriber, str *event, str *aor)
 {
 	sca_hash_slot *slot;
 	sca_hash_entry *ent;
@@ -932,9 +951,9 @@ int sca_subscription_delete_subscriber_for_event(sca_mod *scam, str *subscriber,
 	len = aor->len;
 	len += event->len;
 
-	if (len >= sizeof(skbuf)) {
-		LM_ERR("Subscription key %.*s%.*s: too long\n",
-				STR_FMT(aor), STR_FMT(event));
+	if(len >= sizeof(skbuf)) {
+		LM_ERR("Subscription key %.*s%.*s: too long\n", STR_FMT(aor),
+				STR_FMT(event));
 		return (-1);
 	}
 
@@ -948,13 +967,13 @@ int sca_subscription_delete_subscriber_for_event(sca_mod *scam, str *subscriber,
 	sca_hash_table_lock_index(scam->subscriptions, slot_idx);
 
 	ent = sca_hash_table_slot_kv_find_entry_unsafe(slot, subscriber);
-	if (ent != NULL) {
+	if(ent != NULL) {
 		ent = sca_hash_table_slot_unlink_entry_unsafe(slot, ent);
 	}
 
 	sca_hash_table_unlock_index(sca->subscriptions, slot_idx);
 
-	if (ent != NULL) {
+	if(ent != NULL) {
 		sca_hash_entry_free(ent);
 	}
 
@@ -971,8 +990,7 @@ int sca_subscription_from_request(sca_mod *scam, sip_msg_t *msg, int event_type,
 	struct to_body *to, *from;
 	str contact_uri;
 	str to_tag = STR_NULL;
-	unsigned int expires = 0,
-	max_expires;
+	unsigned int expires = 0, max_expires;
 	unsigned int cseq;
 	str *ruri = NULL;
 
@@ -981,113 +999,112 @@ int sca_subscription_from_request(sca_mod *scam, sip_msg_t *msg, int event_type,
 	memset(req_sub, 0, sizeof(sca_subscription));
 
 	// parse required info first
-	if (!SCA_HEADER_EMPTY(msg->expires)) {
-		if (parse_expires(msg->expires) < 0) {
+	if(!SCA_HEADER_EMPTY(msg->expires)) {
+		if(parse_expires(msg->expires) < 0) {
 			LM_ERR("Failed to parse Expires header\n");
 			goto error;
 		}
 
-		expires = ((exp_body_t *) msg->expires->parsed)->val;
+		expires = ((exp_body_t *)msg->expires->parsed)->val;
 	}
 
-	switch (event_type) {
-	case SCA_EVENT_TYPE_CALL_INFO:
-	default:
-		max_expires = scam->cfg->call_info_max_expires;
-		break;
+	switch(event_type) {
+		case SCA_EVENT_TYPE_CALL_INFO:
+		default:
+			max_expires = scam->cfg->call_info_max_expires;
+			break;
 
-	case SCA_EVENT_TYPE_LINE_SEIZE:
-		max_expires = scam->cfg->line_seize_max_expires;
-		break;
+		case SCA_EVENT_TYPE_LINE_SEIZE:
+			max_expires = scam->cfg->line_seize_max_expires;
+			break;
 	}
 
-	if (expires && expires > max_expires) {
+	if(expires && expires > max_expires) {
 		expires = max_expires;
 	}
 
-	if (SCA_HEADER_EMPTY(msg->to)) {
+	if(SCA_HEADER_EMPTY(msg->to)) {
 		LM_ERR("Empty To header\n");
 		goto error;
 	}
-	if (SCA_HEADER_EMPTY(msg->callid)) {
+	if(SCA_HEADER_EMPTY(msg->callid)) {
 		LM_ERR("Empty Call-ID header\n");
 		goto error;
 	}
 
 	// XXX move to static inline function
-	if (SCA_HEADER_EMPTY(msg->cseq)) {
+	if(SCA_HEADER_EMPTY(msg->cseq)) {
 		LM_ERR("Empty CSeq header\n");
 		goto error;
 	}
-	if (str2int(&(get_cseq(msg)->number), &cseq) != 0) {
-		LM_ERR("Bad Cseq header: %.*s\n",
-				msg->cseq->body.len, msg->cseq->body.s);
+	if(str2int(&(get_cseq(msg)->number), &cseq) != 0) {
+		LM_ERR("Bad Cseq header: %.*s\n", msg->cseq->body.len,
+				msg->cseq->body.s);
 		goto error;
 	}
 
-	if (sca_get_msg_contact_uri(msg, &contact_uri) < 0) {
+	if(sca_get_msg_contact_uri(msg, &contact_uri) < 0) {
 		// above logs error
 		goto error;
 	}
 
-	if (SCA_HEADER_EMPTY(msg->from)) {
+	if(SCA_HEADER_EMPTY(msg->from)) {
 		LM_ERR("Empty From header\n");
 		goto error;
 	}
-	if (parse_from_header(msg) < 0) {
+	if(parse_from_header(msg) < 0) {
 		LM_ERR("Bad From header\n");
 		goto error;
 	}
-	from = (struct to_body *) msg->from->parsed;
-	if (SCA_STR_EMPTY(&from->tag_value)) {
+	from = (struct to_body *)msg->from->parsed;
+	if(SCA_STR_EMPTY(&from->tag_value)) {
 		LM_ERR("No from-tag in From header\n");
 		goto error;
 	}
 
-	if ((to = (struct to_body *) msg->to->parsed) == NULL) {
-		parse_to(msg->to->body.s, msg->to->body.s + msg->to->body.len + 1, // end of buffer
-		&tmp_to);
+	if((to = (struct to_body *)msg->to->parsed) == NULL) {
+		parse_to(msg->to->body.s,
+				msg->to->body.s + msg->to->body.len + 1, // end of buffer
+				&tmp_to);
 
-		if (tmp_to.error != PARSE_OK) {
+		if(tmp_to.error != PARSE_OK) {
 			LM_ERR("Bad To header\n");
 			goto error;
 		}
 		to = &tmp_to;
 	}
 
-	if (parse_sip_msg_uri(msg) < 0) {
+	if(parse_sip_msg_uri(msg) < 0) {
 		LM_ERR("Error while parsing the Request-URI\n");
 		goto error;
 	}
 	ruri = GET_RURI(msg);
 
 	to_tag = to->tag_value;
-	if (to_tag.s == NULL) {
+	if(to_tag.s == NULL) {
 		// XXX need hook to detect when we have a subscription and the
 		// subscriber sends an out-of-dialog SUBSCRIBE, which indicates the
 		// old subscription should be dumped & appropriate NOTIFYs sent.
-		if (scam->sl_api->get_reply_totag(msg, &to_tag) < 0) {
+		if(scam->sl_api->get_reply_totag(msg, &to_tag) < 0) {
 			LM_ERR("Failed to generate to-tag for reply to SUBSCRIBE %.*s\n",
 					STR_FMT(ruri));
 			goto error;
 		}
 
-		if (!SCA_HEADER_EMPTY(msg->record_route)) {
-			if (print_rr_body(msg->record_route, &req_sub->rr, 0, NULL) < 0) {
+		if(!SCA_HEADER_EMPTY(msg->record_route)) {
+			if(print_rr_body(msg->record_route, &req_sub->rr, 0, NULL) < 0) {
 				LM_ERR("Failed to parse Record-Route header %.*s in "
-						"SUBSCRIBE %.*s from %.*s\n",
-						STR_FMT(&msg->record_route->body),
-						STR_FMT(ruri),
+					   "SUBSCRIBE %.*s from %.*s\n",
+						STR_FMT(&msg->record_route->body), STR_FMT(ruri),
 						STR_FMT(&contact_uri));
 				goto error;
 			}
 		}
-		if (sca_uri_extract_aor(ruri, &req_sub->target_aor) < 0) {
+		if(sca_uri_extract_aor(ruri, &req_sub->target_aor) < 0) {
 			LM_ERR("Failed to extract AoR from RURI %.*s\n", STR_FMT(ruri));
 			goto error;
 		}
-	}
-	else {
+	} else {
 		/* we are in-dialog */
 		req_sub->target_aor = to->uri;
 	}
@@ -1096,7 +1113,7 @@ int sca_subscription_from_request(sca_mod *scam, sip_msg_t *msg, int event_type,
 	req_sub->event = event_type;
 	req_sub->index = SCA_CALL_INFO_APPEARANCE_INDEX_ANY;
 	req_sub->expires = expires;
-	if (req_sub->expires > 0) {
+	if(req_sub->expires > 0) {
 		req_sub->state = SCA_SUBSCRIPTION_STATE_ACTIVE;
 		expires += time(NULL);
 	} else {
@@ -1110,7 +1127,7 @@ int sca_subscription_from_request(sca_mod *scam, sip_msg_t *msg, int event_type,
 	req_sub->dialog.from_tag = from->tag_value;
 
 	req_sub->dialog.to_tag.s = pkg_malloc(to_tag.len);
-	if (req_sub->dialog.to_tag.s == NULL) {
+	if(req_sub->dialog.to_tag.s == NULL) {
 		LM_ERR("Failed to pkg_malloc space for to-tag %.*s\n",
 				STR_FMT(&to_tag));
 		goto error;
@@ -1125,9 +1142,10 @@ int sca_subscription_from_request(sca_mod *scam, sip_msg_t *msg, int event_type,
 
 	return (1);
 
-	error: free_to_params(&tmp_to);
+error:
+	free_to_params(&tmp_to);
 
-	if (!SCA_STR_EMPTY(&req_sub->rr)) {
+	if(!SCA_STR_EMPTY(&req_sub->rr)) {
 		pkg_free(req_sub->rr.s);
 		req_sub->rr.s = NULL;
 	}
@@ -1151,37 +1169,39 @@ int ki_sca_handle_subscribe(sip_msg_t *msg)
 	int rc = -1;
 	int released = 0;
 
-	if (parse_headers(msg, HDR_EOH_F, 0) < 0) {
+	if(parse_headers(msg, HDR_EOH_F, 0) < 0) {
 		LM_ERR("header parsing failed: bad request\n");
 		SCA_SUB_REPLY_ERROR(sca, 400, "Bad Request", msg);
 		return (-1);
 	}
 
-	if (!STR_EQ(REQ_LINE(msg).method, SCA_METHOD_SUBSCRIBE)) {
+	if(!STR_EQ(REQ_LINE(msg).method, SCA_METHOD_SUBSCRIBE)) {
 		LM_ERR("bad request method %.*s\n", STR_FMT(&REQ_LINE(msg).method));
 		SCA_SUB_REPLY_ERROR(sca, 500, "Internal server error - config", msg);
 		return (-1);
 	}
 
-	if (SCA_HEADER_EMPTY(msg->event)) {
+	if(SCA_HEADER_EMPTY(msg->event)) {
 		SCA_SUB_REPLY_ERROR(sca, 400, "Missing Event", msg);
 		return (-1);
 	}
 
 	event_type = sca_event_from_str(&msg->event->body);
-	if (event_type == SCA_EVENT_TYPE_UNKNOWN) {
+	if(event_type == SCA_EVENT_TYPE_UNKNOWN) {
 		SCA_SUB_REPLY_ERROR(sca, 400, "Bad Event", msg);
 		return (-1);
 	}
 
-	if (sca_subscription_from_request(sca, msg, event_type, &req_sub) < 0) {
-		SCA_SUB_REPLY_ERROR(sca, 400, "Bad Shared Call Appearance Request",
-				msg);
+	if(sca_subscription_from_request(sca, msg, event_type, &req_sub) < 0) {
+		SCA_SUB_REPLY_ERROR(
+				sca, 400, "Bad Shared Call Appearance Request", msg);
 		return (-1);
 	}
-	if (sca_subscription_copy_subscription_key(&req_sub, &sub_key) < 0) {
-		SCA_SUB_REPLY_ERROR(sca, 500, "Internal Server Error - "
-				"copy dialog id", msg);
+	if(sca_subscription_copy_subscription_key(&req_sub, &sub_key) < 0) {
+		SCA_SUB_REPLY_ERROR(sca, 500,
+				"Internal Server Error - "
+				"copy dialog id",
+				msg);
 		goto done;
 	}
 	sca_subscription_print(&req_sub);
@@ -1196,60 +1216,70 @@ int ki_sca_handle_subscribe(sip_msg_t *msg)
 	// pkg_malloc'd in sca_subscription_copy_subscription_key above
 	pkg_free(sub_key.s);
 
-	if (req_sub.event == SCA_EVENT_TYPE_LINE_SEIZE) {
+	if(req_sub.event == SCA_EVENT_TYPE_LINE_SEIZE) {
 		call_info_hdr = get_hdr(msg, HDR_CALLINFO_T);
-		if (call_info_hdr) {
-			if (sca_call_info_body_parse(&call_info_hdr->body, &call_info)
-					< 0) {
-				SCA_SUB_REPLY_ERROR(sca, 400, "Bad Request - "
-						"Invalid Call-Info header", msg);
+		if(call_info_hdr) {
+			if(sca_call_info_body_parse(&call_info_hdr->body, &call_info) < 0) {
+				SCA_SUB_REPLY_ERROR(sca, 400,
+						"Bad Request - "
+						"Invalid Call-Info header",
+						msg);
 				goto done;
 			}
 			req_sub.index = app_idx = call_info.index;
 		} else {
-			SCA_SUB_REPLY_ERROR(sca, 400, "Bad Request - "
-					"missing Call-Info header", msg);
+			SCA_SUB_REPLY_ERROR(sca, 400,
+					"Bad Request - "
+					"missing Call-Info header",
+					msg);
 			goto done;
 		}
 	}
 
 	sca_hash_table_lock_index(sca->subscriptions, idx);
 
-	sub = sca_hash_table_index_kv_find_unsafe(sca->subscriptions, idx,
-			&req_sub.subscriber);
+	sub = sca_hash_table_index_kv_find_unsafe(
+			sca->subscriptions, idx, &req_sub.subscriber);
 
-	if (sub != NULL) {
+	if(sub != NULL) {
 		// this will remove the subscription if expires == 0
-		if (sca_subscription_update_unsafe(sca, sub, &req_sub, idx) < 0) {
-			SCA_SUB_REPLY_ERROR(sca, 500, "Internal Server Error - "
-					"update subscription", msg);
+		if(sca_subscription_update_unsafe(sca, sub, &req_sub, idx) < 0) {
+			SCA_SUB_REPLY_ERROR(sca, 500,
+					"Internal Server Error - "
+					"update subscription",
+					msg);
 			goto done;
 		}
 
-		if (req_sub.event == SCA_EVENT_TYPE_LINE_SEIZE) {
-			if (req_sub.expires == 0) {
+		if(req_sub.event == SCA_EVENT_TYPE_LINE_SEIZE) {
+			if(req_sub.expires == 0) {
 				// release the seized appearance
-				if (call_info_hdr == NULL) {
-					SCA_SUB_REPLY_ERROR(sca, 400, "Bad Request - "
-							"missing Call-Info header", msg);
+				if(call_info_hdr == NULL) {
+					SCA_SUB_REPLY_ERROR(sca, 400,
+							"Bad Request - "
+							"missing Call-Info header",
+							msg);
 					goto done;
 				}
 
-				if (sca_appearance_release_index(sca, &req_sub.target_aor,
-						call_info.index) != SCA_APPEARANCE_OK) {
-					SCA_SUB_REPLY_ERROR(sca, 500, "Internal Server Error - "
-							"release seized line", msg);
+				if(sca_appearance_release_index(
+						   sca, &req_sub.target_aor, call_info.index)
+						!= SCA_APPEARANCE_OK) {
+					SCA_SUB_REPLY_ERROR(sca, 500,
+							"Internal Server Error - "
+							"release seized line",
+							msg);
 					goto done;
 				}
-			} else if (SCA_STR_EMPTY(to_tag)) {
+			} else if(SCA_STR_EMPTY(to_tag)) {
 				// don't seize new index if this is a line-seize reSUBSCRIBE
-				app_idx = sca_appearance_seize_index(sca, &req_sub.target_aor,
-						app_idx, &req_sub.subscriber);
-				if (app_idx == SCA_APPEARANCE_INDEX_UNAVAILABLE) {
-					SCA_SUB_REPLY_ERROR(sca, 480, "Temporarily Unavailable",
-							msg);
+				app_idx = sca_appearance_seize_index(
+						sca, &req_sub.target_aor, app_idx, &req_sub.subscriber);
+				if(app_idx == SCA_APPEARANCE_INDEX_UNAVAILABLE) {
+					SCA_SUB_REPLY_ERROR(
+							sca, 480, "Temporarily Unavailable", msg);
 					goto done;
-				} else if (app_idx < 0) {
+				} else if(app_idx < 0) {
 					SCA_SUB_REPLY_ERROR(sca, 500,
 							"Internal Server Error - seize appearance index",
 							msg);
@@ -1258,47 +1288,52 @@ int ki_sca_handle_subscribe(sip_msg_t *msg)
 				req_sub.index = app_idx;
 			}
 		} else {
-			if (SCA_STR_EMPTY(to_tag)) {
+			if(SCA_STR_EMPTY(to_tag)) {
 				// if the subscriber owns any active appearances, clear them.
 				// we assume that an out-of-dialog SUBSCRIBE for a subscriber
 				// with active appearances is indicative of a reboot.
-				released = sca_appearance_owner_release_all(&req_sub.target_aor,
-						&req_sub.subscriber);
-				if (released) {
+				released = sca_appearance_owner_release_all(
+						&req_sub.target_aor, &req_sub.subscriber);
+				if(released) {
 					LM_INFO("sca_handle_subscribe: released %d appearances "
-							"for subscriber %.*s\n", released,
-							STR_FMT(&req_sub.subscriber));
+							"for subscriber %.*s\n",
+							released, STR_FMT(&req_sub.subscriber));
 				}
 			}
 		}
 	} else {
 		// in-dialog request, but we didn't find it.
-		if (!SCA_STR_EMPTY(to_tag)) {
-			SCA_SUB_REPLY_ERROR(sca, 481, "Call Leg/Transaction Does Not Exist",
-					msg);
+		if(!SCA_STR_EMPTY(to_tag)) {
+			SCA_SUB_REPLY_ERROR(
+					sca, 481, "Call Leg/Transaction Does Not Exist", msg);
 			goto done;
 		}
 
-		if (req_sub.expires > 0) {
-			if (req_sub.event == SCA_EVENT_TYPE_LINE_SEIZE) {
-				app_idx = sca_appearance_seize_index(sca, &req_sub.target_aor,
-						app_idx, &req_sub.subscriber);
-				if (app_idx == SCA_APPEARANCE_INDEX_UNAVAILABLE) {
-					SCA_SUB_REPLY_ERROR(sca, 480, "Temporarily Unavailable",
-							msg);
+		if(req_sub.expires > 0) {
+			if(req_sub.event == SCA_EVENT_TYPE_LINE_SEIZE) {
+				app_idx = sca_appearance_seize_index(
+						sca, &req_sub.target_aor, app_idx, &req_sub.subscriber);
+				if(app_idx == SCA_APPEARANCE_INDEX_UNAVAILABLE) {
+					SCA_SUB_REPLY_ERROR(
+							sca, 480, "Temporarily Unavailable", msg);
 					goto done;
-				} else if (app_idx < 0) {
-					SCA_SUB_REPLY_ERROR(sca, 500, "Internal Server Error - "
-							"seize appearance index", msg);
+				} else if(app_idx < 0) {
+					SCA_SUB_REPLY_ERROR(sca, 500,
+							"Internal Server Error - "
+							"seize appearance index",
+							msg);
 					goto done;
 				}
 				req_sub.index = app_idx;
 			}
 
-			if (sca_subscription_save_unsafe(sca, &req_sub, idx,
-					SCA_SUBSCRIPTION_CREATE_OPT_DEFAULT) < 0) {
-				SCA_SUB_REPLY_ERROR(sca, 500, "Internal Server Error - "
-						"save subscription", msg);
+			if(sca_subscription_save_unsafe(
+					   sca, &req_sub, idx, SCA_SUBSCRIPTION_CREATE_OPT_DEFAULT)
+					< 0) {
+				SCA_SUB_REPLY_ERROR(sca, 500,
+						"Internal Server Error - "
+						"save subscription",
+						msg);
 				goto done;
 			}
 		} else {
@@ -1314,13 +1349,14 @@ int ki_sca_handle_subscribe(sip_msg_t *msg)
 
 	status = sca_ok_status_for_event(event_type);
 	status_text = sca_ok_text_for_event(event_type);
-	if (sca_subscription_reply(sca, status, status_text, event_type,
-			req_sub.expires, msg) < 0) {
+	if(sca_subscription_reply(
+			   sca, status, status_text, event_type, req_sub.expires, msg)
+			< 0) {
 		SCA_SUB_REPLY_ERROR(sca, 500, "Internal server error", msg);
 		goto done;
 	}
 
-	if (sca_notify_subscriber(sca, &req_sub, app_idx) < 0) {
+	if(sca_notify_subscriber(sca, &req_sub, app_idx) < 0) {
 		LM_ERR("SCA %s SUBSCRIBE+NOTIFY for %.*s failed\n",
 				sca_event_name_from_type(req_sub.event),
 				STR_FMT(&req_sub.subscriber));
@@ -1329,8 +1365,8 @@ int ki_sca_handle_subscribe(sip_msg_t *msg)
 		goto done;
 	}
 
-	if (req_sub.event == SCA_EVENT_TYPE_LINE_SEIZE || released) {
-		if (sca_notify_call_info_subscribers(sca, &req_sub.target_aor) < 0) {
+	if(req_sub.event == SCA_EVENT_TYPE_LINE_SEIZE || released) {
+		if(sca_notify_call_info_subscribers(sca, &req_sub.target_aor) < 0) {
 			LM_ERR("SCA %s NOTIFY to all %.*s subscribers failed\n",
 					sca_event_name_from_type(req_sub.event),
 					STR_FMT(&req_sub.target_aor));
@@ -1340,14 +1376,15 @@ int ki_sca_handle_subscribe(sip_msg_t *msg)
 
 	rc = 1;
 
-	done: if (idx >= 0) {
+done:
+	if(idx >= 0) {
 		sca_hash_table_unlock_index(sca->subscriptions, idx);
 	}
 
-	if (req_sub.dialog.to_tag.s != NULL) {
+	if(req_sub.dialog.to_tag.s != NULL) {
 		pkg_free(req_sub.dialog.to_tag.s);
 	}
-	if (req_sub.rr.s != NULL) {
+	if(req_sub.rr.s != NULL) {
 		pkg_free(req_sub.rr.s);
 	}
 
@@ -1366,49 +1403,48 @@ int sca_subscription_reply(sca_mod *scam, int status_code, char *status_msg,
 	char hdr_buf[1024];
 	int len;
 
-	if (event_type != SCA_EVENT_TYPE_CALL_INFO
+	if(event_type != SCA_EVENT_TYPE_CALL_INFO
 			&& event_type != SCA_EVENT_TYPE_LINE_SEIZE) {
 		LM_ERR("sca_subscription_reply: unrecognized event type %d\n",
 				event_type);
 		return (-1);
 	}
 
-	if (status_code < 300) {
+	if(status_code < 300) {
 		// Add Event, Contact, Allow-Events and Expires headers
 		extra_headers.s = hdr_buf;
 		len = snprintf(extra_headers.s, sizeof(hdr_buf), "Event: %s%s",
 				sca_event_name_from_type(event_type), CRLF);
-		if (len >= sizeof(hdr_buf) || len < 0) {
+		if(len >= sizeof(hdr_buf) || len < 0) {
 			LM_ERR("sca_subscription_reply: extra headers too long\n");
 			return (-1);
 		}
 		extra_headers.len = len;
 
 		SCA_STR_APPEND_CSTR(&extra_headers, "Contact: ");
-		if (sca->cfg->server_address != NULL) {
-			SCA_STR_APPEND( &extra_headers, sca->cfg->server_address);
-		}
-		else {
-			SCA_STR_APPEND( &extra_headers, &REQ_LINE( msg ).uri );
+		if(sca->cfg->server_address != NULL) {
+			SCA_STR_APPEND(&extra_headers, sca->cfg->server_address);
+		} else {
+			SCA_STR_APPEND(&extra_headers, &REQ_LINE(msg).uri);
 		}
 		SCA_STR_APPEND_CSTR(&extra_headers, CRLF);
 
-		SCA_STR_COPY_CSTR(&extra_headers,
-				"Allow-Events: call-info, line-seize" CRLF);
+		SCA_STR_COPY_CSTR(
+				&extra_headers, "Allow-Events: call-info, line-seize" CRLF);
 
 		len = snprintf(extra_headers.s + extra_headers.len,
 				sizeof(hdr_buf) - extra_headers.len, "Expires: %d%s", expires,
 				CRLF);
-		if (len >= (sizeof(hdr_buf) - extra_headers.len) || len < 0) {
+		if(len >= (sizeof(hdr_buf) - extra_headers.len) || len < 0) {
 			LM_ERR("sca_subscription_reply: extra headers too long\n");
 			return (-1);
 		}
 		extra_headers.len += len;
-	} else if (status_code == 480) {
+	} else if(status_code == 480) {
 		// tell loser of line-seize SUBSCRIBE race to try again shortly
 		extra_headers.s = hdr_buf;
-		len = snprintf(extra_headers.s, sizeof(hdr_buf), "Retry-After: %d%s", 1,
-				CRLF);
+		len = snprintf(
+				extra_headers.s, sizeof(hdr_buf), "Retry-After: %d%s", 1, CRLF);
 		extra_headers.len = len;
 	}
 
@@ -1432,17 +1468,18 @@ int sca_subscription_terminate(sca_mod *scam, str *aor, int event,
 	int slot_idx;
 	int len;
 
-	if (!(opts & SCA_SUBSCRIPTION_TERMINATE_OPT_UNSUBSCRIBE)) {
+	if(!(opts & SCA_SUBSCRIPTION_TERMINATE_OPT_UNSUBSCRIBE)) {
 		LM_ERR("sca_subscription_terminate: invalid opts 0x%x\n", opts);
 		return (-1);
 	}
 
 	event_name = sca_event_name_from_type(event);
 	len = aor->len + strlen(event_name);
-	sub_key.s = (char *) pkg_malloc(len);
-	if (sub_key.s == NULL) {
+	sub_key.s = (char *)pkg_malloc(len);
+	if(sub_key.s == NULL) {
 		LM_ERR("Failed to pkg_malloc key to look up %s "
-				"subscription for %.*s\n", event_name, STR_FMT(aor));
+			   "subscription for %.*s\n",
+				event_name, STR_FMT(aor));
 		return (-1);
 	}
 	SCA_STR_COPY(&sub_key, aor);
@@ -1456,37 +1493,37 @@ int sca_subscription_terminate(sca_mod *scam, str *aor, int event,
 	sca_hash_table_lock_index(scam->subscriptions, slot_idx);
 
 	ent = sca_hash_table_slot_kv_find_entry_unsafe(slot, subscriber);
-	if (ent != NULL) {
+	if(ent != NULL) {
 		ent = sca_hash_table_slot_unlink_entry_unsafe(slot, ent);
 	}
 
 	sca_hash_table_unlock_index(sca->subscriptions, slot_idx);
 
-	if (ent == NULL) {
+	if(ent == NULL) {
 		LM_DBG("No %s subscription for %.*s\n", event_name,
 				STR_FMT(subscriber));
 		return (0);
 	}
 
-	sub = (sca_subscription *) ent->value;
+	sub = (sca_subscription *)ent->value;
 	sub->expires = 0;
 	sub->dialog.notify_cseq += 1;
 	sub->state = termination_state;
 
 	sca_subscription_print(sub);
 
-	if (sca_notify_subscriber(sca, sub, sub->index) < 0) {
-		LM_ERR("SCA %s NOTIFY to %.*s failed\n",
-				event_name, STR_FMT(&sub->subscriber));
+	if(sca_notify_subscriber(sca, sub, sub->index) < 0) {
+		LM_ERR("SCA %s NOTIFY to %.*s failed\n", event_name,
+				STR_FMT(&sub->subscriber));
 
 		// fall through, we might be able to notify the others
 	}
 
-	if ((opts & SCA_SUBSCRIPTION_TERMINATE_OPT_RELEASE_APPEARANCE)
+	if((opts & SCA_SUBSCRIPTION_TERMINATE_OPT_RELEASE_APPEARANCE)
 			&& sub->index != SCA_CALL_INFO_APPEARANCE_INDEX_ANY) {
-		if (sca_appearance_release_index(sca, &sub->target_aor, sub->index)
+		if(sca_appearance_release_index(sca, &sub->target_aor, sub->index)
 				== SCA_APPEARANCE_OK) {
-			if (sca_notify_call_info_subscribers(sca, &sub->target_aor) < 0) {
+			if(sca_notify_call_info_subscribers(sca, &sub->target_aor) < 0) {
 				LM_ERR("SCA %s NOTIFY to all %.*s subscribers failed\n",
 						event_name, STR_FMT(&sub->target_aor));
 				// fall through, not much we can do about it
@@ -1494,7 +1531,7 @@ int sca_subscription_terminate(sca_mod *scam, str *aor, int event,
 		}
 	}
 
-	if (ent) {
+	if(ent) {
 		sca_hash_entry_free(ent);
 	}
 
diff --git a/src/modules/sca/sca_subscribe.h b/src/modules/sca/sca_subscribe.h
index e919717..e27883e 100644
--- a/src/modules/sca/sca_subscribe.h
+++ b/src/modules/sca/sca_subscribe.h
@@ -23,7 +23,8 @@
 #include "sca.h"
 #include "sca_dialog.h"
 
-enum {
+enum
+{
 	SCA_SUBSCRIPTION_STATE_ACTIVE,
 	SCA_SUBSCRIPTION_STATE_PENDING,
 	SCA_SUBSCRIPTION_STATE_TERMINATED,
@@ -35,45 +36,48 @@ enum {
 	SCA_SUBSCRIPTION_STATE_TERMINATED_TIMEOUT,
 };
 
-struct _sca_subscription {
+struct _sca_subscription
+{
 	str subscriber; // contact: user@ip
 	str target_aor; // account of record to watch: user@domain
-	int event; // "call-info", "line-seize"
+	int event;		// "call-info", "line-seize"
 	time_t expires; // expiration date of subscription
-	int state; // active, pending, terminated
-	int index; // seized appearance-index, line-seize only
+	int state;		// active, pending, terminated
+	int index;		// seized appearance-index, line-seize only
 
 	sca_dialog dialog; // call-id, to- and from-tags, cseq
 
 	str rr; // Record-Route header values
 
 	int db_cmd_flag; // track whether to INSERT or UPDATE
-	int server_id; // server
+	int server_id;	 // server
 };
 typedef struct _sca_subscription sca_subscription;
 
-enum {
+enum
+{
 	SCA_SUBSCRIPTION_TERMINATE_OPT_UNSUBSCRIBE = (1 << 0),
 	SCA_SUBSCRIPTION_TERMINATE_OPT_RELEASE_APPEARANCE = (1 << 1),
 };
-#define SCA_SUBSCRIPTION_TERMINATE_OPT_DEFAULT \
-	(SCA_SUBSCRIPTION_TERMINATE_OPT_UNSUBSCRIBE | \
-	 SCA_SUBSCRIPTION_TERMINATE_OPT_RELEASE_APPEARANCE)
+#define SCA_SUBSCRIPTION_TERMINATE_OPT_DEFAULT  \
+	(SCA_SUBSCRIPTION_TERMINATE_OPT_UNSUBSCRIBE \
+			| SCA_SUBSCRIPTION_TERMINATE_OPT_RELEASE_APPEARANCE)
 
-enum {
+enum
+{
 	SCA_SUBSCRIPTION_CREATE_OPT_DEFAULT = 0,
 	SCA_SUBSCRIPTION_CREATE_OPT_RAW_EXPIRES = (1 << 0),
 };
 
 extern const str SCA_METHOD_SUBSCRIBE;
 
-#define SCA_SUBSCRIPTION_IS_TERMINATED(sub1) \
-	((sub1)->state >= SCA_SUBSCRIPTION_STATE_TERMINATED && \
-		(sub1)->state <= SCA_SUBSCRIPTION_STATE_TERMINATED_TIMEOUT)
+#define SCA_SUBSCRIPTION_IS_TERMINATED(sub1)            \
+	((sub1)->state >= SCA_SUBSCRIPTION_STATE_TERMINATED \
+			&& (sub1)->state <= SCA_SUBSCRIPTION_STATE_TERMINATED_TIMEOUT)
 
 #define SCA_SUB_REPLY_ERROR(mod, scode, smsg, sreply) \
-		sca_subscription_reply((mod), (scode), (smsg), \
-		SCA_EVENT_TYPE_CALL_INFO, -1, (sreply))
+	sca_subscription_reply(                           \
+			(mod), (scode), (smsg), SCA_EVENT_TYPE_CALL_INFO, -1, (sreply))
 
 int sca_handle_subscribe(sip_msg_t *, char *, char *);
 int sca_subscription_reply(sca_mod *, int, char *, int, int, sip_msg_t *);
@@ -86,7 +90,8 @@ void sca_subscription_purge_expired(unsigned int, void *);
 void sca_subscription_state_to_str(int, str *);
 
 int sca_subscription_aor_has_subscribers(int, str *);
-int sca_subscription_delete_subscriber_for_event(sca_mod *, str *, str *, str *);
+int sca_subscription_delete_subscriber_for_event(
+		sca_mod *, str *, str *, str *);
 int sca_subscription_terminate(sca_mod *, str *, int, str *, int, int);
 int ki_sca_handle_subscribe(sip_msg_t *msg);
 
diff --git a/src/modules/sca/sca_util.c b/src/modules/sca/sca_util.c
index b586c8f..4ab4c6f 100644
--- a/src/modules/sca/sca_util.c
+++ b/src/modules/sca/sca_util.c
@@ -29,7 +29,7 @@ int sca_get_msg_method(sip_msg_t *msg)
 {
 	assert(msg != NULL);
 
-	if (msg->first_line.type == SIP_REQUEST) {
+	if(msg->first_line.type == SIP_REQUEST) {
 		return (msg->REQ_METHOD);
 	}
 
@@ -43,7 +43,7 @@ int sca_get_msg_contact_uri(sip_msg_t *msg, str *contact_uri)
 	assert(msg != NULL);
 	assert(contact_uri != NULL);
 
-	if (SCA_HEADER_EMPTY(msg->contact)) {
+	if(SCA_HEADER_EMPTY(msg->contact)) {
 		LM_DBG("Empty Contact header\n");
 		contact_uri->s = NULL;
 		contact_uri->len = 0;
@@ -51,24 +51,24 @@ int sca_get_msg_contact_uri(sip_msg_t *msg, str *contact_uri)
 		return (0);
 	}
 
-	if (parse_contact(msg->contact) < 0) {
+	if(parse_contact(msg->contact) < 0) {
 		LM_ERR("Failed to parse Contact header: %.*s\n",
 				STR_FMT(&msg->contact->body));
 		return (-1);
 	}
-	if ((contact_body = (contact_body_t *) msg->contact->parsed) == NULL) {
+	if((contact_body = (contact_body_t *)msg->contact->parsed) == NULL) {
 		LM_ERR("Invalid Contact header: %.*s\n", STR_FMT(&msg->contact->body));
 		return (-1);
 	}
-	if (contact_body->star) {
+	if(contact_body->star) {
 		LM_ERR("Invalid Contact header: SCA Contact must not be \"*\"\n");
 		return (-1);
 	}
-	if (contact_body->contacts == NULL) {
+	if(contact_body->contacts == NULL) {
 		LM_ERR("Invalid Contact header: parser found no contacts\n");
 		return (-1);
 	}
-	if (contact_body->contacts->next) {
+	if(contact_body->contacts->next) {
 		LM_ERR("Invalid Contact header: Contact may only contain one URI\n");
 		return (-1);
 	}
@@ -85,11 +85,11 @@ int sca_get_msg_cseq_number(sip_msg_t *msg)
 
 	assert(msg != NULL);
 
-	if (SCA_HEADER_EMPTY(msg->cseq)) {
+	if(SCA_HEADER_EMPTY(msg->cseq)) {
 		LM_ERR("Empty Cseq header\n");
 		return (-1);
 	}
-	if (str2int(&(get_cseq(msg)->number), (unsigned int *) &cseq) != 0) {
+	if(str2int(&(get_cseq(msg)->number), (unsigned int *)&cseq) != 0) {
 		LM_ERR("Bad Cseq header: %.*s\n", STR_FMT(&msg->cseq->body));
 		return (-1);
 	}
@@ -104,7 +104,7 @@ int sca_get_msg_cseq_method(sip_msg_t *msg)
 {
 	assert(msg != NULL);
 
-	if (SCA_HEADER_EMPTY(msg->cseq)) {
+	if(SCA_HEADER_EMPTY(msg->cseq)) {
 		LM_ERR("Empty Cseq header\n");
 		return (-1);
 	}
@@ -119,22 +119,22 @@ int sca_get_msg_from_header(sip_msg_t *msg, struct to_body **from)
 	assert(msg != NULL);
 	assert(from != NULL);
 
-	if (SCA_HEADER_EMPTY(msg->from)) {
+	if(SCA_HEADER_EMPTY(msg->from)) {
 		LM_ERR("Empty From header\n");
 		return (-1);
 	}
-	if (parse_from_header(msg) < 0) {
+	if(parse_from_header(msg) < 0) {
 		LM_ERR("Bad From header\n");
 		return (-1);
 	}
 	f = get_from(msg);
-	if (SCA_STR_EMPTY(&f->tag_value)) {
+	if(SCA_STR_EMPTY(&f->tag_value)) {
 		LM_ERR("Bad From header: no tag parameter\n");
 		return (-1);
 	}
 
 	// ensure the URI is parsed for future use
-	if (parse_uri(f->uri.s, f->uri.len, GET_FROM_PURI(msg)) < 0) {
+	if(parse_uri(f->uri.s, f->uri.len, GET_FROM_PURI(msg)) < 0) {
 		LM_ERR("Failed to parse From URI %.*s\n", STR_FMT(&f->uri));
 		return (-1);
 	}
@@ -152,15 +152,16 @@ int sca_get_msg_to_header(sip_msg_t *msg, struct to_body **to)
 	assert(msg != NULL);
 	assert(to != NULL);
 
-	if (SCA_HEADER_EMPTY(msg->to)) {
+	if(SCA_HEADER_EMPTY(msg->to)) {
 		LM_ERR("Empty To header\n");
 		return (-1);
 	}
 	t = get_to(msg);
-	if (t == NULL) {
-		parse_to(msg->to->body.s, msg->to->body.s + msg->to->body.len + 1, // end of buffer
-		&parsed_to);
-		if (parsed_to.error != PARSE_OK) {
+	if(t == NULL) {
+		parse_to(msg->to->body.s,
+				msg->to->body.s + msg->to->body.len + 1, // end of buffer
+				&parsed_to);
+		if(parsed_to.error != PARSE_OK) {
 			LM_ERR("Bad To header\n");
 			return (-1);
 		}
@@ -168,7 +169,7 @@ int sca_get_msg_to_header(sip_msg_t *msg, struct to_body **to)
 	}
 
 	// ensure the URI is parsed for future use
-	if (parse_uri(t->uri.s, t->uri.len, GET_TO_PURI(msg)) < 0) {
+	if(parse_uri(t->uri.s, t->uri.len, GET_TO_PURI(msg)) < 0) {
 		LM_ERR("Failed to parse To URI %.*s\n", STR_FMT(&t->uri));
 		return (-1);
 	}
@@ -190,14 +191,14 @@ int sca_build_to_body_from_uri(sip_msg_t *msg, struct to_body **body, str *uri)
 	*body = pkg_malloc(sizeof(struct to_body));
 	if(*body == NULL) {
 		LM_ERR("cannot allocate pkg memory\n");
-		return(-1);
+		return (-1);
 	}
 
 	parse_to(uri->s, uri->s + uri->len + 1, *body);
-	if ((*body)->error != PARSE_OK) {
+	if((*body)->error != PARSE_OK) {
 		LM_ERR("Bad uri value[%.*s]\n", STR_FMT(uri));
 		free_to(*body);
-		return(-1);
+		return (-1);
 	}
 	return (0);
 }
@@ -205,24 +206,25 @@ int sca_build_to_body_from_uri(sip_msg_t *msg, struct to_body **body, str *uri)
 /*
  *  count characters requiring escape as defined by escape_common
  */
-int sca_uri_display_escapes_count(str *display) {
+int sca_uri_display_escapes_count(str *display)
+{
 	int c = 0;
 	int i;
 
-	if (SCA_STR_EMPTY(display)) {
+	if(SCA_STR_EMPTY(display)) {
 		return (0);
 	}
 
-	for (i = 0; i < display->len; i++) {
-		switch (display->s[i]) {
-		case '\'':
-		case '"':
-		case '\\':
-		case '\0':
-			c++;
+	for(i = 0; i < display->len; i++) {
+		switch(display->s[i]) {
+			case '\'':
+			case '"':
+			case '\\':
+			case '\0':
+				c++;
 
-		default:
-			break;
+			default:
+				break;
 		}
 	}
 
@@ -235,7 +237,7 @@ int sca_uri_extract_aor(str *uri, str *aor)
 
 	assert(aor != NULL);
 
-	if (uri == NULL) {
+	if(uri == NULL) {
 		aor->s = NULL;
 		aor->len = 0;
 		return (-1);
@@ -243,7 +245,7 @@ int sca_uri_extract_aor(str *uri, str *aor)
 
 	aor->s = uri->s;
 	semi = memchr(uri->s, ';', uri->len);
-	if (semi != NULL) {
+	if(semi != NULL) {
 		aor->len = semi - uri->s;
 	} else {
 		aor->len = uri->len;
@@ -262,12 +264,12 @@ int sca_uri_build_aor(str *aor, int maxlen, str *contact_uri, str *domain_uri)
 	assert(contact_uri != NULL);
 	assert(domain_uri != NULL);
 
-	if (contact_uri->len + domain_uri->len >= maxlen) {
+	if(contact_uri->len + domain_uri->len >= maxlen) {
 		return (-1);
 	}
 
 	p = memchr(contact_uri->s, '@', contact_uri->len);
-	if (p == NULL) {
+	if(p == NULL) {
 		// no username, by definition can't be an SCA line
 		aor->s = NULL;
 		aor->len = 0;
@@ -275,10 +277,10 @@ int sca_uri_build_aor(str *aor, int maxlen, str *contact_uri, str *domain_uri)
 		return (0);
 	}
 	dp = memchr(domain_uri->s, '@', domain_uri->len);
-	if (dp == NULL) {
+	if(dp == NULL) {
 		// may be nameless URI
 		dp = memchr(domain_uri->s, ':', domain_uri->len);
-		if (dp == NULL) {
+		if(dp == NULL) {
 			// bad domain URI
 			return (-1);
 		}
@@ -298,8 +300,8 @@ int sca_uri_build_aor(str *aor, int maxlen, str *contact_uri, str *domain_uri)
 	return (aor->len);
 }
 
-int sca_aor_create_from_info(str *aor, uri_type type, str *user, str *domain,
-		str *port)
+int sca_aor_create_from_info(
+		str *aor, uri_type type, str *user, str *domain, str *port)
 {
 	str scheme = STR_NULL;
 	int len = 0;
@@ -310,13 +312,13 @@ int sca_aor_create_from_info(str *aor, uri_type type, str *user, str *domain,
 
 	// +1 for ':', +1 for '@'
 	len = scheme.len + 1 + user->len + 1 + domain->len;
-	if (!SCA_STR_EMPTY(port)) {
+	if(!SCA_STR_EMPTY(port)) {
 		// +1 for ':'
 		len += 1 + port->len;
 	}
 
-	aor->s = (char *) pkg_malloc(len);
-	if (aor->s == NULL) {
+	aor->s = (char *)pkg_malloc(len);
+	if(aor->s == NULL) {
 		LM_ERR("sca_aor_create_from_info: pkg_malloc %d bytes failed\n", len);
 		return (-1);
 	}
@@ -339,7 +341,7 @@ int sca_aor_create_from_info(str *aor, uri_type type, str *user, str *domain,
 	SCA_STR_APPEND(aor, domain);
 	len += domain->len;
 
-	if (!SCA_STR_EMPTY(port)) {
+	if(!SCA_STR_EMPTY(port)) {
 		*(aor->s + len) = ':';
 		len += 1;
 
@@ -363,59 +365,63 @@ int sca_create_canonical_aor_for_ua(sip_msg_t *msg, str *c_aor, int ua_opts)
 
 	memset(c_aor, 0, sizeof(str));
 
-	if ((ua_opts & SCA_AOR_TYPE_AUTO)) {
-		if (msg->first_line.type == SIP_REQUEST) {
+	if((ua_opts & SCA_AOR_TYPE_AUTO)) {
+		if(msg->first_line.type == SIP_REQUEST) {
 			ua_opts = SCA_AOR_TYPE_UAC;
 		} else {
 			ua_opts = SCA_AOR_TYPE_UAS;
 		}
 	}
 
-	if ((ua_opts & SCA_AOR_TYPE_UAC)) {
-		if (sca_get_msg_from_header(msg, &tf) < 0) {
+	if((ua_opts & SCA_AOR_TYPE_UAC)) {
+		if(sca_get_msg_from_header(msg, &tf) < 0) {
 			LM_ERR("sca_create_canonical_aor: failed to get From header\n");
 			goto done;
 		}
 	} else {
-		if (sca_get_msg_to_header(msg, &tf) < 0) {
+		if(sca_get_msg_to_header(msg, &tf) < 0) {
 			LM_ERR("sca_create_canonical_aor: failed to get To header\n");
 			goto done;
 		}
 	}
 
-	if (sca_uri_extract_aor(&tf->uri, &tf_aor) < 0) {
+	if(sca_uri_extract_aor(&tf->uri, &tf_aor) < 0) {
 		LM_ERR("sca_create_canonical_aor: failed to extract AoR from "
-				"URI <%.*s>\n", STR_FMT(&tf->uri));
+			   "URI <%.*s>\n",
+				STR_FMT(&tf->uri));
 		goto done;
 	}
 
 	memset(&c_uri, 0, sizeof(sip_uri_t));
-	if ((rc = sca_get_msg_contact_uri(msg, &contact_uri)) < 0) {
+	if((rc = sca_get_msg_contact_uri(msg, &contact_uri)) < 0) {
 		LM_ERR("sca_create_canonical_aor: failed to get contact URI from "
-				"Contact <%.*s>\n", STR_FMT(&msg->contact->body));
+			   "Contact <%.*s>\n",
+				STR_FMT(&msg->contact->body));
 		goto done;
 	}
-	if (rc > 0) {
-		if (parse_uri(contact_uri.s, contact_uri.len, &c_uri) < 0) {
+	if(rc > 0) {
+		if(parse_uri(contact_uri.s, contact_uri.len, &c_uri) < 0) {
 			LM_ERR("sca_create_canonical_aor: failed to parse Contact URI "
-					"<%.*s>\n", STR_FMT(&contact_uri));
+				   "<%.*s>\n",
+					STR_FMT(&contact_uri));
 			rc = -1;
 			goto done;
 		}
 	}
 
-	if (SCA_STR_EMPTY(&c_uri.user) ||
-	SCA_STR_EQ(&c_uri.user, &tf->parsed_uri.user)) {
+	if(SCA_STR_EMPTY(&c_uri.user)
+			|| SCA_STR_EQ(&c_uri.user, &tf->parsed_uri.user)) {
 		// empty contact header or Contact user matches To/From AoR
-		c_aor->s = (char *) pkg_malloc(tf_aor.len);
+		c_aor->s = (char *)pkg_malloc(tf_aor.len);
 		c_aor->len = tf_aor.len;
 		memcpy(c_aor->s, tf_aor.s, tf_aor.len);
 	} else {
 		// Contact user and To/From user mismatch
-		if (sca_aor_create_from_info(c_aor, c_uri.type, &c_uri.user,
-				&tf->parsed_uri.host, &tf->parsed_uri.port) < 0) {
+		if(sca_aor_create_from_info(c_aor, c_uri.type, &c_uri.user,
+				   &tf->parsed_uri.host, &tf->parsed_uri.port)
+				< 0) {
 			LM_ERR("sca_create_canonical_aor: failed to create AoR from "
-					"Contact <%.*s> and URI <%.*s>\n",
+				   "Contact <%.*s> and URI <%.*s>\n",
 					STR_FMT(&contact_uri), STR_FMT(&tf_aor));
 			goto done;
 		}
@@ -423,7 +429,8 @@ int sca_create_canonical_aor_for_ua(sip_msg_t *msg, str *c_aor, int ua_opts)
 
 	rc = 1;
 
-	done: return (rc);
+done:
+	return (rc);
 }
 
 int sca_create_canonical_aor(sip_msg_t *msg, str *c_aor)
@@ -444,34 +451,36 @@ int sca_call_is_held(sip_msg_t *msg)
 	int rc;
 
 	if(sca->cfg->onhold_bflag >= 0) {
-		if (isbflagset(0, (flag_t)sca->cfg->onhold_bflag)==1) {
+		if(isbflagset(0, (flag_t)sca->cfg->onhold_bflag) == 1) {
 			LM_DBG("onhold_bflag set, skip parse_sdp and set held\n");
-			return ( 1 );
+			return (1);
 		}
 	}
 	rc = parse_sdp(msg);
-	if (rc < 0) {
+	if(rc < 0) {
 		LM_ERR("sca_call_is_held: parse_sdp body failed\n");
 		return (0);
-	} else if (rc > 0) {
+	} else if(rc > 0) {
 		LM_DBG("sca_call_is_held: parse_sdp returned %d, no SDP body\n", rc);
 		return (0);
 	}
 
 	// Cf. modules_k/textops's exported is_audio_on_hold
-	for (n_sess = 0, session = get_sdp_session(msg, n_sess); session != NULL;
+	for(n_sess = 0, session = get_sdp_session(msg, n_sess); session != NULL;
 			n_sess++, session = get_sdp_session(msg, n_sess)) {
 
-		for (n_str = 0, stream = get_sdp_stream(msg, n_sess, n_str);
+		for(n_str = 0, stream = get_sdp_stream(msg, n_sess, n_str);
 				stream != NULL;
 				n_str++, stream = get_sdp_stream(msg, n_sess, n_str)) {
-			if (stream->is_on_hold) {
-				LM_DBG("sca_call_is_held: parse_sdp detected stream is on hold\n");
+			if(stream->is_on_hold) {
+				LM_DBG("sca_call_is_held: parse_sdp detected stream is on "
+					   "hold\n");
 				is_held = 1;
 				goto done;
 			}
 		}
 	}
 
-	done: return (is_held);
+done:
+	return (is_held);
 }
diff --git a/src/modules/sca/sca_util.h b/src/modules/sca/sca_util.h
index 9dcf705..c191083 100644
--- a/src/modules/sca/sca_util.h
+++ b/src/modules/sca/sca_util.h
@@ -22,7 +22,8 @@
 
 #include "sca_common.h"
 
-enum {
+enum
+{
 	SCA_AOR_TYPE_AUTO = (1 << 0),
 	SCA_AOR_TYPE_UAC = (1 << 1),
 	SCA_AOR_TYPE_UAS = (1 << 2),
