From 40d971af44b60b2c14dcc22693d41ec4ee4af33b Mon Sep 17 00:00:00 2001
From: Daniel-Constantin Mierla <miconda@gmail.com>
Date: Tue, 3 Jul 2018 08:46:58 +0200
Subject: [PATCH] topos: execute event_route[topos:sending] with current sip
 message to be sent

- if drop is used, then the message processing with topos is skipped
- event route is executed after event_route[topos:outgoing]
- new parameter event_mode to control what event_route blocks are
executed
---
 src/modules/topos/topos_mod.c | 51 ++++++++++++++++++++++++++---------
 1 file changed, 38 insertions(+), 13 deletions(-)

diff --git a/src/modules/topos/topos_mod.c b/src/modules/topos/topos_mod.c
index 30090b6b16..1bd9eb6571 100644
--- a/src/modules/topos/topos_mod.c
+++ b/src/modules/topos/topos_mod.c
@@ -84,16 +84,22 @@ extern int _tps_dialog_expire;
 
 int _tps_clean_interval = 60;
 
+#define TPS_EVENTRT_OUTGOING 1
+#define TPS_EVENTRT_SENDING  2
+static int _tps_eventrt_mode = TPS_EVENTRT_OUTGOING | TPS_EVENTRT_SENDING;
 static int _tps_eventrt_outgoing = -1;
 static str _tps_eventrt_callback = STR_NULL;
-static str _tps_eventrt_name = str_init("topos:msg-outgoing");
+static str _tps_eventrt_outgoing_name = str_init("topos:msg-outgoing");
+static int _tps_eventrt_sending = -1;
+static str _tps_eventrt_sending_name = str_init("topos:msg-sending");
 
 sanity_api_t scb;
 
 int tps_msg_received(sr_event_param_t *evp);
 int tps_msg_sent(sr_event_param_t *evp);
 
-static int tps_execute_event_route(sip_msg_t *msg, sr_event_param_t *evp);
+static int tps_execute_event_route(sip_msg_t *msg, sr_event_param_t *evp,
+		int evtype, int evidx, str *evname);
 
 /** module functions */
 /* Module init function prototype */
@@ -121,6 +127,7 @@ static param_export_t params[]={
 	{"dialog_expire",	PARAM_INT, &_tps_dialog_expire},
 	{"clean_interval",	PARAM_INT, &_tps_clean_interval},
 	{"event_callback",	PARAM_STR, &_tps_eventrt_callback},
+	{"event_mode",		PARAM_STR, &_tps_eventrt_mode},
 	{0,0,0}
 };
 
@@ -146,11 +153,16 @@ struct module_exports exports= {
  */
 static int mod_init(void)
 {
-	_tps_eventrt_outgoing = route_lookup(&event_rt, _tps_eventrt_name.s);
+	_tps_eventrt_outgoing = route_lookup(&event_rt, _tps_eventrt_outgoing_name.s);
 	if(_tps_eventrt_outgoing<0
 			|| event_rt.rlist[_tps_eventrt_outgoing]==NULL) {
 		_tps_eventrt_outgoing = -1;
 	}
+	_tps_eventrt_sending = route_lookup(&event_rt, _tps_eventrt_sending_name.s);
+	if(_tps_eventrt_sending<0
+			|| event_rt.rlist[_tps_eventrt_sending]==NULL) {
+		_tps_eventrt_sending = -1;
+	}
 
 	if(faked_msg_init()<0) {
 		LM_ERR("failed to init fmsg\n");
@@ -380,7 +392,8 @@ int tps_msg_sent(sr_event_param_t *evp)
 
 	obuf = (str*)evp->data;
 
-	if(tps_execute_event_route(NULL, evp)==1) {
+	if(tps_execute_event_route(NULL, evp, TPS_EVENTRT_OUTGOING,
+				_tps_eventrt_outgoing, &_tps_eventrt_outgoing_name)==1) {
 		return 0;
 	}
 
@@ -396,7 +409,14 @@ int tps_msg_sent(sr_event_param_t *evp)
 		goto done;
 	}
 
+	if(tps_execute_event_route(&msg, evp, TPS_EVENTRT_SENDING,
+				_tps_eventrt_sending, &_tps_eventrt_sending_name)==1) {
+		goto done;
+	}
+
 	if(msg.first_line.type==SIP_REQUEST) {
+
+
 		dialog = (get_to(&msg)->tag_value.len>0)?1:0;
 
 		local = 0;
@@ -451,7 +471,8 @@ int tps_get_branch_expire(void)
 /**
  *
  */
-static int tps_execute_event_route(sip_msg_t *msg, sr_event_param_t *evp)
+static int tps_execute_event_route(sip_msg_t *msg, sr_event_param_t *evp,
+		int evtype, int evidx, str *evname)
 {
 	struct sip_msg *fmsg;
 	struct run_act_ctx ctx;
@@ -459,7 +480,11 @@ static int tps_execute_event_route(sip_m
 	sr_kemi_eng_t *keng = NULL;
 	struct onsend_info onsnd_info = {0};
 
-	if(_tps_eventrt_outgoing<0) {
+	if(!(_tps_eventrt_mode & evtype)) {
+		return 0;
+	}
+
+	if(evidx<0) {
 		if(_tps_eventrt_callback.s!=NULL || _tps_eventrt_callback.len>0) {
 			keng = sr_kemi_eng_get();
 			if(keng==NULL) {
@@ -470,12 +495,12 @@ static int tps_execute_event_route(sip_m
 		}
 	}
 
-	if(_tps_eventrt_outgoing<0 && keng==NULL) {
+	if(evidx<0 && keng==NULL) {
 		return 0;
 	}
 
-	LM_DBG("executing event_route[topos:...] (%d)\n",
-			_tps_eventrt_outgoing);
+	LM_DBG("executing event_route[topos:%.*s] (%d)\n", evname->len, evname->s,
+			evidx);
 	fmsg = faked_msg_next();
 
 	onsnd_info.to = &evp->dst->to;
@@ -494,12 +519,12 @@ static int tps_execute_event_route(sip_m
 	rtb = get_route_type();
 	set_route_type(REQUEST_ROUTE);
 	init_run_actions_ctx(&ctx);
-	if(_tps_eventrt_outgoing>=0) {
-		run_top_route(event_rt.rlist[_tps_eventrt_outgoing], fmsg, &ctx);
+	if(evidx>=0) {
+		run_top_route(event_rt.rlist[evidx], (msg)?msg:fmsg, &ctx);
 	} else {
 		if(keng!=NULL) {
-			if(keng->froute(fmsg, EVENT_ROUTE,
-						&_tps_eventrt_callback, &_tps_eventrt_name)<0) {
+			if(keng->froute((msg)?msg:fmsg, EVENT_ROUTE,
+						&_tps_eventrt_callback, evname)<0) {
 				LM_ERR("error running event route kemi callback\n");
 				p_onsend=NULL;
 				return -1;
--- a/src/modules/topos/doc/topos_admin.xml
+++ b/src/modules/topos/doc/topos_admin.xml
@@ -257,6 +257,27 @@ end
 </programlisting>
 		</example>
 	</section>
+	<section id="topos.p.event_mode">
+		<title><varname>event_mode</varname> (int)</title>
+		<para>
+			Control what event_route blocks to be executed. It is a bitmask of:
+			1 - execute event_route[topos:outgoing]; 2 - execute
+			event_route[topos:sending].
+		</para>
+		<para>
+		<emphasis>
+			Default value is 3 (execute both event_route blocks).
+		</emphasis>
+		</para>
+		<example>
+		<title>Set <varname>event_mode</varname> parameter</title>
+		<programlisting format="linespecific">
+...
+modparam("topos", "event_mode", 2)
+...
+</programlisting>
+		</example>
+	</section>
 	</section>
 	<section>
 	<title>Event Routes</title>
@@ -283,6 +304,30 @@ event_route[topos:msg-outgoing] {
     drop;
   }
 }
+...
+</programlisting>
+		</example>
+	</section>
+	<section>
+		<title>event_route[topos:msg-sending]</title>
+		<para>
+		It is executed before doing topology stripping processing for a SIP
+		message to be sent out, being executed after event_route[topos:sending].
+		</para>
+		<para>
+		Inside the event route the variables $sndto(ip), $sndto(port) and
+		$sndto(proto) point to the destination. The SIP message is the one
+		to be sent out.
+		</para>
+		<example>
+		<title>Usage of event_route[topos:msg-sending]</title>
+		<programlisting format="linespecific">
+...
+event_route[topos:msg-sending] {
+  if(is_request() and $fU=="alice") {
+    drop;
+  }
+}
 ...
 </programlisting>
 		</example>
